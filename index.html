<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v14.9 Fixed</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.8), inset 0 -3px 6px rgba(0, 0, 0, 0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body {
            margin: 0;
            background-color: var(--bg-main);
            background-image: var(--paw-pattern);
            background-size: 80px 80px;
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: 0.3s;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
        .screen-shake {
            animation: jelly-bounce 0.5s both;
        }

        @keyframes jelly-bounce {
            0% { transform: scale(1, 1); }
            30% { transform: scale(1.15, 0.85); }
            40% { transform: scale(0.9, 1.1); }
            50% { transform: scale(1.05, 0.95); }
            65% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); }
        }

        /* ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ */
        button {
            font-family: var(--font-main);
            border-radius: 25px;
            border: none;
            background: #fff;
            color: #777;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-radius: 20px;
            pointer-events: none;
        }

        button:active {
            transform: translateY(3px) scale(0.98);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .btn-restart {
            padding: 8px 12px;
            font-size: 14px;
            color: var(--accent);
        }

        .btn-restart:hover {
            background: #fff0f5;
        }

        .mute-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #eee;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: 0.2s;
        }

        .mute-btn:active {
            transform: scale(0.9);
        }

        .mute-btn.muted {
            background: #ffebee;
            color: #e57373;
            border-color: #ffcdd2;
        }

        /* ë ˆì´ì•„ì›ƒ */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden;
        }

        #selection-screen {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        #battle-screen {
            display: none;
            padding: 5px;
            height: 100%;
            justify-content: space-between;
        }

        /* ì˜ì›… ì¹´ë“œ (ì„ íƒ í™”ë©´) */
        .hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            overflow-y: auto;
            padding: 5px;
            flex: 1;
        }

        .hero-card {
            background: #fff;
            border-radius: 20px;
            padding: 6px;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05), inset 0 0 0 3px #fce4ec;
            position: relative;
            min-height: 100px;
            justify-content: center;
        }

        .hero-card:active {
            transform: scale(0.95);
        }

        .hero-card.selected {
            background: #e1bee7;
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }

        .hero-card.selected::after {
            content: 'ğŸ¾';
            position: absolute;
            top: -10px;
            right: -5px;
            background: var(--accent);
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            z-index: 5;
            border: 2px solid #fff;
        }

        /* ì „íˆ¬ ìœ ë‹› (Battle Unit) */
        .field-row {
            flex: 1;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            perspective: 1000px;
            padding: 5px 0;
            min-height: 0;
        }

        .unit {
            width: 30vw;
            max-width: 130px;
            background: #fff;
            border-radius: 20px;
            padding: 8px 4px;
            position: relative;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: default;
            box-shadow: inset 0 4px 10px rgba(255, 255, 255, 1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 110px;
            justify-content: flex-end;
            border: 2px solid #f8bbd0;
            flex-shrink: 1;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ê°ì„± ìŠ¤íƒ€ì¼ (Super Hero) */
        .unit.super-hero {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.5) !important;
            animation: super-pulse 1.5s infinite alternate;
            z-index: 10;
        }

        @keyframes super-pulse {
            0% { box-shadow: 0 0 10px #ffb300; border-color: #ffb300; }
            100% { box-shadow: 0 0 25px #ff6f00; border-color: #ffca28; }
        }

        .unit.active-turn {
            border-color: var(--accent);
            transform: translateY(-12px) scale(1.05);
            z-index: 5;
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3);
        }

        .unit.target-enemy:hover {
            border-color: #ff7043;
            background: #ffebee;
            cursor: crosshair;
            transform: scale(1.05) rotate(2deg);
        }

        .unit.target-ally:hover {
            border-color: #66bb6a;
            background: #e8f5e9;
            cursor: pointer;
            transform: scale(1.05) rotate(-2deg);
        }

        .unit.target-aoe {
            border-color: #ff7043;
            background: #ffebee;
            animation: jelly-bounce 1s infinite;
            cursor: pointer;
        }

        .unit.dead {
            opacity: 0.6;
            filter: grayscale(1);
            pointer-events: none;
            border-color: #cfd8dc;
            transform: scale(0.9) rotate(5deg);
            box-shadow: none;
        }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-bottom: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            color: #fff;
            position: relative;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            border: 3px solid #fff;
            flex-shrink: 0;
        }

        .mini-attr-box {
            position: absolute;
            bottom: -2px;
            right: -2px;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 12px;
            border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mini-icon { font-size: 10px; line-height: 1; }

        .elec-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ffeb3b;
            color: #f57f17;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        .status-bar {
            width: 85%;
            height: 10px;
            background: #eceff1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .hp-fill {
            height: 100%;
            background: var(--hp-high);
            border-radius: 10px;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
        }

        .shield-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--shield);
            opacity: 0.8;
            border-radius: 10px;
            transition: width 0.3s;
        }

        .control-panel {
            flex: 0 0 auto;
            max-height: 45vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px 30px 0 0;
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            border-top: 5px solid #ff80ab;
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        .cp-header {
            padding: 8px 15px;
            background: #fff8e1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px dashed #ffe082;
            font-size: 14px;
        }

        .timeline-container {
            height: 40px;
            background: #fff;
            border-bottom: 2px dashed #ffcdd2;
            display: flex;
            align-items: center;
            padding: 0 10px;
            overflow: hidden;
            gap: 5px;
            flex-shrink: 0;
        }

        .timeline-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
            margin-right: 5px;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); }
        }

        .tl-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            border: 2px solid #eee;
            position: relative;
            flex-shrink: 0;
            transition: 0.3s;
            background: #fff;
            box-shadow: 0 2px 0 #ddd;
        }

        .tl-node.curr {
            border-color: var(--accent);
            transform: scale(1.3);
            z-index: 2;
            border-width: 3px;
            animation: active-pulse 1.5s infinite;
        }

        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            border-bottom: 2px solid #f0f0f0;
            background: #fff;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            min-height: 50px;
            max-height: 120px;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            background: #fafafa;
            border-radius: 10px;
            word-break: keep-all;
            border-left: 3px solid #eee;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .log-ally { color: #29b6f6; font-weight: bold; }
        .log-enemy { color: #ff7043; font-weight: bold; }
        .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }

        /* [UI ê°œì„ ] ë†’ì´ ìœ ë™ì  ë³€ê²½ (ì˜ë¦¼ ë°©ì§€) */
        .btn-group {
            display: flex;
            min-height: 80px;
            height: auto;
            flex-shrink: 0;
            padding: 5px;
            gap: 5px;
            background: #fff5f8;
        }

        .skill-btn {
            flex: 1;
            border: none;
            background: #fff;
            border-radius: 15px;
            cursor: pointer;
            transition: 0.2s;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 4px;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
        }

        .skill-btn::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            border-radius: 15px;
            pointer-events: none;
        }

        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }

        .passive-panel {
            background: #e0f2f1;
            padding: 5px 10px;
            font-size: 11px;
            color: #00695c;
            display: flex;
            align-items: center;
            border-radius: 10px;
            margin: 4px 10px;
            border: 1px solid #b2dfdb;
            flex-shrink: 0;
        }

        .passive-icon { margin-right: 5px; font-size: 14px; }

        .btn-start {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 20px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 5px 0 #c2185b, 0 10px 15px rgba(0, 0, 0, 0.15);
            transition: 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(5px); box-shadow: 0 0 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-rnd {
            background: #b39ddb;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            box-shadow: 0 4px 0 #7e57c2;
        }

        .btn-rnd:active { transform: translateY(4px); box-shadow: none; }

        .tag-container {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
            max-height: 36px;
            overflow: hidden;
            align-content: flex-start;
        }

        .tag {
            padding: 2px 4px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 1px;
            white-space: nowrap;
            height: 14px;
            display: flex;
            align-items: center;
        }

        .tag.poison { background: #ab47bc; }
        .tag.stun { background: #ffd54f; color: #5d4037; }
        .tag.freeze { background: #29b6f6; }
        .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; }
        .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; }
        .tag.bind { background: #66bb6a; }
        .tag.trap { background: #d4e157; color: #5d4037; }
        .tag.atkdown { background: #5c6bc0; }
        .tag.growth { background: #9ccc65; color: #33691e; }
        .tag.blind { background: #bdbdbd; color: #5d4037; }
        .tag.immunity { background: #fff; color: #5d4037; border: 1px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color: #fff; }
        .tag.atkup { background: #ef5350; color: #fff; }
        .tag.taunt {
            background: #212121;
            color: #ff5252;
            border: 1px solid #ff1744;
            box-shadow: 0 0 4px rgba(255, 23, 68, 0.6);
            font-weight: 900;
        }
        .tag.karma {
            background: #512da8;
            color: #fff;
            border: 1px solid #d1c4e9;
            animation: jelly-bounce 2s infinite;
        }
        /* ì„ ê³µë°©ì–´ ë©´ì—­ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.start-immunity { background: #00bcd4; color: #fff; border: 1px solid #80deea; box-shadow: 0 0 5px #00e5ff; }
        /* [ì‹ ê·œ] ì„¸ë‡Œ ê´€ë ¨ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.mc-wait { background: #5e35b1; color: #fff; border: 1px solid #b39ddb; animation: jelly-bounce 2s infinite; }
        .tag.mc-ready { background: #d500f9; color: #fff; border: 2px solid #ea80fc; box-shadow: 0 0 10px #d500f9; font-weight:900; }

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color: #1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color: #5d4037; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color: #5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        /* [ë°ë¯¸ì§€ í°íŠ¸ ì„¸ë¶„í™”] */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 28px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        .ft-dmg { color: #ff7043; }
        .ft-crit { color: #ffa726; font-size: 36px; text-shadow: 2px 2px 0 #d84315; }
        .ft-heal { color: #26a69a; animation: floatUpSlow 1.2s ease-out forwards; }
        .ft-miss { color: #b0bec5; font-size: 20px; }
        .ft-weak { color: #d32f2f; font-size: 32px; font-weight: 900; animation: shake-dmg 0.4s ease-in-out; }
        .ft-resist { color: #78909c; font-size: 18px; opacity: 0.8; }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        @keyframes floatUpSlow {
            0% { transform: translate(-50%, 0); opacity: 0; }
            50% { transform: translate(-50%, -40px); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        @keyframes shake-dmg {
            0%, 100% { transform: translate(-50%, -20px); }
            25% { transform: translate(-55%, -20px); }
            75% { transform: translate(-45%, -20px); }
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 248, 225, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 35px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3);
            overflow-y: auto;
            max-height: 80vh;
            border: 5px solid #ffcc80;
            position: relative;
        }

        /* [ì»·ì‹ ] ìŠ¤íƒ€ì¼ */
        #cut-in-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cut-in-img {
            font-size: 120px;
            animation: cut-in-zoom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .cut-in-text {
            font-size: 40px;
            color: #fff;
            font-weight: 900;
            margin-top: 20px;
            animation: slide-up 0.5s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes cut-in-zoom {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes slide-up {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* [íˆ´íŒ] ìŠ¤íƒ€ì¼ */
        #tooltip-view {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 150;
            max-width: 200px;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
            text-align: left;
        }

        .tooltip-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 45vh; }
            .btn-group { min-height: 72px; height: auto; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 10px; display: block; line-height: 1.2; }
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
/* [ì‹ ê·œ] ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° & ê°ì •í‘œí˜„ */
        .hp-preview {
            position: absolute; top: 0; right: 0; bottom: 0;
            background: rgba(255, 23, 68, 0.6); /* ë¶‰ì€ìƒ‰ ë¹—ê¸ˆ */
            z-index: 2; pointer-events: none;
            transition: width 0.2s;
            box-shadow: -2px 0 0 rgba(255,255,255,0.5);
        }
        .emote-bubble {
            position: absolute; top: -45px; left: 50%; transform: translateX(-50%);
            background: #fff; border: 3px solid #333; border-radius: 20px;
            padding: 8px 12px; font-size: 24px; z-index: 50;
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            white-space: nowrap; pointer-events: none;
        }
        @keyframes pop-in { from { transform: translateX(-50%) scale(0); } to { transform: translateX(-50%) scale(1); } }
        
        .emote-menu {
            position: absolute; display: flex; gap: 8px; 
            background: rgba(255,255,255,0.95); padding: 8px; 
            border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 100; border: 2px solid #eee;
            animation: fade-up 0.2s;
        }
        @keyframes fade-up { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
        .emote-btn { 
            font-size: 22px; cursor: pointer; transition: 0.2s; 
            width: 36px; height: 36px; border-radius: 50%; 
            display:flex; align-items:center; justify-content:center;
        }
        .emote-btn:hover { transform: scale(1.2); background: #f0f0f0; }
        /* [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (ì‹œê°„ ì •ì§€ íš¨ê³¼) */
        body.hit-stopped .unit,
        body.hit-stopped .float-text {
            animation-play-state: paused !important;
            transition: none !important;
        }
       /* [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë° íƒ€ê²© ì´í™íŠ¸ */
        .projectile {
            position: absolute;
            font-size: 24px;
            z-index: 150;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        .impact-effect {
            position: absolute;
            font-size: 40px;
            z-index: 151;
            pointer-events: none;
            animation: impact-pop 0.3s ease-out forwards;
        }
        @keyframes impact-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
/* [ì‹ ê·œ] ì˜¤ë””ì˜¤ ì„¤ì • UI */
        .settings-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .settings-btn:active { transform: scale(0.9); }

        .settings-modal {
            display: none; position: absolute; top: 60px; right: 15px;
            width: 240px; background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 15px; z-index: 110;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); border: 2px solid #ffcc80;
            backdrop-filter: blur(5px); flex-direction: column; gap: 10px;
        }
        .set-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #5d4037; font-weight: bold; }
        .vol-slider { flex: 1; margin-left: 10px; accent-color: #ff80ab; height: 6px; }
        
        .bgm-select { display: flex; gap: 5px; margin-top: 5px; }
        .bgm-opt { 
            flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 10px; 
            background: #fff; font-size: 11px; cursor: pointer; text-align: center; color: #888;
        }
        .bgm-opt.active { background: #fff8e1; border-color: #ffb74d; color: #f57c00; font-weight: bold; }
        
        .toggle-btn {
            width: 40px; height: 20px; background: #ccc; border-radius: 20px;
            position: relative; cursor: pointer; transition: 0.3s;
        }
        .toggle-btn.on { background: #66bb6a; }
        .toggle-btn::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            transition: 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-btn.on::after { left: 22px; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div>
<!-- [ì»·ì‹ ] ì˜¤ë²„ë ˆì´ -->
<div id="cut-in-overlay">
    <div class="cut-in-img" id="cut-in-emoji">ğŸ¦</div>
    <div class="cut-in-text" id="cut-in-msg">FINISH!</div>
</div>
<!-- [íˆ´íŒ] ë·° -->
<div id="tooltip-view"></div>

<div class="settings-btn" onclick="UI.toggleSettings()">ğŸµ</div>
<div id="audio-settings" class="settings-modal">
    <div class="set-row">
        <span>ë³¼ë¥¨</span>
        <input type="range" class="vol-slider" min="0" max="100" value="50" oninput="AudioSys.setMasterVolume(this.value)">
    </div>
    <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
    <div class="set-row">
        <span>ë°°ê²½ìŒì•… (BGM)</span>
        <div class="toggle-btn on" id="tog-bgm" onclick="AudioSys.toggleChannel('bgm')"></div>
    </div>
    <div style="font-size:11px; color:#888; margin-top:5px;">ğŸ¹ New Piano Collection</div>
    <div class="bgm-select">
    <div class="bgm-opt" onclick="UI.selectBGM('Battle_Piano', this)">âš”ï¸ ì „íˆ¬</div>
    <div class="bgm-opt" onclick="UI.selectBGM('Thinking', this)">ğŸ¤” ì „ëµ</div>
    <div class="bgm-opt" onclick="UI.selectBGM('Aftermath', this)">ğŸŒ… í‰í™”</div>
    </div>

    <div style="font-size:11px; color:#888; margin-top:5px;">ğŸ¼ Canon Variations (Original)</div>
    <div class="bgm-select">
        <div class="bgm-opt active" onclick="UI.selectBGM('Canon_Piano', this)">ğŸ¹ í”¼ì•„ë…¸</div>
        <div class="bgm-opt" onclick="UI.selectBGM('Canon_Harp', this)">ğŸ» í•˜í”„</div>
        <div class="bgm-opt" onclick="UI.selectBGM('Canon_Mix', this)">âœ¨ ë¯¹ìŠ¤</div>
    </div>
    <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
        <div class="set-row">
        <span>íš¨ê³¼ìŒ (SFX)</span>
        <div class="toggle-btn on" id="tog-sfx" onclick="AudioSys.toggleChannel('sfx')"></div>
    </div>
</div>

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v12.1 Fixed (AI Crash & Save/Load)</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="UI.showCollection()">ğŸ’ Codex</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="btn-online" class="btn-start" style="flex:1; background:#7e57c2; font-size:16px;" onclick="UI.openOnlineModal()">
                ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
            </button>
            <button id="btn-start" class="btn-start" style="flex:1; font-size:16px;" onclick="Game.start()" disabled>
                âš”ï¸ ì „íˆ¬ ì‹œì‘
            </button>
        </div>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
let socket;
// ==================== [ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸°] ====================
class SeededRandom {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0) this.seed += 2147483646;
    }
    
    next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    }
}

let globalRNG = null; // ì „ì—­ RNG ì¸ìŠ¤í„´ìŠ¤
if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {},
        emit: () => {},
        connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ");
}

let myRole = null;
let myRoom = null;
let isOnlineMode = false;
let netRndBuffer = []; // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ í˜¸í™˜ì„± ìœ ì§€
let netRndIdx = 0;
let isReplaying = false;
let gameSeed = null; // ì„œë²„ì—ì„œ ë°›ì€ ì‹œë“œ ì €ì¥

// [New] ë””ë²„ê·¸ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë„êµ¬
const DEBUG = {
    enabled: false, // ì½˜ì†”ì—ì„œ DEBUG.toggle()ë¡œ ì¼¤ ìˆ˜ ìˆìŒ
    log: function(...args) { if (this.enabled) console.log('%c[DEBUG]', 'color:cyan; font-weight:bold;', ...args); },
    error: function(...args) { if (this.enabled) console.error('%c[DEBUG ERR]', 'color:red; font-weight:bold;', ...args); },
    toggle: function() { this.enabled = !this.enabled; console.log(`ğŸ•µï¸ Debug Mode: ${this.enabled ? 'ON' : 'OFF'}`); }
};

const PERF = {
    timers: {},
    start: function(label) { if(DEBUG.enabled) this.timers[label] = performance.now(); },
    end: function(label) {
        if (DEBUG.enabled && this.timers[label]) {
            const t = performance.now() - this.timers[label];
            console.log(`%câ±ï¸ [PERF] ${label}: ${t.toFixed(2)}ms`, 'color:orange');
            delete this.timers[label];
        }
    }
};

// [ì¶”ê°€] ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('âš ï¸ Global Error:', {
        message: msg,
        line: lineNo,
        column: columnNo,
        error: error
    });
    
    // ê²Œì„ì´ ì´ë¯¸ ëë‚¬ê±°ë‚˜, Game ê°ì²´ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    if (typeof Game === 'undefined' || Game.isOver) return false;

    // ê²Œì„ ì¤‘ë‹¨ ë°©ì§€ (ìë™ ë³µêµ¬ ì‹œë„)
    if (Game.timer) clearTimeout(Game.timer);
    if (Game.watchdog) clearTimeout(Game.watchdog);
    
    // UIì— ì•Œë¦¼ í‘œì‹œ (Game.logê°€ ìˆë‹¤ë©´)
    if (Game.log) {
        Game.log("<span class='log-sys' style='color:red;'>âš ï¸ ì˜¤ë¥˜ ë°œìƒ! ìë™ ë³µêµ¬(í„´ ë„˜ê¸°ê¸°) ì‹œë„ ì¤‘...</span>");
    }

    // 1ì´ˆ ë’¤ ê°•ì œë¡œ í„´ì„ ë„˜ê²¨ì„œ ê²Œì„ì„ ì‚´ë¦¼
    setTimeout(() => {
        try {
            if (Game.endTurn) Game.endTurn();
        } catch(e) {
            console.error('Recovery failed:', e);
            alert("ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
        }
    }, 1000);
    
    return true; // ì—ëŸ¬ê°€ ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë¹¨ê°›ê²Œ ë„ë°°ë˜ëŠ” ê²ƒì„ ë°©ì§€
};

function getNetRandom() {
    // ì˜¨ë¼ì¸ ëª¨ë“œ: ì„œë²„ ì‹œë“œ ê¸°ë°˜ RNG ì‚¬ìš©
    if (isOnlineMode && globalRNG) {
        return globalRNG.next();
    }
    // ì˜¤í”„ë¼ì¸ ëª¨ë“œ: ì¼ë°˜ ë‚œìˆ˜
    return Math.random();
}

socket.on('gameStart', (data) => {
    isOnlineMode = true;
    myRole = data.role;
    myRoom = data.room;
    gameSeed = data.seed; // ì„œë²„ ì‹œë“œ ì €ì¥
    
    // ğŸ² ì‹œë“œ ê¸°ë°˜ RNG ì´ˆê¸°í™”
    globalRNG = new SeededRandom(gameSeed);
    console.log(`ğŸ² RNG ì´ˆê¸°í™” ì™„ë£Œ (Seed: ${gameSeed})`);
    
    UI.closeModal();
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display = 'none';
    document.getElementById('battle-screen').style.display = 'flex';
    document.getElementById('logs').innerHTML = '';
    Game.difficulty = 'online';
    Game.mode = 'pvp';
    Game.turnCount = 1;
    Game.isOver = false;

    if (myRole === 'player2') Game.queue = [1, 0, 3, 2, 5, 4];
    else Game.queue = [0, 1, 2, 3, 4, 5];
    Game.curr = 0;
    Game.isProcessing = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra);
    });
    const enemyIndices = data.enemyDeck;
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(enIds[i], 1, original.base, original.extra);
    });
    Game.render();

    // [ì„ /í›„ê³µ ë³´ì •] ì˜¨ë¼ì¸ ëª¨ë“œ: í›„ê³µì—ê²Œ ë°©ì–´ë§‰ ë¶€ì—¬
    if (myRole === 'player2') {
        Game.pTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.log("<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ ë³´ë„ˆìŠ¤: ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ìƒíƒœ!</span>");
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.eTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.timer = setTimeout(() => Game.turn(), 1000);
    }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    
    if (attacker) {
        // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
        if (data.mcState) {
            if (data.mcState.isMindControlling) {
                const mcTarget = allUnits.find(u => u.id === data.mcState.mcTargetId);
                Game.isMindControlling = mcTarget || null;
                Game.currentMCCasterId = data.mcState.mcCasterId || null;
            } else {
                Game.isMindControlling = null;
                Game.currentMCCasterId = null;
            }
        }
        
        // RNGëŠ” ì´ë¯¸ ë™ê¸°í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ ë¶ˆí•„ìš”
        Game.execute(attacker, target, data.skillIdx, true);
    }
});

socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)");
    
    // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬
    isOnlineMode = false;
    globalRNG = null;
    gameSeed = null;
    Game.isMindControlling = null;
    Game.currentMCCasterId = null;
});

socket.on('waiting', (msg) => {
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.innerText = "â³ " + msg;
        btn.disabled = true;
    }
});

socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.disabled = false;
        btn.innerText = "ì…ì¥í•˜ê¸° ğŸš€";
    }
});

function startOnlineGame(code) {
    AudioSys.init();
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
    }
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    socket.emit('findMatch', {
        deck: Game.selected,
        roomCode: code
    });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+30%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15/ë°ë¯¸ì§€X', type:'CC', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë°›ëŠ” í”¼í•´ MaxHP 30% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ê³µ+18/ì‰´ë“œ+30(ì˜êµ¬ì¤‘ì²©)', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'ALLY', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤<br>ìê°€ì„±ì¥ + í', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(3í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 25%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ 1íšŒ ìë™ íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.6ë°° +í™”ìƒ(60%)', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(30%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ (ìœ í†µê¸°í•œ)', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2í„´ ê³µ+20, 3~6í„´ ê³µ+10, 7í„´ ì´í›„ 0' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'âš–ï¸', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°© (ì•½ì :ë‹¨ì¼ê¸°ì´ˆ5ì†ì„±) + ì„œë¸Œíƒ±í‚¹', passive:'ğŸ² ë©´ì—­: í–‰ë™ ì œì–´ê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ,ì„¸ë‡Œ)ì— ê±¸ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.'},
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ(100%)', s2:'ì†Œê°', s2d:'1.0ë°°+ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€íƒ€', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì—­ì´ìš© ì¹´ìš´í„°', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ê³µê²©ë ¥ì´ ë†’ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+ìê°€ê¸°ì ˆ(1í„´ íœ´ì‹)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ/ì¹¨ë¬µ(30%)', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ê¸°ì ˆ / ì¹¨ë¬µ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²°', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.3ë°°/CCê±¸ë¦°ì  1.5ë°°', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…(3í„´)', type:'DEBUFF', target:'ALL_ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë²„í”„ ì œê±° + ì¡°ê±´ë¶€í­ë”œ', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°(ê´€í†µ)+ì‰´ë“œíƒ€ê²©0.6ë°°', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•+ì¹˜ìœ ê°ì†Œ(60%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì‰´ë“œ íŒŒê´´ì', passive:null },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë°˜ì‚¬ê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì˜êµ¬ ì¦ê°€.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´120+(20%í™•ë¥ 50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.3ë°°+ì•„êµ°ëœë¤í20', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + íšŒë³µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬50%)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.3ë°°/ê³µ35%â†“/ì‰´ë“œ30%íŒŒê´´', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.8ë°°+ì¹¨ë¬µ(1í„´)', s2:'ì •ì‹ ì§€ë°°', s2d:'HP15%ì†Œëª¨/ì„¸ë‡Œ(30~55%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ§ ', desc:'ì‹¬ì—°ì˜ ì§€ë°°ì<br>ì  ì œì–´ê¶Œ íƒˆì·¨', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ì„¸ë‡Œ ì„±ê³µë¥ ì€ ê¸°ë³¸ 30%ì´ë©°, ëŒ€ìƒì˜ ì²´ë ¥ì´ ë‚®ì„ìˆ˜ë¡ ìµœëŒ€ 55%ê¹Œì§€ ì¦ê°€í•©ë‹ˆë‹¤. ì„±ê³µ ì‹œ ë‹¤ìŒ í„´ ì ì„ 1íšŒ ì¡°ì¢…í•©ë‹ˆë‹¤.' }
};

// [ì‹ ê·œ] Emotion Alias Database (English)
const EMOTION_DB = {
    'Fire': { t: 'Rage', d: 'Burning instinct of destruction' },
    'Water': { t: 'Sorrow', d: 'Cold grief that freezes the heart' },
    'Tree': { t: 'Vigor', d: 'Unstoppable life force' },
    'Metal': { t: 'Coldness', d: 'Reason without emotion' },
    'Earth': { t: 'Stoicism', d: 'Unshakable calmness' },
    'Light': { t: 'Bliss', d: 'Pure joy and light' },
    'Dark': { t: 'Terror', d: 'Fear of the unknown' },
    'Normal': { t: 'Void', d: 'Emptiness unaffected by anything' },
    
    'Fire-Light': { t: 'Passion', d: 'Rage sublimated into positivity' },
    'Fire-Dark': { t: 'Madness', d: 'Uncontrollable frenzy' },
    'Water-Light': { t: 'Compassion', d: 'Sorrow that embraces others' },
    'Water-Dark': { t: 'Misery', d: 'Solidified pain and cold' },
    'Tree-Light': { t: 'Hope', d: 'A forest embracing everyone' },
    'Tree-Dark': { t: 'Obsession', d: 'Twisted love and pain' },
    'Metal-Light': { t: 'Critique', d: 'Sharp and piercing analysis' },
    'Metal-Dark': { t: 'Thrill', d: 'Hidden stimulating excitement' },
    'Earth-Light': { t: 'Tenacity', d: 'Persistence that never lets go' },
    'Earth-Dark': { t: 'Pride', d: 'Overwhelming weight of arrogance' },
    'Light-Light': { t: 'Salvation', d: 'Liberation from suffering' },
    'Dark-Dark': { t: 'Domination', d: 'Power to control minds' }
};

// [ì‹ ê·œ] Title Manager (Unlock System)
const TitleManager = {
    unlocked: JSON.parse(localStorage.getItem('et_titles_en') || '[]'),
    unlock: function(key) {
        if (!this.unlocked.includes(key)) {
            this.unlocked.push(key);
            localStorage.setItem('et_titles_en', JSON.stringify(this.unlocked));
            return true;
        }
        return false;
    }
};

const ChallengeDB = [
    { name: "ë¶€ë™ì˜ ì² ì˜¹ì„±", desc: "ì‡ (Metal)ê°€ ë§‰ê³  ë¬¼(Water)ì´ ì±„ìš°ë©° ë¶ˆ(Fire)ì´ ë•Œë¦½ë‹ˆë‹¤.", team: ['Metal', 'Water', 'Fire'] },
    { name: "ë¬´í•œ í†µì œ", desc: "ë¹™ê²°, ê¸°ì ˆ, ê¸°ì ˆ... ìˆ¨ ì‰´ í‹ˆì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.", team: ['Water-Dark', 'Earth', 'Metal-Dark'] },
    { name: "í¡í˜ˆ ê·€ì¡±ë‹¨", desc: "í‘¸ë¥¸ë¶ˆ(Fire-Light)ì˜ í¡í˜ˆ ë¶€ì—¬ì™€ ë‚˜ë¬´(Tree)ì˜ ìœ ì§€ë ¥.", team: ['Fire-Light', 'Tree', 'Fire'] },
    { name: "ì‹¬ë¦¬ì „ì˜ ëŒ€ê°€", desc: "ë°˜ì‚¬(ì—…ë³´)ì™€ ë³µìˆ˜(ê°€ì‹œ)ë¡œ ë”œë ˆë§ˆë¥¼ ìœ ë°œí•©ë‹ˆë‹¤.", team: ['Dark', 'Tree-Dark', 'Normal'] },
    { name: "ì‰´ë“œ íŒŒê´´ì", desc: "ì‰´ë“œë¥¼ ê´€í†µí•˜ê³  ë„íŠ¸ ë°ë¯¸ì§€ë¡œ ë§ë ¤ ì£½ì…ë‹ˆë‹¤.", team: ['Earth-Light', 'Fire-Dark', 'Metal-Light'] },
    { name: "ì„¸ë‡Œ ê³µì‘", desc: "ë‚´ ìœ ë‹›ì´ ì ì´ ë˜ëŠ” ê³µí¬ë¥¼ ëŠê»´ë³´ì„¸ìš”.", team: ['Dark-Dark', 'Metal', 'Water-Light'] },
    { name: "ì´ˆë°˜ ìŠ¤ë…¸ìš°ë³¼", desc: "ì´ˆë°˜ ê¹¡íŒ¨ ë¶ˆ(Fire)ê³¼ ê°•ë ¥í•œ í•œë°© ë°”ìœ„(Earth-Dark).", team: ['Fire', 'Earth-Dark', 'Metal'] },
    // [ìˆœì„œ ê³ ì •] ë¹›ê°•í™”(ì‰´ë“œ/ì •í™”) -> ë°”ìœ„(2.5ë°° ë”œ) ì½¤ë³´
    { name: "ëŒ€ì§€ì˜ ë¶„ë…¸", desc: "ì •í™” ë°›ì€ ë°”ìœ„(Earth-Dark)ì˜ 2.5ë°° í•µí€ì¹˜ ì—°ê³„.", team: ['Light-Light', 'Earth-Dark', 'Water'], fixedOrder: true },
    { name: "ìš´ë¹¨ ì¡´ë§ê²œ", desc: "ì„¸ë‡Œ, ì •í™”, ê·¸ë¦¬ê³  ë…¸ë§ì˜ ëœë¤ ì£¼ì‚¬ìœ„.", team: ['Dark-Dark', 'Light-Light', 'Normal'] },
    // [ìµœì¢… ë³´ìŠ¤]
    { name: "ì‹¬ì—°ì˜ ë§¹ë…", desc: "ì„¸ë‡Œ(Dark-Dark), ë§¹ë…/í•´ì œ(Metal-Light), í(Water)ì˜ ìµœì•… ì¡°í•©.", team: ['Dark-Dark', 'Metal-Light', 'Water'] }
];

const Common = {
    logAction: function(game, type, source, target, value, extra='') {
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else { msg = `[${source.name.split(' ')[0]}] ${extra}`; }
        game.log(msg);
    },
    basicAttack: function(atk, def, game) {
        AudioSys.play('HIT');
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); UI.floatText(atk, "BLINDED", "ft-miss"); return; }
        const baseAtk = atk.getAtk();
        const aff = (def && def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * 1.0 * aff.v * blindMod);
        const act = def.takeDamage(dmg, false, false, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) {
            Common.logAction(game, 'dmg', atk, def, act, aff.t);
            const isCrit = (act >= 200) || (atk.isNormal && def.isNormal && act > baseAtk);
            let type = isCrit ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type);
            if (isCrit || aff.v > 1.0) { 
                AudioSys.play('CRITICAL'); 
                UI.screenShake(); 
                UI.hitStop(150); // âš¡ íˆíŠ¸ ìŠ¤í†± ì¶”ê°€! (0.15ì´ˆ ë©ˆì¶¤)
            } else {
                game.shake(def);
            }
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.25));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else {
            Common.logAction(game, 'miss', atk, def, 0); UI.floatText(def, "MISS", "ft-miss");
        }
    },
    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { UI.floatText(atk, "BLINDED", "ft-miss"); Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); return -1; }
        const baseAtk = atk.getAtk();
        const aff = (def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * mult * aff.v);
        const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) { 
            let type = act>=200 ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type); 
            game.shake(def); 
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.25));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else { 
            UI.floatText(def, "MISS", "ft-miss"); 
        }
        return act;
    },
    // [ìˆ˜ì •] ì„¸ë‡Œ ìƒíƒœì¼ ë•Œ í”¼ì•„ì‹ë³„ ë°˜ì „ ë¡œì§ (ê´‘ì—­ê¸° ë²„ê·¸ ìˆ˜ì •)
    forEachAlly: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì ì´ ë‚´ ì•„êµ°
        }
        const team = effectiveTeam === 0 ? game.pTeam : game.eTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    },
    forEachEnemy: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì›ë˜ ì•„êµ°ì´ ì 
        }
        const team = effectiveTeam === 0 ? game.eTeam : game.pTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    }
};

const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                // [Balance] í™”ìƒ í™•ë¥  60% ì ìš©
                const act = Common.applyDamage(atk, def, 1.6, game, false, true);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.60) def.addStatus('BURN', 2, 0, atk);
                }
            } else {
                // ... (S2 ë©”í…Œì˜¤ëŠ” ê¸°ì¡´ ìœ ì§€)
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.30) e.addStatus('BURN', 2, 0, atk);
                });
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    let amt = 120;
                    if (game.netRandom() < 0.2) {
                        amt += 50;
                        UI.floatText(a, "Lucky!", "ft-crit");
                    }
                    const h = a.heal(amt);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
                return false;
            }
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê´‘í•©ì„± ğŸŒ¿`);
                AudioSys.play('POWER_UP');
                atk.atk += 18;
                atk.shield += 30;
                atk.growthStack = (atk.growthStack || 0) + 1;
                atk.addStatus('GROWTH', 99);
                game.recordStat(atk, 'shield', 30);
                UI.floatText(atk, "ì„±ì¥", "ft-heal");
                Common.logAction(game, 'shield', atk, atk, 30, "(ì„±ì¥)");
                return false;
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                const h = def.heal(150);
                def.cleanse();
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(ì •í™”)");
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const absorb = Math.floor(act * 0.3);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸª¨`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if (game.netRandom() < 0.25) def.addStatus('STUN', 1, 0, atk);
                    else if (game.netRandom() < 0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u => !u.isDead).length;
                const eAlive = game.eTeam.filter(u => !u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, mult, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 70;
                    const existing = a.status.find(s => s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    a.addStatus('LIGHT_MIGHT', 2, nextVal);
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.3, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s => s.type === 'ATK_DOWN');
                        e.status = e.status.filter(s => s.type !== 'ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear ? 35 : 20, atk);
                        if (e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                if (atk.hp > 30) {
                    atk.hp -= 30;
                    UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                    if (target) {
                        target.shield += 60;
                        game.recordStat(atk, 'shield', 60);
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í¡í˜ˆ ë¶€ì—¬ ğŸ©¸`);
                Common.forEachAlly(atk, game, (a) => {
                    // [Fix] ë²„í”„ ì´ë¦„ í†µì¼ (VAMP -> LIFESTEAL_BUFF)
                    a.addStatus('LIFESTEAL_BUFF', 3, 0, atk);
                });
            } else {
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                Common.forEachAlly(atk, game, (a) => a.addStatus('ATK_BUFF_SMALL', 1));
                return false;
            }
        }
    },
    'Water-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.3) {
                        def.addStatus('BLIND', 1, 0, atk);
                        game.log(" (ì‹¤ëª…!)");
                    }
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ ğŸŒ«ï¸`);
                AudioSys.play('HEAL');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt);
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id !== atk.id) a.addStatus('EVADE', 2);
                });
                return false;
            }
        }
    },
    'Tree-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const alive = allies.filter(a => !a.isDead);
                    if (alive.length > 0) {
                        const t = alive[Math.floor(game.netRandom() * alive.length)];
                        const h = t.heal(20);
                        game.recordStat(atk, 'heal', h);
                        Common.logAction(game, 'heal', atk, t, h, "(ëœë¤í)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.cleanse();
                    const h = a.heal(70);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT'];
                const hadBuff = def.status.some(s => buffs.includes(s.type));
                def.status = def.status.filter(s => !buffs.includes(s.type));
                if (hadBuff) UI.floatText(def, "í•´ì œ", "ft-miss");
                let reduced = false;
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) {
                    def.s2Count--;
                    def.atk -= 20;
                    reduced = true;
                }
                if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) {
                    def.elecStacks--;
                    def.atk -= 10;
                    reduced = true;
                }
                if (def.getKey() === 'Tree' && def.growthStack > 0) {
                    def.growthStack--;
                    def.atk -= 18;
                    def.shield = Math.max(0, def.shield - 30);
                    reduced = true;
                }
                if (reduced) {
                    game.log(" (ğŸ“‰ìŠ¤íƒ ë‹¤ìš´)");
                    UI.floatText(def, "ìŠ¤íƒ-1", "ft-miss");
                }
                
                // [Balance] CC(ê¸°ì ˆ/ë¹™ê²°/ìˆ˜ë©´) ë˜ëŠ” ë§¹ë… ìƒíƒœë©´ ë°ë¯¸ì§€ 50% ì¦ê°€
                const isCC = def.hasStatus('STUN') || def.hasStatus('FREEZE') || def.hasStatus('SLEEP');
                const dmgMult = isCC ? 0.45 : 0.3; // 0.3ì˜ 1.5ë°° = 0.45
                
                const act = Common.applyDamage(atk, def, dmgMult, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, isCC ? "(ì¶”ê°€ë”œ)" : "");
            } else {
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => e.addStatus('POISON', 3, 0, atk));
            }
        }
    },
    'Earth-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                // 1. ì²´ë ¥ ì§ì ‘ íƒ€ê²© (ì‰´ë“œ ë¬´ì‹œ 1.3ë°°)
                const hpAct = Common.applyDamage(atk, def, 1.3, game, true);
                
                if (hpAct !== -1) { // ëª…ì¤‘í–ˆì„ ë•Œë§Œ ì‹¤í–‰
                    Common.logAction(game, 'dmg', atk, def, hpAct, "(ì‰´ë“œë¬´ì‹œ)");
                    
                    // 2. ì‰´ë“œ ì¶”ê°€ íƒ€ê²© (0.6ë°°)
                    if (def.shield > 0) {
                        const aff = game.calc(atk, def);
                        const shieldDmg = Math.floor(atk.getAtk() * 0.6 * aff.v);
                        def.shield = Math.max(0, def.shield - shieldDmg); // ì•ˆì „í•œ ì°¨ê° (HPë¡œ ì•ˆ ë„˜ì–´ê°)
                        UI.floatText(def, `-${shieldDmg}ğŸ›¡ï¸`, "ft-dmg");
                        game.log(`<span class='log-ally'>[ì¶”ê°€íƒ€]</span> ì‰´ë“œ íŒŒê´´ : -${shieldDmg}`);
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                def.addStatus('TRAP', 2, 0, atk);
                def.addStatus('HEAL_DOWN', 2, 0, atk);
            }
        }
    },
    'Water-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => e.addStatus('BURN', 2, 0, atk));
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    // [Balance] ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€ ë°ë¯¸ì§€
                    const extra = def.getAtk();
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act + extra, "(ê³µê²©ë ¥ë¹„ë¡€)");
                } else {
                    Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (atk.elecStacks < 3) {
                        atk.elecStacks++;
                        atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                const act = Common.applyDamage(atk, def, 2.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (atk.hasStatus('IMMUNITY')) {
                    atk.status = atk.status.filter(s => s.type !== 'IMMUNITY');
                    UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss");
                }
                const ex = atk.status.find(s => s.type === 'STUN');
                if (ex) ex.turn = 2;
                else atk.status.push({
                    type: 'STUN',
                    turn: 2,
                    val: 0
                });
                UI.floatText(atk, "ğŸ’¤íœ´ì‹", "ft-miss");
                game.log("(ë°˜ë™:íœ´ì‹)");
            }
        }
    },
    'Light-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 50;
                    a.cleanse();
                    game.recordStat(atk, 'shield', 50);
                    Common.logAction(game, 'shield', atk, a, 50, "(ì •í™”)");
                });
                return false;
            }
        }
    },
'Dark-Dark': {
    useSkill: function(atk, def, sIdx, game) {
        if (sIdx === 0) Common.basicAttack(atk, def, game);
        else if (sIdx === 1) {
            game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`); // âœ… ê´„í˜¸ () í•„ìš”
            const act = Common.applyDamage(atk, def, 0.8, game);
            if (act !== -1) {
                Common.logAction(game, 'dmg', atk, def, act, "");
                def.addStatus('SILENCE', 1, 0, atk);
            }
        } else {
            // ì„¸ë‡Œ ìŠ¤í‚¬ (ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥)
            game.log(`<b>[${atk.name}]</b> ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ ğŸ§ `);
    
            // [ì œì•½ 1] ì´ë¯¸ ëˆ„êµ°ê°€ë¥¼ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
            if (game.isMindControlling) {
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                return;
            }
            
            // [ì œì•½ 1] ì´ë¯¸ ëˆ„êµ°ê°€ë¥¼ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
            if (game.isMindControlling) {
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                return;
            }
            
            // [ì œì•½ 2] ë©´ì—­ ì²´í¬
            if (def.getKey() === 'Dark-Dark' || def.hasStatus('IMMUNITY') || (def.isNormal && !def.extra)) {
                game.log("<span class='log-sys'>ğŸš« ì •ì‹  ì§€ë°°ê°€ í†µí•˜ì§€ ì•ŠëŠ” ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                UI.floatText(def, "ë©´ì—­", "ft-miss");
                return;
            }

            // 1. ì½”ìŠ¤íŠ¸ ì§€ë¶ˆ
            const cost = Math.floor(atk.hp * 0.12);
            atk.hp = Math.max(1, atk.hp - cost);
            UI.floatText(atk, `HPì†Œëª¨(-${cost})`, "ft-miss");
            
            // 2. í™•ë¥  ê³„ì‚°
            const missingPct = 1.0 - (def.hp / def.maxHp);
            // [Balance] 30% ~ 55%ë¡œ ìƒí–¥
            const chance = 0.30 + (missingPct * 0.25);

            if (game.netRandom() < chance) {
                def.addStatus('MC_WAIT', 1, 0, atk, true); 
                game.log(` ğŸŒ€ <b>[${def.name}]</b> ì •ì‹  ì§€ë°° ì‹œì‘! (1í„´ í›„ ìŠ¤í‚µ, ê·¸ ë‹¤ìŒ ì¡°ì¢…)`);
                UI.floatText(def, "ì„¸ë‡Œ ëŒ€ê¸°", "ft-crit");
                AudioSys.play('DEBUFF');
            } else if (def.hasStatus('MC_WAIT') || def.hasStatus('MC_READY')) {
                // ì´ë¯¸ ê±¸ë ¤ìˆëŠ” ê²½ìš°
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì •ì‹  ì§€ë°°ê°€ ì§„í–‰ ì¤‘ì¸ ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                UI.floatText(def, "ì¤‘ë³µë¶ˆê°€", "ft-miss");
            } else {
                game.log(" (ì •ì‹  ì§€ë°° ì‹¤íŒ¨)");
                UI.floatText(def, "ì €í•­", "ft-miss");
            }
        }
    }
}
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id;
        this.team = team;
        this.base = base;
        this.extra = extra;
        this.maxHp = 600;
        if (base === 'Tree' && extra === 'Dark') this.maxHp = 700;
        if (base === 'Fire' && extra === 'Light') this.maxHp = 650;
        this.hp = this.maxHp;
        this.evadeTriggered = false;
        this.revengeAtk = 0;
        this.shield = (base === 'Metal' && !extra) ? 100 : 0;

        if (this.team === 1 && typeof Game !== 'undefined' && Game.difficulty === 'hell') {
            this.atk = 70;
        } else {
            this.atk = 55 + (id * 7 % 15);
        }

        this.status = [];
        this.isDead = false;
        this.thornStack = 0;
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.growthStack = 0;
        this.resist = 0;
        this.stats = {
            dmg: 0,
            heal: 0,
            shieldGiven: 0,
            taken: 0,
            kills: 0
        };
        this.isSuper = false;
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base === 'Light' && this.extra === 'Dark') || (this.base === 'Dark' && this.extra === 'Light');
        this.isEnhanced = (this.base === this.extra && (this.base === 'Light' || this.base === 'Dark'));

        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() {
        if (this.isNormal) return 'Normal';
        if (this.isEnhanced) return `${this.base}-${this.extra}`;
        return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base;
    }

    checkAwakening() {
        // [Balance] ì‰´ë“œ ìµœëŒ€ëŸ‰ 400ìœ¼ë¡œ ì œí•œ
        if (this.shield > 400) this.shield = 400;

        if (this.isSuper) return;
        const key = this.getKey();
        const role = SKILL_DB[key].role;
        let awakened = false;
        if (role === 'nuker') {
            if (this.stats.kills >= 2 || this.stats.dmg >= 1500) awakened = true;
        } else if (role === 'tank') {
            if (this.stats.taken >= 1000) awakened = true;
        } else if (role === 'supp') {
            if ((this.stats.heal + this.stats.shieldGiven) >= 1000) awakened = true;
        }
if (awakened) {
            this.isSuper = true;
            
            // [Modified] Emotion Awakening Logic
            const emo = EMOTION_DB[key];
            if (emo) {
                const isNew = TitleManager.unlock(key);
                const titleText = `[${emo.t}] Awakened!`;
                UI.floatText(this, titleText, "ft-crit");
                
                if (isNew) {
                    setTimeout(() => {
                        Game.log(`<span class="log-crit" style="color:#d500f9;">ğŸ† New Title Unlocked: [${emo.t}]</span>`);
                        // ì•Œë¦¼ ë©”ì‹œì§€ëŠ” í•œ ë²ˆë§Œ
                        const bubble = document.createElement('div');
                        bubble.style.cssText = "position:fixed; top:20%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.8); color:#fff; padding:15px 25px; border-radius:30px; z-index:9999; font-size:18px; box-shadow:0 5px 15px rgba(0,0,0,0.3); animation:floatUp 2s forwards;";
                        bubble.innerHTML = `ğŸ’ New Emotion: <b>${emo.t}</b><br><span style='font-size:12px; color:#aaa;'>${emo.d}</span>`;
                        document.body.appendChild(bubble);
                        setTimeout(() => bubble.remove(), 2500);
                    }, 500);
                }
            } else {
                UI.floatText(this, "âš¡AWAKENING!!âš¡", "ft-crit");
            }

            AudioSys.play('AWAKEN');
            Game.render();
        }
    }

    getAtk() {
        let v = this.atk;
        if (this.base === 'Fire' && !this.extra) {
            const turn = Game.turnCount;
            if (turn <= 12) v += 20;
            else if (turn <= 36) v += 10;
        }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        const lightMight = this.status.find(s => s.type === 'LIGHT_MIGHT');
        if (lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        if (this.hasStatus('ATK_BUFF_SMALL')) v += 10;
        v = Math.max(10, v);
        const ads = this.status.filter(s => s.type === 'ATK_DOWN');
        if (ads.length > 0) {
            ads.forEach(s => {
                if (s.val > 0) v -= Math.floor(v * (s.val / 100));
                else v -= 15;
            });
        }
        return Math.max(0, v);
    }

    resetTurn() {
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
    }

    takeDamage(dmg, isFire = false, ignoreShield = false, source = null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);

        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30);
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal");
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) {
            if (Game.netRandom() < 0.40) {
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                this.status = this.status.filter(s => s.type !== 'EVADE');
                return -1;
            }
        }
        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            if (karma && !isDarkVsDark) {
                const reflectDmg = Math.floor(dmg * 0.3);
                if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null);
                    this.stats.dmg += actualReflect;
                    UI.floatText(source, reflectDmg, "ft-crit");
                }
            }
        }

        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) {
            if (this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg;
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield;
                this.shield = 0;
            }
        } else {
            hpDmg = dmg;
        }
        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            hpDmg += 10;
            this.stats.taken += 10;
            UI.floatText(this, "Crack!", "ft-crit");
        }
        this.hp = Math.max(0, this.hp - hpDmg);

        if (this.hp <= 0 && source) {
            source.stats.kills = (source.stats.kills || 0) + 1;
            if (source.isSuper && !source.isDead) {
                const allies = source.team === 0 ? Game.pTeam : Game.eTeam;
                const aliveAllies = allies.filter(a => !a.isDead);
                if (aliveAllies.length === 1 && aliveAllies[0].id === source.id) {
                    UI.showCutIn(source);
                }
            }
            if (source.checkAwakening) source.checkAwakening();
        }

        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.evadeTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        this.checkAwakening();

        // [Fix] HPê°€ 0 ì´í•˜ë©´ ì¦‰ì‹œ ì‚¬ë§ ì²˜ë¦¬ (ë°˜ì‚¬ ë°ë¯¸ì§€ ì¢€ë¹„í™” ë°©ì§€)
        if (this.hp <= 0 && !this.isDead) {
            if (typeof Game !== 'undefined' && Game.die) {
                Game.die(this);
            }
        }

        return hpDmg + shieldDmg;
    }

    addStatus(type, turn, val = 0, source = null, force = false) {
        const CC_LIST = ['STUN', 'FREEZE', 'BANISH', 'SILENCE', 'SLEEP'];
        
        if (this.hasStatus('START_IMMUNITY') && !force) {
            if (CC_LIST.includes(type) || type.startsWith('PROVOKED')) { 
                UI.floatText(this, "ğŸ›¡ï¸CCë°©ì–´", "ft-miss");
                return;
            }
        }

        if (source && source.id !== this.id && !force) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            const isPuppet = (this.hasStatus('MC_READY') || (Game.isMindControlling && Game.isMindControlling.id === this.id));
            
            if (karma && !isDarkVsDark && !isPuppet) {
                if (Game.netRandom() < 0.5) {
                    UI.floatText(this, "ë°˜ì‚¬!", "ft-crit");
                    Game.log(`<span class='log-crit'>ğŸ‘ï¸ [${this.name}]ì˜ ì—…ë³´ ë°œë™! [${source.name}]ì—ê²Œ ${type} ë°˜ì‚¬</span>`);
                    source.addStatus(type, turn, val, null, true);
                    return;
                }
            }
        }
        // 1. ë…¸ë§ ë©´ì—­ ì²´í¬ (PROVOKED ì œì™¸)
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE'];
        if (this.isNormal && !force && NORMAL_IMMUNE.includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }

        const existing = this.status.find(s => s.type === type);
        if (existing && !force) {
            if (turn > existing.turn) {
                existing.turn = turn;
                existing.val = val;
                existing.sourceId = source?.id;
            }
            return;
        }
        
        const MUTUALLY_EXCLUSIVE = {
            'STUN': ['FREEZE', 'BANISH', 'SLEEP'],
            'FREEZE': ['STUN', 'BANISH', 'SLEEP'],
            'BANISH': ['STUN', 'FREEZE', 'SLEEP'],
            'SLEEP': ['STUN', 'FREEZE', 'BANISH']
        };
        
        if (MUTUALLY_EXCLUSIVE[type]) {
            const removed = [];
            MUTUALLY_EXCLUSIVE[type].forEach(conflictType => {
                const conflict = this.status.find(s => s.type === conflictType);
                if (conflict) {
                    removed.push(conflictType);
                    this.status = this.status.filter(s => s.type !== conflictType);
                }
            });
            if (removed.length > 0) {
                Game.log(`<span class='log-sys'>[${this.name}] ${removed.join(', ')} ìƒíƒœê°€ ${type}ìœ¼ë¡œ ëŒ€ì²´ë¨</span>`);
            }
        }
        
        // 2. íšŒí”¼ ì²´í¬ (ë…¸ë§ë„ ê°€ëŠ¥)
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return;
                }
            }
        }

        // 3. ë„ë°œì€ ë³„ë„ ì²´í¬
        if (this.isNormal && !force && type.startsWith('PROVOKED')) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY') && !force) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            if (!source || source.id !== this.id || force) {
                this.status.push({
                    type: 'IMMUNITY',
                    turn: turn + 1
                });
            }
        }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN'].includes(type)) return;
        
        if (type === 'ATK_DOWN') {
            const s = this.status.filter(s => s.type === 'ATK_DOWN');
            if (s.length < 2) {
                this.status.push({
                    type,
                    turn,
                    val,
                    sourceId: source ? source.id : -1
                });
            } else {
                const shortest = s.sort((a, b) => a.turn - b.turn)[0];
                shortest.turn = turn;
                if(source) shortest.sourceId = source.id;
            }
            return;
        }

        const idx = this.status.findIndex(s => s.type === type);
    if (idx >= 0) {
        this.status[idx].turn = turn;
        if (val !== 0) this.status[idx].val = val;
        if (source) this.status[idx].sourceId = source.id; // âœ… ê°±ì‹  ì‹œì—ë„ sourceId ì €ì¥
    } else {
        this.status.push({
            type,
            turn,
            val,
            sourceId: source ? source.id : -1 // âœ… ì‹ ê·œ ìƒì„± ì‹œ sourceId ì €ì¥
        });
    }
}
    hasStatus(type) {
        return this.status.some(s => s.type === type);
    }
    cleanse() {
        const bad = ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'KARMA_VICTIM', 'MC_WAIT', 'MC_READY'];
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM'));
    }
    dispel() {
        const buffs = ['EVADE', 'DMG_RED', 'ATK_BUFF', 'GROWTH', 'LIGHT_MIGHT'];
        const has = this.status.some(s => buffs.includes(s.type));
        this.status = this.status.filter(s => !buffs.includes(s.type));
        return has;
    }

    tickStatus() {
        let log = [];
        if (this.hasStatus('POISON')) {
            const d = this.takeDamage(35, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`);
        }
        if (this.hasStatus('BURN')) {
            const d = this.takeDamage(20, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`);
        }
        if (this.hasStatus('TRAP')) {
            const d = this.takeDamage(40, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`);
        }
        return log;
    }
    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    heal(amount) {
        if (this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4);
        const prev = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + amount);
        const diff = this.hp - prev;
        if (diff > 0) {
            UI.floatText(this, diff, 'ft-heal');
        }
        this.checkAwakening();
        return diff;
    }
}

const AudioSys = {
    ctx: null,
    masterVol: 0.5,
    bgmMuted: false,
    sfxMuted: false,

    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    // ğŸŸ¢ [ì¶”ê°€] ì´ ë¶€ë¶„ì´ ë¹ ì ¸ìˆì–´ì„œ ì‹¤í–‰ì´ ì•ˆ ëœ ê²ƒì…ë‹ˆë‹¤!
    resume: function() {
        this.init();
    },
    
    // [ì‹ ê·œ] ë³¼ë¥¨ ì¡°ì ˆ
    setMasterVolume: function(val) {
        this.masterVol = val / 100;
    },

    // [ì‹ ê·œ] ì±„ë„ í† ê¸€ (bgm/sfx)
    toggleChannel: function(type) {
        if (type === 'bgm') {
            this.bgmMuted = !this.bgmMuted;
            document.getElementById('tog-bgm').classList.toggle('on');
            // [Fix] MusicEngineìœ¼ë¡œ ë³€ê²½
            if(this.bgmMuted) MusicEngine.stop(); 
            else MusicEngine.play('Battle_Piano'); // ì¼œì§ˆ ë•Œ ê¸°ë³¸ ì¬ìƒ
        } else {
            this.sfxMuted = !this.sfxMuted;
            document.getElementById('tog-sfx').classList.toggle('on');
        }
    },

    // ì†Œë¦¬ ì¬ìƒ (ì œê³µí•´ì£¼ì‹  ë¡œì§ í†µí•©)
    playTone: function(freq, type, duration, vol, detune = 0, isBGM = false) {
        if (!this.ctx) return;
        if (isBGM && this.bgmMuted) return;
        if (!isBGM && this.sfxMuted) return;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        if (detune !== 0) osc.detune.value = detune;

        // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì ìš©
        const finalVol = vol * this.masterVol;

        // ë³¼ë¥¨ ì—”ë²¨ë¡œí”„ (ë¶€ë“œëŸ¬ìš´ ì‹œì‘ê³¼ ë)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.05); // Attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration); // Decay

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration + 0.1);
    },

    // íš¨ê³¼ìŒ ì „ìš© ë˜í¼ (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ìš©)
    play: function(type) {
        if (this.sfxMuted) return;
        this.init();
        // ê¸°ì¡´ íš¨ê³¼ìŒ ë¡œì§ ìœ ì§€ (playTone í˜¸ì¶œ ì‹œ íŒŒë¼ë¯¸í„° ì „ë‹¬)
        switch (type) {
            case 'HIT': this.playTone(150, 'square', 0.1, 0.2); break;
            case 'CRITICAL': 
                this.playTone(800, 'sawtooth', 0.2, 0.3); 
                setTimeout(()=>this.playTone(1200, 'square', 0.1, 0.2), 50);
                break;
            case 'SKILL': this.playTone(400, 'sine', 0.3, 0.2); break;
            case 'HEAL': 
                this.playTone(600, 'sine', 0.15, 0.2);
                setTimeout(()=>this.playTone(800, 'sine', 0.3, 0.2), 150);
                break;
            case 'DEBUFF': this.playTone(300, 'sawtooth', 0.3, 0.15); break;
            case 'POWER_UP':
                this.playTone(300, 'square', 0.1, 0.15);
                setTimeout(()=>this.playTone(450, 'square', 0.1, 0.15), 100);
                break;
            case 'WIN': 
                [0,200,400,600].forEach((d,i)=> setTimeout(()=>this.playTone(523+(i*100),'triangle',0.3,0.3), d));
                break;
            case 'CUTIN': this.playTone(100, 'sawtooth', 0.8, 0.4); break;
            case 'AWAKEN': this.playTone(200, 'square', 0.5, 0.3); break;
        }
    },
    speak: function(unit) {
        if(this.sfxMuted) return;
        this.init();
        const base = 400 + (unit.id*50);
        for(let i=0; i<2; i++) {
            setTimeout(()=> this.playTone(base+(Math.random()*100-50), 'triangle', 0.08, 0.15), i*80);
        }
    }
};
// ==========================================
// ğŸ¹ Music Engine (Hybrid: Canon + New Tracks)
// ==========================================
const MusicEngine = {
    ctx: null, isPlaying: false, currentTrack: null, tempo: 100, timeoutId: null, bgmOscillators: [],
    
    // [ìºë…¼ ì›ë³¸ ë°ì´í„°] ì‚¬ìš©ì ìš”ì²­ ì›ë³¸ ìœ ì§€
    canon: {
        melody: [587, 554, 494, 440, 392, 370, 392, 440, 587, 0, 494, 0, 494, 554, 587, 659, 740, 587, 659, 587, 554, 494, 554, 440, 392, 440, 494, 554, 370, 440, 494, 554],
        bass:   [293, 0, 220, 0, 246, 0, 185, 0, 196, 0, 293, 0, 196, 0, 220, 0, 293, 220, 246, 293, 185, 246, 196, 220, 196, 220, 293, 220, 293, 370, 440, 554],
        step: 0,
        style: 1 // 1:Piano, 2:Harp, 3:Mix
    },

    init: () => {
        if (!MusicEngine.ctx) { MusicEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (MusicEngine.ctx.state === 'suspended') MusicEngine.ctx.resume();
    },

    // [ì†Œë¦¬ ë°œìƒê¸°] (ìºë…¼ ì›ë³¸ ë¡œì§ í˜¸í™˜ìš©)
    playTone: (freq, type, duration, vol, detune=0) => {
        const t = MusicEngine.ctx.currentTime;
        const osc = MusicEngine.ctx.createOscillator();
        const gain = MusicEngine.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        if(detune) osc.detune.value = detune;
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol * 0.5, t + 0.02); // ë³¼ë¥¨ ì¡°ì ˆ
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain); gain.connect(MusicEngine.ctx.destination);
        osc.start(t); osc.stop(t + duration + 0.1);
        MusicEngine.bgmOscillators.push(osc);
    },

    // [ìŒê³„ ë³€í™˜ê¸°] (ì‹ ê·œ ê³¡ìš©)
    getFreq: (note) => {
        if (!note) return 0;
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = parseInt(note.slice(-1));
        const idx = notes.indexOf(note.slice(0, -1));
        return idx === -1 ? 0 : 440 * Math.pow(2, (idx - 9 + (octave - 4) * 12) / 12);
    },

    // [ì¬ìƒ ë©”ì¸ í•¨ìˆ˜]
    play: (trackName) => {
        MusicEngine.init(); MusicEngine.stop();
        MusicEngine.isPlaying = true;

        // A. ìºë…¼ ëª¨ë“œ (ê¸°ì¡´ ë¡œì§)
        if (trackName.startsWith('Canon')) {
            if (trackName === 'Canon_Piano') MusicEngine.canon.style = 1;
            else if (trackName === 'Canon_Harp') MusicEngine.canon.style = 2;
            else if (trackName === 'Canon_Mix') MusicEngine.canon.style = 3;
            
            MusicEngine.canon.step = 0;
            MusicEngine.loopCanon();
        } 
        // B. ì‹ ê·œ íŠ¸ë™ ëª¨ë“œ
        else {
            MusicEngine.currentTrack = MusicEngine.Tracks[trackName];
            if (!MusicEngine.currentTrack) return;
            MusicEngine.tempo = MusicEngine.currentTrack.bpm;
            
            let noteIndex = 0;
            const playNext = () => {
                if (!MusicEngine.isPlaying) return;
                const noteData = MusicEngine.currentTrack.notes[noteIndex];
                // ë…¸íŠ¸ ì¬ìƒ
                if (noteData[0]) {
                    const notes = Array.isArray(noteData[0]) ? noteData[0] : [noteData[0]];
                    notes.forEach(n => {
                        // ì‹ ê·œ ê³¡ì€ ë¶€ë“œëŸ¬ìš´ Triangle íŒŒí˜• ì‚¬ìš©
                        const f = MusicEngine.getFreq(n);
                        MusicEngine.playTone(f, 'triangle', noteData[1] * (60/MusicEngine.tempo), 0.3);
                    });
                }
                const timeToNext = noteData[1] * (60000 / MusicEngine.tempo);
                noteIndex = (noteIndex + 1) % MusicEngine.currentTrack.notes.length;
                MusicEngine.timeoutId = setTimeout(playNext, timeToNext);
            };
            playNext();
        }
    },

    // [ìºë…¼ ë£¨í”„] (ì‚¬ìš©ì ì›ë³¸ ë¡œì§ ë³µì›)
    loopCanon: function() {
        if (!this.isPlaying) return;
        
        // í…œí¬ ë¡œì§ (ìœ„ê¸° ì‹œ ë¹¨ë¼ì§)
        // const isDanger = Game.pTeam && Game.pTeam.some(u => !u.isDead && u.hp < u.maxHp * 0.3);
        const tempo = 400; // ê¸°ë³¸ 400ms

        const idx = this.canon.step;
        const mNote = this.canon.melody[idx];
        const bNote = this.canon.bass[idx];
        const style = this.canon.style;

        // === ì›ë³¸ ìŠ¤íƒ€ì¼ ë¡œì§ ===
        if (style === 1) { // Soft Piano
            if(mNote) {
                this.playTone(mNote, 'sine', 0.6, 0.3);
                this.playTone(mNote, 'triangle', 0.6, 0.2);
            }
            if(bNote) this.playTone(bNote, 'sine', 0.8, 0.4);
        } 
        else if (style === 2) { // Harp
            if(mNote) this.playTone(mNote, 'triangle', 0.3, 0.3);
            if(bNote) {
                this.playTone(bNote, 'triangle', 0.4, 0.3);
                setTimeout(() => this.playTone(bNote * 1.5, 'sine', 0.2, 0.1), 50);
            }
        } 
        else if (style === 3) { // Mix
            if(mNote) {
                this.playTone(mNote, 'sine', 0.5, 0.3);
                this.playTone(mNote * 2, 'triangle', 0.2, 0.1);
            }
            if(bNote) {
                this.playTone(bNote, 'square', 0.1, 0.05);
                this.playTone(bNote, 'sine', 0.8, 0.3);
            }
        }

        this.canon.step = (this.canon.step + 1) % this.canon.melody.length;
        this.timeoutId = setTimeout(() => this.loopCanon(), tempo);
    },

    stop: () => {
        MusicEngine.isPlaying = false;
        clearTimeout(MusicEngine.timeoutId);
        MusicEngine.bgmOscillators.forEach(o => { try{o.stop();}catch(e){} });
        MusicEngine.bgmOscillators = [];
    },

    // ì‹ ê·œ ê³¡ ì•…ë³´
    Tracks: {
        'Battle_Piano': { bpm: 90, notes: [['A3',0.5],['E4',0.5],['A4',0.5],['E4',0.5],['F3',0.5],['C4',0.5],['F4',0.5],['C4',0.5],['G3',0.5],['D4',0.5],['G4',0.5],['D4',0.5],['E3',0.5],['B3',0.5],['E4',1.0],[['A3','C4'],1.0],['B3',0.5],['A3',0.5],[['F3','A3'],1.5],['G3',0.5],[['C4','E4'],1.0],['D4',0.5],['C4',0.5],[['G3','B3'],2.0],[['F3','A3'],1.0],['G3',0.5],['A3',0.5],[['D3','F3'],1.5],['E3',0.5],[['E3','G#3'],2.0],[null,0.5],['E4',0.5],['D4',0.5],['C4',0.5],[['A3','C4','E4'],2.0],[['F3','A3','C4'],2.0],[['G3','B3','D4'],2.0],[['E3','G#3','B3'],2.0],['A3',0.5],['B3',0.5],['C4',1.0],[null,1.0]] },
        'Thinking': { bpm: 100, notes: [['D4',0.5],['A3',0.5],['D4',0.5],['E4',0.5],['F4',1.5],['E4',0.5],['D4',0.5],['A3',0.5],['F4',0.5],['E4',0.5],['D4',1.5],[null,0.5],[['D3','D4'],0.5],['A3',0.5],['D4',0.5],['E4',0.5],[['F3','F4'],1.5],['E4',0.5],[['G3','D4'],0.5],['A3',0.5],['F4',0.5],['E4',0.5],[['A2','D4'],1.5],[null,0.5],[['Bb3','D5'],1.0],['C5',0.5],['A4',0.5],[['C4','G4'],1.5],['F4',0.5],[['D3','D4'],1.0],['F4',0.5],['E4',0.5],[['A2','D4'],2.0],['D4',0.25],['F4',0.25],['A4',0.25],['D5',0.25],['C5',1.0],[null,1.0]] },
        'Aftermath': { bpm: 80, notes: [[['C4','E4'],2.0],[['D4','F4'],2.0],[['E4','G4'],3.0],[null,1.0],['G4',0.5],['A4',0.5],[['C4','G4'],2.0],['F4',0.5],['E4',0.5],[['A3','D4'],2.0],['C4',1.0],[['F3','A3','C4'],2.0],[['G3','B3','D4'],2.0],[['E3','G3','C4'],3.0],[null,1.0],['C5',0.5],['B4',0.5],['A4',0.5],['G4',0.5],[['F4','A4'],1.5],['E4',0.5],[['D4','G4'],1.5],['C4',0.5],[['C4','E4','C5'],4.0]] }
    }
};

 

const UI = {
    toggleSettings: function() {
        const el = document.getElementById('audio-settings');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
	// [UI] BGM ì„ íƒ ë° í•˜ì´ë¼ì´íŠ¸ ì²˜ë¦¬
    selectBGM: function(trackName, el) {
        // 1. ëª¨ë“  ì˜µì…˜ì—ì„œ active ì œê±°
        document.querySelectorAll('.bgm-opt').forEach(opt => opt.classList.remove('active'));
        
        // 2. í´ë¦­í•œ ì˜µì…˜ì— active ì¶”ê°€
        if(el) el.classList.add('active');
        
        // 3. ìŒì•… ì¬ìƒ
        MusicEngine.play(trackName);
        
        // 4. í† ê¸€ ë²„íŠ¼ì´ êº¼ì ¸ìˆë‹¤ë©´ ì¼œê¸°
        const tog = document.getElementById('tog-bgm');
        if (tog && !tog.classList.contains('on')) {
            AudioSys.toggleChannel('bgm');
        }
    },

    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() {
        document.getElementById('modal-overlay').style.display = 'none';
    },

    // [UI ê°œì„ ] ì˜¨ë¼ì¸ ì½”ë“œ ì…ë ¥ ëª¨ë‹¬
    openOnlineModal: function() {
        if (!socket || !socket.connected) {
            alert("âš ï¸ ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n(ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” AIì™€ ëŒ€ê²°í•˜ì„¸ìš”)");
            return;
        }
        if (Game.selected.length !== 3) {
            alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        const content = `
            <div style="text-align:center;">
                <p style="color:#555; margin-bottom:15px;">ì¹œêµ¬ì™€ ê³µìœ í•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple)</p>
                <input type="text" id="modal-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥" 
                    style="font-size:20px; padding:15px; width:80%; text-align:center; border-radius:15px; border:2px solid #ddd; outline:none; font-weight:bold; color:#7e57c2;">
                <button id="modal-submit-btn" onclick="Game.submitOnline()" 
                    style="width:100%; margin-top:20px; padding:15px; background:#7e57c2; color:white; border:none; border-radius:15px; font-weight:bold; cursor:pointer; font-size:18px;">
                    ì…ì¥í•˜ê¸° ğŸš€
                </button>
            </div>
        `;
        this.showModal("ğŸŒ ì˜¨ë¼ì¸ ë§¤ì¹­", content);
        setTimeout(() => document.getElementById('modal-room-code').focus(), 100);
    },

    showGuide: function() {
        let heroList = '';
        const guideOrder = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark'];
        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if (k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if (parts.length === 2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';
            // [íŒ¨ì‹œë¸Œ í‘œì‹œ ì¶”ê°€]
            heroList += `<div class="guide-item"> 
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> 
                <div class="guide-info"> 
                    <div class="guide-name">${name}</div> 
                    <div class="guide-desc">${s.desc}</div> 
                    <div style="font-size:10px; color:#555; margin-top:2px;"> 
                        <div>S1: ${s.s1} (${s.s1d})</div> 
                        <div>S2: ${s.s2} (${s.s2d})</div> 
                        ${s.passive ? `<div style="color:#00695c; font-weight:bold; margin-top:2px; border-top:1px dashed #ddd; padding-top:2px;">PASSIVE: ${s.passive}</div>` : ''}
                    </div> 
                </div> 
            </div>`;
        });
        const content = `<div class="tab-header"> <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button> <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button> </div> <div id="tab-0" class="tab-content active"> <table class="chart-table"> <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr> <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr> <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr> <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr> <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr> <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr> <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr> <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr> </table> <div class="dual-chart"> <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div> <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div> </div> </div> <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;"> ${heroList} </div>`;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if (i === idx) b.classList.add('active');
            else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if (i === idx) c.classList.add('active');
            else c.classList.remove('active');
        });
    },

    // [ë°ë¯¸ì§€ í°íŠ¸] ì„¸ë¶„í™” ì ìš©
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id);
        if (!unitEl) return;
        const el = document.createElement('div');
        el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        const randomX = (Math.random() - 0.5) * 40;
        const randomY = (Math.random() - 0.5) * 20;
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px';
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    },

    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)";
        }
        banner.style.animation = 'none';
        void banner.offsetWidth;
        const duration = Game.turnCount > 5 ? '0.6s' : '1.2s';
        banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`;
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);
        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        const mvp = allUnits.sort((a, b) => (b.stats.dmg + b.stats.heal + b.stats.shieldGiven) - (a.stats.dmg + a.stats.heal + a.stats.shieldGiven))[0];
        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`;
        };
        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },

    // [íˆ´íŒ] ì •ë³´ í‘œì‹œ
    showTooltip: function(u, el) {
        const info = SKILL_DB[u.getKey()];
        const statusText = u.status.map(s => {
            let info = `â€¢ ${s.type} (${s.turn}í„´)`;
            // [UI] í™•ë¥  ë° ìƒì„¸ ì •ë³´ í‘œì‹œ
            if (s.type.startsWith('KARMA_VICTIM')) info += ' <span style="color:#ffcc80; font-size:10px;">(ë°˜ì‚¬ 50%)</span>';
            if (s.type === 'MC_WAIT') info += ' <span style="color:#ff80ab; font-size:10px;">(ì„¸ë‡Œ ëŒ€ê¸°)</span>';
            return info;
        }).join('<br>') || 'ì—†ìŒ';
        const html = `
            <div class="tooltip-title">${u.name} (HP: ${u.hp})</div>
            <div style="margin-bottom:5px;">${info.desc}</div>
            <div style="color:#aaa; border-top:1px solid #555; padding-top:3px; margin-top:3px;">
                <b>ìƒíƒœì´ìƒ:</b><br>${statusText}
            </div>
        `;
        const tooltip = document.getElementById('tooltip-view');
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';

        const rect = el.getBoundingClientRect();
        let top = rect.top - 100;
        let left = rect.left + rect.width / 2 - 100;
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
    },
    hideTooltip: function() {
        document.getElementById('tooltip-view').style.display = 'none';
    },

    // [ì»·ì‹ ] ì—°ì¶œ
    showCutIn: function(unit) {
        const ov = document.getElementById('cut-in-overlay');
        const em = document.getElementById('cut-in-emoji');
        const msg = document.getElementById('cut-in-msg');

        const key = unit.getKey();
        em.innerText = SKILL_DB[key].icon || ATTR[unit.base].i;
        msg.innerText = "HEROIC FINISH!";

        ov.style.display = 'flex';
        AudioSys.play('CUTIN');

        // 1.2ì´ˆ í›„ ì¢…ë£Œ
        setTimeout(() => {
            ov.style.display = 'none';
        }, 1200);
    }, 

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ë©”ë‰´ ì—´ê¸°
    showEmoteMenu: function(u, el) {
        const existing = document.querySelector('.emote-menu');
        if (existing) existing.remove();

        const menu = document.createElement('div');
        menu.className = 'emote-menu';
        const emojis = ['ğŸ‘', 'ğŸ˜¡', 'ğŸ˜±', 'ğŸ˜œ', 'ğŸ³ï¸'];
        emojis.forEach(e => {
            const btn = document.createElement('span');
            btn.className = 'emote-btn';
            btn.innerText = e;
            btn.onclick = (ev) => {
                ev.stopPropagation();
                UI.triggerEmote(u, e);
                menu.remove();
            };
            menu.appendChild(btn);
        });
        
        const rect = el.getBoundingClientRect();
        // ìœ ë‹› ë¨¸ë¦¬ ìœ„ì— í‘œì‹œ
        menu.style.top = (rect.top - 60 + window.scrollY) + 'px';
        menu.style.left = (rect.left + rect.width/2 - 100 + window.scrollX) + 'px';
        
        document.body.appendChild(menu);
        
        // ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
        setTimeout(() => {
            document.addEventListener('click', function close() {
                if(menu.parentNode) menu.remove();
                document.removeEventListener('click', close);
            }, {once:true});
        }, 0);
    },

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ì‹¤í–‰
    triggerEmote: function(u, emoji) {
        // ìœ ë‹› ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (!el) return;
        
        const rect = el.getBoundingClientRect();
        
        // ë§í’ì„  ìƒì„± (bodyì— ì§ì ‘ ì¶”ê°€í•˜ì—¬ ìµœìƒìœ„ ë ˆì´ì–´ ë³´ì¥)
        const bubble = document.createElement('div');
        bubble.className = 'emote-bubble';
        bubble.innerText = emoji;
        
        // ìœ„ì¹˜ ì ˆëŒ€ê°’ ê³„ì‚° (ìŠ¤í¬ë¡¤ í¬í•¨)
        bubble.style.left = (rect.left + rect.width / 2) + 'px'; 
        bubble.style.top = (rect.top - 50 + window.scrollY) + 'px';
        // z-indexë¥¼ ì•„ì£¼ ë†’ê²Œ ì„¤ì •
        bubble.style.zIndex = "9999"; 
        
        document.body.appendChild(bubble);
        
        setTimeout(() => bubble.remove(), 2000);
    }, 

// [New] Emotion Codex UI
    showCollection: function() {
        const list = Object.keys(EMOTION_DB);
        let html = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">`;
        let unlockedCount = 0;

        list.forEach(key => {
            const isUnlocked = TitleManager.unlocked.includes(key);
            if (isUnlocked) unlockedCount++;
            
            const data = EMOTION_DB[key];
            const base = key.split('-')[0] === 'Normal' ? 'Normal' : key.split('-')[0];
            let bgClass = `bg-${base}`;
            if (key.includes('-') && key.split('-')[0] === key.split('-')[1]) bgClass += '-Enhanced';
            if (key === 'Normal') bgClass = 'bg-Normal';

            // Style: Unlocked vs Locked
            const style = isUnlocked 
                ? `border:2px solid #ff80ab; background:#fff; color:#333;` 
                : `background:#eee; color:#aaa; border:2px dashed #ccc; opacity:0.7;`;
            
            const icon = isUnlocked ? (SKILL_DB[key].icon || ATTR[base].i) : 'ğŸ”’';
            const title = isUnlocked ? data.t : '???';
            const desc = isUnlocked ? data.d : 'Unlock by Awakening';

            html += `
                <div style="padding:10px; border-radius:15px; display:flex; flex-direction:column; align-items:center; text-align:center; ${style}">
                    <div class="attr-icon ${isUnlocked ? bgClass : ''}" style="width:36px; height:36px; font-size:20px; margin-bottom:5px; ${!isUnlocked?'background:#ccc;':''}">${icon}</div>
                    <div style="font-weight:bold; font-size:14px; margin-bottom:3px;">${title}</div>
                    <div style="font-size:10px; line-height:1.2;">${desc}</div>
                </div>
            `;
        });
        html += `</div>`;
        
        const pct = Math.floor((unlockedCount / list.length) * 100);
        const header = `
            <div style="text-align:center; margin-bottom:15px; padding-bottom:10px; border-bottom:2px dashed #ffcdd2;">
                <h3 style="margin:0 0 5px 0; color:#ff80ab;">ğŸ’ Emotion Codex</h3>
                <div style="font-size:14px; color:#888;">
                    Collection: <b style="color:${pct===100?'#ffca28':'#5d4037'}">${unlockedCount} / ${list.length}</b> (${pct}%)
                </div>
            </div>
        `;

        this.showModal("Codex", header + html);
    },
    // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ ì• ë‹ˆë©”ì´ì…˜
    fireProjectile: function(atk, def, icon) {
        return new Promise(resolve => {
            // ìœ„ì¹˜ ê³„ì‚°
            const startId = atk.team === 0 ? `p-card-${atk.id}` : `e-card-${atk.id}`;
            const endId = def.team === 0 ? `p-card-${def.id}` : `e-card-${def.id}`;
            const sEl = document.getElementById(startId);
            const eEl = document.getElementById(endId);
            
            if (!sEl || !eEl) { resolve(); return; }

            const sRect = sEl.getBoundingClientRect();
            const eRect = eEl.getBoundingClientRect();

            // íˆ¬ì‚¬ì²´ ìƒì„±
            const p = document.createElement('div');
            p.className = 'projectile';
            p.innerText = icon;
            p.style.left = (sRect.left + sRect.width/2) + 'px';
            p.style.top = (sRect.top + sRect.height/2) + 'px';
            document.body.appendChild(p);

            // ë°œì‚¬ (ê°•ì œ ë¦¬í”Œë¡œìš° í›„ ì´ë™)
            requestAnimationFrame(() => {
                p.style.left = (eRect.left + eRect.width/2) + 'px';
                p.style.top = (eRect.top + eRect.height/2) + 'px';
            });

            // ë„ì°© í›„ ì²˜ë¦¬
            setTimeout(() => {
                p.remove();
                // íƒ€ê²© ì´í™íŠ¸
                const boom = document.createElement('div');
                boom.className = 'impact-effect';
                boom.innerText = 'ğŸ’¥';
                boom.style.left = (eRect.left + eRect.width/2) + 'px';
                boom.style.top = (eRect.top + eRect.height/2) + 'px';
                document.body.appendChild(boom);
                setTimeout(() => boom.remove(), 300);
                resolve();
            }, 400); // 0.4ì´ˆ ë¹„í–‰
        });
    },

    // [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (íƒ€ê²©ê° ê·¹ëŒ€í™”)
    hitStop: function(duration = 150) {
        document.body.classList.add('hit-stopped');
        setTimeout(() => {
            document.body.classList.remove('hit-stopped');
        }, duration);
    }
};

const Game = {
    // [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
    DEBUG_MODE: true, // ê°œë°œ ì¤‘ì—” true, ë°°í¬ ì‹œ falseë¡œ ë³€ê²½

    debugLog: function(msg, data) {
        if (this.DEBUG_MODE) {
            // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê°ì²´ë¡œ, ì—†ìœ¼ë©´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
            if (data) console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;', data);
            else console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;');
        }
    },
    pool: [],
    selected: [],
    pTeam: [],
    eTeam: [],
    queue: [],
    curr: 0,
    selectedSkillIdx: -1,
    timer: null,
    turnCount: 1,
    difficulty: 'normal',
    watchdog: null,
    isOver: false,
    mode: 'pve',
    isProcessing: false,
    challengeStage: 0,
    isMindControlling: null, // [ì‹ ê·œ] ì„¸ë‡Œ ì¡°ì¢… ìƒíƒœ í”Œë˜ê·¸
    currentMCCasterId: null,
    cleanup: function() {
        console.log("ğŸ§¹ Game cleanup started");
        
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.watchdog) {
            clearTimeout(this.watchdog);
            this.watchdog = null;
        }
        
        this.isOver = true;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        MusicEngine.stop();
        
        console.log("âœ… Game cleanup completed");
    },
	
    netRandom: function() {
        return getNetRandom();
    },

    init: function() {
        // íƒ€ì´ë¨¸ ì •ë¦¬
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // ìƒíƒœ ì´ˆê¸°í™”
        this.isOver = false;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        // BGM ì •ì§€
        MusicEngine.stop();
        
        // ë°ì´í„° ì´ˆê¸°í™”
        this.pool = [];
        this.selected = [];
        const allCombos = [{
            b: 'Metal',
            e: null
        }, {
            b: 'Tree',
            e: null
        }, {
            b: 'Fire',
            e: 'Light'
        }, {
            b: 'Water',
            e: 'Light'
        }, {
            b: 'Fire',
            e: null
        }, {
            b: 'Normal',
            e: null
        }, {
            b: 'Fire',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: null
        }, {
            b: 'Water',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Light'
        }, {
            b: 'Earth',
            e: 'Light'
        }, {
            b: 'Tree',
            e: 'Dark'
        }, {
            b: 'Water',
            e: null
        }, {
            b: 'Tree',
            e: 'Light'
        }, {
            b: 'Light',
            e: null
        }, {
            b: 'Light',
            e: 'Light'
        }, {
            b: 'Dark',
            e: null
        }, {
            b: 'Dark',
            e: 'Dark'
        }];
        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // [UI ê°œì„ ] ì˜¨ë¼ì¸ ë²„íŠ¼ì€ í•­ìƒ í™œì„±í™”, í´ë¦­ ì‹œ ëª¨ë‹¬ ì²˜ë¦¬
        const btnOnline = document.getElementById('btn-online');
        if (btnOnline) {
            btnOnline.style.backgroundColor = '#7e57c2';
        }

        this.checkMode();
    },

    // [UI ê°œì„ ] ëª¨ë‹¬ì—ì„œ ì½”ë“œ ì…ë ¥ í›„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    submitOnline: function() {
        const codeInput = document.getElementById('modal-room-code');
        const code = codeInput.value.trim();
        if (!code) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            codeInput.focus();
            return;
        }

        const btn = document.getElementById('modal-submit-btn');
        if (btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
        btn.disabled = true;
        btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";

        startOnlineGame(code);
    },

    renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block';
        grid.style.overflowY = 'auto';
        const categories = [{
            name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)",
            range: [0, 3],
            color: "#e3f2fd",
            border: "#90caf9"
        }, {
            name: "âš”ï¸ ë”œëŸ¬ (Dealer)",
            range: [4, 13],
            color: "#ffebee",
            border: "#ef9a9a"
        }, {
            name: "ğŸ§© ì§€ì› (Support)",
            range: [14, 19],
            color: "#f1f8e9",
            border: "#a5d6a7"
        }];
        categories.forEach(cat => {
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:10px; border-radius:5px; color:#455a64; text-align:left; box-sizing:border-box;`;
            header.innerText = cat.name;
            grid.appendChild(header);
            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; padding:10px 0;";
            for (let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const el = document.createElement('div');
                el.className = 'hero-card';
                el.id = `card-${i}`;
                el.innerHTML = this.renderCard(u);
                el.onclick = () => {
                    this.toggle(i, el);
                };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },
    renderCard: function(u) {
    if (!u) return '';

    let bgClass = 'bg-' + u.base;
    if (u.isEnhanced) {
        bgClass = 'bg-' + u.base + '-Enhanced';
    } else if (u.isNormal) {
        bgClass = 'bg-Normal';
    }

    const key = u.getKey();
    const info = SKILL_DB[key];
    
    if (!info) {
        console.error('SKILL_DB missing for key:', key);
        return '<div class="attr-icon bg-Normal">?</div><div style="font-weight:bold;">ERROR</div>';
    }

    const mainIcon = info.icon || (ATTR[u.base] ? ATTR[u.base].i : '?');
    const baseIcon = ATTR[u.base] ? ATTR[u.base].i : '?';
    const extraIcon = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : '';
    const displayName = u.name ? u.name.split(' ')[0] : 'Unknown';
    const fullName = u.name || 'Unknown';
    const description = info.desc || 'ì •ë³´ ì—†ìŒ';

    let html = '<div class="attr-icon ' + bgClass + '">';
    html += mainIcon;
    html += '<div class="mini-attr-box">';
    html += '<div class="mini-icon">' + baseIcon + '</div>';
    if (extraIcon) {
        html += '<div class="mini-icon">' + extraIcon + '</div>';
    }
    html += '</div></div>';
    html += '<div style="font-weight:bold; margin-bottom:2px; font-size:15px;">' + displayName + '</div>';
    html += '<div style="font-size:11px; color:#999;">' + fullName + '</div>';
    html += '<div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">';
    html += description + '</div>';
    
    return html;
},
    toggle: function(i, el) {
        if (!el) el = document.getElementById(`card-${i}`);
        if (this.selected.includes(i)) {
            this.selected = this.selected.filter(x => x !== i);
            el.classList.remove('selected');
        } else {
            if (this.selected.length >= 3) {
                el.classList.add('shake');
                setTimeout(() => el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },
    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if (el) el.classList.remove('selected');
        });
        Game.selected = [];
        while (Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if (!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if (el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            if (this.challengeStage > maxStage) this.challengeStage = maxStage;
            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }
    },
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },

    start: function() {
        AudioSys.init();
        AudioSys.resume();
        // [ìˆ˜ì •] ê¸°ë³¸ BGMì„ ìºë…¼(ì†Œí”„íŠ¸ í”¼ì•„ë…¸)ìœ¼ë¡œ ì„¤ì •
        MusicEngine.play('Canon_Piano'); 
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => {
            const u = this.pool[idx];
            u.id = i;
            u.team = 0;
            return u;
        });
        this.eTeam = [];
        this.isOver = false;
        const makeEnemy = (idx, b, e) => {
            const u = new Unit(idx + 3, 1, b, e);
            return u;
        };

        if (this.difficulty === 'hell') {
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            const stageData = ChallengeDB[this.challengeStage];

            // [AI ê°•í™”] ë± ìˆœì„œ ì„ê¸° (fixedOrderê°€ trueë©´ ì„ì§€ ì•ŠìŒ)
            // ì´ë¥¼ í†µí•´ 'ëŒ€ì§€ì˜ ë¶„ë…¸' ê°™ì€ ì½¤ë³´ ë±ì˜ ìˆœì„œë¥¼ ë³´ì¥í•¨
            let currentTeamList = [...stageData.team];
            if (!stageData.fixedOrder) {
                // ëœë¤ì„±ì„ ìœ„í•´ ì„ë˜, ì›ë³¸ ë°°ì—´ì„ ê±´ë“œë¦¬ì§€ ì•Šë„ë¡ ë³µì‚¬ë³¸ ì‚¬ìš©
                currentTeamList.sort(() => Math.random() - 0.5);
            }

            this.eTeam = currentTeamList.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
        } else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => {
                const u = new Unit(i + 3, 1, pu.base, pu.extra);
                u.maxHp = Math.floor(u.maxHp * 1.15);
                u.hp = u.maxHp;
                u.atk = Math.floor(u.atk * 1.15);
                return u;
            });
        } else if (this.difficulty === 'easy') {
            const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
            while (this.eTeam.length < 3) {
                const b = basics[Math.floor(Math.random() * basics.length)];
                if (!this.eTeam.some(u => u.base === b)) {
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, null));
                }
            }
        } else if (this.difficulty === 'hard') {
            let bestIdx = Math.floor(Math.random() * ChallengeDB.length);
            let maxScore = -999;
            ChallengeDB.forEach((stage, idx) => {
                let score = 0;
                stage.team.forEach(key => {
                    let b, e, isN = false,
                        isEnh = false;
                    if (key === 'Normal') {
                        b = 'Normal';
                        isN = true;
                    } else {
                        const parts = key.split('-');
                        b = parts[0];
                        e = parts[1] || null;
                        if (b === e) isEnh = true;
                    }
                    const dumE = {
                        base: b,
                        extra: e,
                        isNormal: isN,
                        isEnhanced: isEnh
                    };
                    this.pTeam.forEach(p => {
                        const atkRel = this.calc(dumE, p);
                        if (atkRel.v > 1.0) score += 3;
                        const defRel = this.calc(p, dumE);
                        if (defRel.v < 1.0) score += 2;
                    });
                });
                score += Math.random();
                if (score > maxScore) {
                    maxScore = score;
                    bestIdx = idx;
                }
            });
            const targetDeck = ChallengeDB[bestIdx].team;
            this.eTeam = targetDeck.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
            this.log(`<span class='log-sys'>ğŸ”¥ ì–´ë ¤ì›€(Counter): ì ì´ ë‹¹ì‹ ì˜ ì•½ì ì„ ê°„íŒŒí–ˆìŠµë‹ˆë‹¤! (${ChallengeDB[bestIdx].name})</span>`);
        } else {
            const used = new Set();
            while (this.eTeam.length < 3) {
                const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                if (b === 'Dark' && e === 'Light') continue;
                let key = `${b}-${e}`;
                if (b === 'Light' && e === 'Dark') key = 'Normal';
                if (!used.has(key)) {
                    used.add(key);
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, e));
                }
            }
        }

        this.queue = [0, 1, 2, 3, 4, 5];
        this.curr = Math.floor(Math.random() * 6);
        this.turnCount = 1;
        this.isProcessing = false;
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('battle-screen').style.display = 'flex';
        document.getElementById('logs').innerHTML = '';
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);

        // [ì„ /í›„ê³µ ë³´ì •] í›„ê³µ íŒ€ì—ê²Œ ë©´ì—­ ë¶€ì—¬
        // queue[curr]ì´ ì„ ê³µì˜ ì²« í„´ ì¸ë±ìŠ¤.
        // ë§Œì•½ queue[curr]ì´ 0,2,4 ì¤‘ í•˜ë‚˜ë©´ PíŒ€ì´ ì„ ê³µ -> EíŒ€(1)ì—ê²Œ ë©´ì—­
        // ë§Œì•½ queue[curr]ì´ 1,3,5 ì¤‘ í•˜ë‚˜ë©´ EíŒ€ì´ ì„ ê³µ -> PíŒ€(0)ì—ê²Œ ë©´ì—­
        const firstTurnUnitId = (this.queue[this.curr] % 2 === 0 ? this.queue[this.curr] / 2 : (this.queue[this.curr] - 1) / 2 + 3);
        const firstTurnTeam = this.queue[this.curr] % 2; // 0 (PíŒ€) or 1 (EíŒ€)
        const secondTeam = firstTurnTeam === 0 ? this.eTeam : this.pTeam;

        secondTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        this.log(`<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ íŒ€(${firstTurnTeam===0?'ì êµ°':'ì•„êµ°'})ì—ê²Œ ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ë¶€ì—¬!</span>`);

        this.render();
        this.timer = setTimeout(() => this.turn(), 1000);
    },

turn: function() {
        const battleScreen = document.getElementById('battle-screen');
        if (this.isOver || !battleScreen || battleScreen.style.display === 'none') {
            console.warn("âš ï¸ Turn called but game is over or not visible");
            this.cleanup();
            return;
        }
        
        this.isProcessing = false;
        if (this.isOver) return;

        // [Fix] ì„¸ë‡Œ ëŒ€ìƒ ì‚¬ë§ ì‹œ ì•ˆì „í•˜ê²Œ í•´ì œ
        if (this.isMindControlling && this.isMindControlling.isDead) {
            this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ëŒ€ìƒì´ ì‚¬ë§í•˜ì—¬ ì œì–´ê¶Œì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.</span>");
            this.isMindControlling = null;
            this.currentMCCasterId = null;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }

        const round = Math.ceil(this.turnCount / 6);
        const tVal = this.queue[this.curr];
        
        // 1. ìœ ë‹› ì •ì˜ (ê¸°ì¡´ ì°Œêº¼ê¸° ì˜¤ë¥˜ í•´ê²°ë¨) - ì •ìˆ˜ ë³€í™˜ ì¶”ê°€
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // 2. [ë¡œì§ ì‚­ì œë¨] ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ì–´, ì‚¬ì „ ì¤€ë¹„(MC_READY) ë‹¨ê³„ê°€ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
        // (ì´ê³³ì— ìˆë˜ ë¬¸ë²• ì˜¤ë¥˜ ë° êµ¬ë²„ì „ ë¡œì§ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.)


        // 3. [ê¶Œí•œ íŒì •] ì¡°ì‘ ê¶Œí•œ ì„¤ì • (ëª¨ë“  ìœ ë‹› ê³µí†µ ë¡œì§)
        // ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ íŒ€(0)ì´ë©´ ë‚´ í„´.
        let isMyTurn = (u.team === 0);
        let isPuppetTurn = false;

        // ì„¸ë‡Œ ìƒíƒœ ì²´í¬: í˜„ì¬ í„´ ìœ ë‹›ì´ ì„¸ë‡Œëœ ëŒ€ìƒì´ê³ , ì„¸ë‡Œì˜ ì£¼ì²´ê°€ 'ë‚˜'ì¸ê°€?
        if (this.isMindControlling && this.isMindControlling.id === u.id) {
            // ê°„ë‹¨ í•´ê²°: ë‚´ íŒ€ì´ ì•„ë‹Œë°(ì êµ°ì¸ë°) ì„¸ë‡Œ ë³€ìˆ˜ê°€ ì¼œì ¸ìˆë‹¤ë©´, ë‚´ê°€ ì¡°ì¢…í•˜ëŠ” ê²ƒì„.
            if (u.team !== 0) { 
                isMyTurn = true; 
                isPuppetTurn = true; 
            } else {
                // ë°˜ëŒ€ë¡œ ë‚´ ìœ ë‹›ì´ ì ì—ê²Œ ì„¸ë‡Œë‹¹í–ˆë‹¤ë©´? -> ì¡°ì‘ ê¶Œí•œ ë°•íƒˆ
                isMyTurn = false;
            }
        }

        // 4. AI ê°ì‹œì (Watchdog) ë° ì¢…ë£Œ ì²´í¬
        if (this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            this.watchdog = setTimeout(() => {
                console.log("AI Stuck. Forcing next.");
                this.endTurn();
            }, 3000);
        }
        if (this.endCheck()) return;

        // 5. [ìˆ˜ì •] í„´ ì‹œì‘ ìƒíƒœì´ìƒ ì²˜ë¦¬ (ë„íŠ¸ ë°ë¯¸ì§€ -> ì‚¬ë§ ì²´í¬ -> CC ì²´í¬)
        if (!u.isDead) {
            u.resetTurn();
            
            // 5-1. ë„íŠ¸ ë°ë¯¸ì§€ ì²˜ë¦¬ (ë§¹ë…, í™”ìƒ ë“±)
            const dotLogs = u.tickStatus();
            dotLogs.forEach(log => this.log(log));
            
            // ë„íŠ¸ ë°ë¯¸ì§€ë¡œ ì‚¬ë§ ì‹œ í„´ ì¢…ë£Œ
            if (u.isDead) {
                this.endTurn(true);
                return;
            }

            // [í›„ê³µ ë³´ì •] í•´ì œ
            if (u.hasStatus('START_IMMUNITY')) {
                const myTeam = u.team === 0 ? this.pTeam : this.eTeam;
                myTeam.forEach(member => {
                    member.status = member.status.filter(s => s.type !== 'START_IMMUNITY');
                });
                this.log(`<span class='log-sys'>ğŸ”“ [${u.team===0?'ì•„êµ°':'ì êµ°'}] í›„ê³µ ë³´í˜¸ë§‰ í•´ì œ!</span>`);
                this.render();
            }
        }

        // 5-2. í–‰ë™ ë¶ˆê°€(CC) ì²´í¬ (ìš°ì„ ìˆœìœ„: ì‚¬ë§ > ê¸°ì ˆ/ë¹™ê²° > ì„¸ë‡Œ)
        const hasCC = u.hasStatus('STUN') || u.hasStatus('FREEZE') || u.hasStatus('SLEEP');
        
        // [ìˆ˜ì •] ì„¸ë‡Œ ëŒ€ê¸° ì¤‘ì´ì–´ë„ ê¸°ì ˆí•˜ë©´ í„´ì„ ë‚ ë ¤ì•¼ í•¨ (ì„¸ë‡Œ ë¶ˆë°œ ì²˜ë¦¬)
        if (hasCC) {
            UI.floatText(u, "í–‰ë™ë¶ˆê°€", "ft-miss");
            this.log(`<span class='log-crit'>ğŸš« [${u.name}] ìƒíƒœì´ìƒìœ¼ë¡œ í–‰ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
            
            // ê¸°ì ˆë¡œ ì¸í•´ ì„¸ë‡Œ íƒ€ì´ë°ì„ ë†“ì³¤ë‹¤ë©´ ì˜ˆì•½ ì·¨ì†Œ
            if (u.hasStatus('MC_WAIT')) {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸŒ€ [${u.name}] ê¸°ì ˆí•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ ë¶ˆë°œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
            
            setTimeout(() => this.endTurn(), 1000);
            return;
        }
        
        // (ì—¬ê¸° ìˆë˜ ì¤‘ë³µ ì½”ë“œë“¤ì„ ê¹¨ë—ì´ ì§€ì› ìŠµë‹ˆë‹¤)

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        // 6. [ì„¸ë‡Œ ë°œë™] í„´ í•˜ì´ì¬í‚¹ (ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨)
        const mcWaitStatus = u.status.find(s => s.type === 'MC_WAIT');
        if (mcWaitStatus) {
            // ì‹œì „ì(ì£¼ì¸) í™•ì¸
            let caster = null;
            if (mcWaitStatus.sourceId !== undefined && mcWaitStatus.sourceId !== -1) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                caster = allUnits.find(unit => unit.id === mcWaitStatus.sourceId);
            }

                    // ì‹œì „ìê°€ ë‚´ íŒ€ì´ë©´ -> ë‚´ í„´ìœ¼ë¡œ ê°•ì œ ì „í™˜ (ëª¨ë“  ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥)
        if (caster && !caster.isDead && caster.team === 0) {
            // [ìˆ˜ì •] ì„¸ë‡Œ ì„±ê³µ ì‹œ, ì´ë¯¸ ëŒì•„ê°€ê³  ìˆëŠ” AI ê°ì‹œì(Watchdog)ë¥¼ ë°˜ë“œì‹œ êº¼ì•¼ í•¨
            if (this.watchdog) clearTimeout(this.watchdog);

            isMyTurn = true;
            isPuppetTurn = true;
            this.isMindControlling = u; // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
            this.currentMCCasterId = caster.id; // [ì¶”ê°€] ì‹œì „ì ID ì €ì¥ (ì‚¬ë§ íŒì •ìš©)

            this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°° ì„±ê³µ! ì œì–´ê¶Œì„ íƒˆì·¨í–ˆìŠµë‹ˆë‹¤.</span>`);

                UI.floatText(u, "ì œì–´ê¶Œ íšë“", "ft-crit");
                
                // ìƒíƒœ ì œê±° (ì´ë²ˆ í„´ì— ë°”ë¡œ í–‰ë™í•˜ë¯€ë¡œ ìƒíƒœ ì•„ì´ì½˜ ì‚­ì œ)
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            } 
            // ì‹œì „ìê°€ ì  íŒ€ì´ë©´ -> ì ì´ ì¡°ì¢… (ë‚´ ì…ë ¥ ì°¨ë‹¨)
            else if (caster && !caster.isDead && caster.team === 1) {
                isMyTurn = false;
                this.isMindControlling = u;
                
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì ì—ê²Œ ì¡°ì¢…ë‹¹í•©ë‹ˆë‹¤!</span>`);
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            }
            // ì‹œì „ìê°€ ì£½ì—ˆìœ¼ë©´ í•´ì œ
            else {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ìê°€ ì‚¬ë§í•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤.</span>`);
            }
            
            // ì£¼ì˜: ê¸°ì¡´ì˜ 'return'ì„ ì‚­ì œí•˜ì—¬ ì•„ë˜ì˜ input() ë¡œì§ìœ¼ë¡œ íë¥´ê²Œ í•¨
        }

        // 7. [UI ì—…ë°ì´íŠ¸] ë°°ë„ˆ ë° ë©”ì‹œì§€
        let turnName = u.name.split(' ')[0];
        let indicatorText = `Round ${round} : ${turnName}`;
        
        if (isPuppetTurn) {
            UI.showTurnBanner(true);
            indicatorText = `ğŸ§  ì •ì‹  ì§€ë°° ì¤‘! [${turnName}] ì¡°ì¢…í•˜ì„¸ìš”!`;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #d500f9";
        } else if (isMyTurn) {
            UI.showTurnBanner(true);
            if (this.mode === 'pvp') indicatorText += " (ë‚˜)";
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ff80ab";
        } else {
            UI.showTurnBanner(false);
            if (this.mode === 'pvp') indicatorText = "ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
            if (this.isMindControlling && u.id === this.isMindControlling.id && u.team === 0) {
                 indicatorText = "ğŸ§  ë‚´ ìœ ë‹›ì´ ì¡°ì¢…ë‹¹í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
            }
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }
        
        document.getElementById('turn-indicator').innerText = indicatorText;
        // [ì‚­ì œ] ìƒˆ ì—”ì§„ì€ ê³¡ ë³€ê²½ ë°©ì‹ì´ë¯€ë¡œ í…œí¬ ì¡°ì ˆ ë¶ˆí•„ìš”
        // const danger = ... 
        // MusicEngine.play('Crisis_Track'); // í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì„œ ìœ„ê¸° ì „ìš© ê³¡ ì¬ìƒ ê°€ëŠ¥
        this.turnCount++;

        // 8. [ì…ë ¥ í™œì„±í™” ì—¬ë¶€ ê²°ì •]
        if (isMyTurn || this.difficulty === 'local') {
            this.input(u);
            // ë§Œì•½ ê¼­ë‘ê°ì‹œ í„´ì´ë¼ë©´ íˆ´íŒ ë„ì›Œì£¼ê¸°
            if (isPuppetTurn) {
                setTimeout(() => {
                    const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                    const el = document.getElementById(cardId);
                    if(el) UI.showTooltip(u, el);
                }, 100);
            }
        } else {
            this.noInput();
            if (this.mode !== 'pvp') {
                // [Fix] ê¸°ì¡´ íƒ€ì´ë¨¸ ì œê±° í›„ ì‹¤í–‰ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
                if (this.timer) clearTimeout(this.timer);
                this.timer = setTimeout(() => this.ai(u), 800);
            }
        }
    },

    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for (let i = 0; i < 6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx];
            const isP = qId % 2 === 0;
            const uIdx = isP ? Math.floor(qId / 2) : Math.floor((qId - 1) / 2);
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            if (!u) continue; // null ì²´í¬ ì¶”ê°€
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if (u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if (!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });
            team.forEach((u) => {
                const cardId = tid === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                
                d.className = `unit role-${role} ${u.isSuper ? 'super-hero' : ''} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;

                // [íˆ´íŒ & ê°ì •í‘œí˜„ ë¡œì§ í†µí•©]
                d.onmousedown = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return;
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.onmouseup = () => { clearTimeout(d.pressTimer); UI.hideTooltip(); };
                d.onmouseleave = () => { 
                    clearTimeout(d.pressTimer); UI.hideTooltip();
                    // ë¯¸ë¦¬ë³´ê¸° ì œê±°
                    const p = d.querySelector('.hp-preview');
                    if(p) p.remove();
                };
                d.ontouchstart = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return;
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.ontouchend = () => { clearTimeout(d.pressTimer); UI.hideTooltip(); };

                // [ì‹ ê·œ] í´ë¦­ ì‹œ ê°ì •í‘œí˜„ ë©”ë‰´ (ìŠ¤í‚¬ ì„ íƒ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
                d.onclick = (e) => {
                    if (Game.selectedSkillIdx !== -1) return; // íƒ€ê²ŸíŒ… ì¤‘ì´ë©´ ë¬´ì‹œ
                    if (u.team === 0) { // ë‚´ ìœ ë‹›ë§Œ
                        UI.showEmoteMenu(u, d);
                        e.stopPropagation();
                    }
                };

                // [ì‹ ê·œ] ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
                d.onmouseenter = () => {
                    // ìŠ¤í‚¬ ì„ íƒ ì¤‘ì´ê³  + ì êµ°ì´ë©° + ë‚´ê°€ ì¡°ì‘ ì¤‘ì¼ ë•Œ
                    if (Game.selectedSkillIdx !== -1 && tid !== 0 && !Game.isProcessing) {
                        const pred = Game.predictDmg(u);
                        if (pred > 0) {
                            const bar = d.querySelector('.status-bar');
                            if (bar) {
                                const preview = document.createElement('div');
                                preview.className = 'hp-preview';
                                // ì²´ë ¥ë°” ë¹„ìœ¨ ê³„ì‚°
                                const widthPct = Math.min(100, (pred / u.maxHp) * 100);
                                preview.style.width = widthPct + '%';
                                bar.appendChild(preview);
                            }
                        }
                    }
                };

                let tags = u.status.map(s => {
                    let c = 'tag';
                    const map = {
                        'POISON': 'poison', 'FREEZE': 'freeze', 'SILENCE': 'silence',
                        'EVADE': 'evade', 'BURN': 'burn', 'BANISH': 'banish',
                        'TRAP': 'trap', 'BIND': 'bind', 'GROWTH': 'growth',
                        'ATK_DOWN': 'atkdown', 'BLIND': 'blind', 'IMMUNITY': 'immunity',
                        'HEAL_DOWN': 'healdown', 'LIGHT_MIGHT': 'atkup', 'LIFESTEAL_BUFF': 'lifesteal',
                        'ATK_BUFF_SMALL': 'atkup_s', 'START_IMMUNITY': 'start-immunity',
                        'MC_WAIT': 'mc-wait', 'MC_READY': 'mc-ready'
                    };
                    if (s.type.includes('PROVOKED')) c += ' taunt';
                    else if (s.type.startsWith('KARMA_VICTIM')) c += ' karma';
                    else if (map[s.type]) c += ` ${map[s.type]}`;
                    let txt = s.type;
                    const tMap = {
                        'POISON': 'ë…', 'FREEZE': 'ë¹™ê²°', 'SILENCE': 'ì¹¨ë¬µ', 'DMG_RED': 'ë°©ì–´â†‘',
                        'EVADE': 'íšŒí”¼', 'BURN': 'í™”ìƒ', 'TRAP': 'ì†ë°•', 'BANISH': 'ì¶”ë°©',
                        'BIND': 'ê²°ì†', 'GROWTH': 'ì„±ì¥', 'ATK_DOWN': 'ê³µê²©â†“', 'BLIND': 'ì‹¤ëª…',
                        'IMMUNITY': 'ë©´ì—­', 'HEAL_DOWN': 'ì¹˜ìœ â†“', 'LIGHT_MIGHT': 'ê³µê²©â†‘',
                        'LIFESTEAL_BUFF': 'ğŸ©¸í¡í˜ˆ', 'ATK_BUFF_SMALL': 'ğŸ”¥ê³µê²©â†‘', 'START_IMMUNITY': 'ğŸ›¡ï¸ì„ ê³µë°©ì–´',
                        'MC_WAIT': 'ğŸŒ€ì„¸ë‡Œì¤‘...', 'MC_READY': 'ğŸ§ ì¡°ì¢…ê°€ëŠ¥'
                    };
                    if (s.type.includes('PROVOKED')) txt = 'ë„ë°œ';
                    else if (s.type.startsWith('KARMA_VICTIM')) txt = 'ğŸ‘ï¸ì—…ë³´';
                    else if (tMap[s.type]) txt = tMap[s.type];
                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');
                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;
                let bgClass = `bg-${u.base}`;
                if (u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if (u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || '';
                let extraBadge = '';
                if (u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;

                let displayName = u.name.split(' ')[0];
                if (u.isSuper) {
                    const emo = EMOTION_DB[u.getKey()];
                    // 1. ê°ì • DBì— ìˆê³ , í•´ê¸ˆëœ ìƒíƒœë¼ë©´ íƒ€ì´í‹€ í‘œì‹œ
                    if (emo) {
                        displayName = `[${emo.t}] ${displayName}`;
                    } else {
                        // 2. ì˜ˆì™¸ ì²˜ë¦¬ (ê¸°ì¡´ ë¡œì§)
                        if (role === 'nuker') displayName = `ğŸ‘¹God ${displayName}`;
                        else if (role === 'tank') displayName = `ğŸ›¡ï¸Lord ${displayName}`;
                        else if (role === 'supp') displayName = `ğŸ˜‡Saint ${displayName}`;
                    }
                }

                // [ì‹ ê·œ] ë™ì  ì²´ë ¥ë°” ìƒ‰ìƒ (Dynamic HP Color)
                const hpPct = (u.hp / u.maxHp) * 100;
                let hpColor = '#66bb6a'; // Green (Safe)
                if (hpPct <= 25) hpColor = '#ef5350'; // Red (Danger)
                else if (hpPct <= 50) hpColor = '#ffb74d'; // Orange (Warning)

                // [UI] ìƒì„± ì•„ì´ì½˜ ê³„ì‚° (ì¶”ê°€ëœ ì½”ë“œ)
                let affInd = '';
                if (this.turnChar && this.turnChar !== u && this.turnChar.team !== u.team) {
                    const aff = Common.calc(this.turnChar, u);
                    if (aff.v > 1.1) affInd = ' <span style="color:red; font-size:12px;">ğŸ”º</span>'; // ì•½ì 
                    else if (aff.v < 0.9) affInd = ' <span style="color:gray; font-size:12px;">ğŸ›¡ï¸</span>'; // ì €í•­
                }

                // í…œí”Œë¦¿ ë¦¬í„°ëŸ´ì— ${affInd} ì¶”ê°€
                const innerHTML = ` ${extraBadge} <div class="tag-container">${tags}</div> <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div> <div class="unit-name" style="font-size:15px; margin-bottom:3px; ${u.isSuper ? 'color:#fbc02d; text-shadow:0 0 5px rgba(255,235,59,0.5);' : ''}">${displayName} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div> <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${hpPct}%; background:${hpColor};"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div> <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div> `;
                if (d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0);
        draw('enemy-row', this.eTeam, 1);
    },

endTurn: function(isFast = false) {
        if (this.isOver) return;
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // í˜„ì¬ í„´ ì£¼ì¸ ìœ ë‹› ì°¾ê¸°
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // [ë°¸ëŸ°ìŠ¤ ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§
        // "í˜„ì¬ í„´ì„ ë§ˆì¹œ ìœ ë‹›(u)"ì´ "ì¡°ì¢… ì¤‘ì¸ ìœ ë‹›(isMindControlling)"ì¼ ë•Œë§Œ í•´ì œ
        if (this.isMindControlling && u && u.id === this.isMindControlling.id) {
             const puppet = this.isMindControlling;
             
             this.log(`<span class='log-sys'>ğŸ•Šï¸ [${puppet.name}] ì¡°ì¢… ì™„ë£Œ. ì •ì‹  ì§€ë°°ê°€ í•´ì œë©ë‹ˆë‹¤.</span>`); // ë©”ì‹œì§€ ë³€ê²½
             UI.floatText(puppet, "ì§€ë°° ì¢…ë£Œ", "ft-miss"); // í…ìŠ¤íŠ¸ ë³€ê²½
             
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             this.isMindControlling = null;
             
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab";
        }

        if (u && !u.isDead) u.decayStatus();
        
        [...this.pTeam, ...this.eTeam].forEach(u => {
            if (u.hp <= 0) this.die(u)
        });
        
        this.curr = (this.curr + 1) % 6;
        
        // ë°ìŠ¤ë§¤ì¹˜ ë¡œì§
        if (this.curr === 0) {
            const round = Math.ceil(this.turnCount / 6);
            if (round > 20) {
                [...this.pTeam, ...this.eTeam].forEach(u => {
                    if (!u.isDead) u.atk += 10;
                });
                this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
            }
        }
        
        this.render();
        const delay = isFast ? 100 : 1500;

        // [ìˆ˜ì •] íƒ€ì´ë¨¸ ì‹¤í–‰ ì§ì „ì—ë„ ê²Œì„ ì¢…ë£Œ ì—¬ë¶€(Kill Switch) í™•ì¸
        if (this.isOver) return;

        this.timer = setTimeout(() => {
            // [ì•ˆì „ì¥ì¹˜] ëŒ€ê¸° ì‹œê°„ ë™ì•ˆ ê²Œì„ì´ ë¦¬ì…‹ë˜ì—ˆëŠ”ì§€ í•œ ë²ˆ ë” í™•ì¸
            if (this.isOver) return;
            this.turn();
        }, delay);
    }, 

    // [ìˆ˜ì •] async í‚¤ì›Œë“œ ì¶”ê°€ (íˆ¬ì‚¬ì²´ ëŒ€ê¸°ìš©)
    execute: async function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el => el.onclick = null);
        AudioSys.speak(atk);

        if (isOnlineMode && !isRemote) {
            const isMindControlAction = this.isMindControlling && atk.id === this.isMindControlling.id;
            if (atk.team !== 0 && !isMindControlAction) {
                alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!");
                return;
            }
            netRndBuffer = [];
        }

        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];
        if (!logic) {
            this.endTurn(); 
            return;
        }

        if (sIdx > 0 && !def) {
             const needsTarget = !['SELF', 'SELF_BUFF', 'ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(SKILL_DB[key].type);
             if (needsTarget) {
                 this.log(`<span class='log-sys'>âš ï¸ [${atk.name}] ëŒ€ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
                 this.endTurn();
                 return;
             }
        }

        // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ (íƒ€ê²Ÿì´ ìˆê³ , ìì‹ ì´ ì•„ë‹ ë•Œ)
        if (def && atk.id !== def.id) {
            const skillType = (sIdx === 0) ? 'ATTACK' : SKILL_DB[key].type;
            // ìŠ¤í‚¬ íƒ€ì…ì´ ë²„í”„/íì´ ì•„ë‹ˆê±°ë‚˜, íì´ë¼ë„ ì ì—ê²Œ ì“¸ ë•Œ(ì„¸ë‡Œ)ëŠ” ê³µê²© ì´í™íŠ¸
            // ê°„ë‹¨í•˜ê²Œ ì•„ì´ì½˜ ë§¤í•‘
            let pIcon = 'âœ¨';
            if (atk.base === 'Fire') pIcon = 'ğŸ”¥';
            else if (atk.base === 'Water') pIcon = 'ğŸ’§';
            else if (atk.base === 'Tree') pIcon = 'ğŸƒ';
            else if (atk.base === 'Metal') pIcon = 'âš”ï¸';
            else if (atk.base === 'Earth') pIcon = 'ğŸª¨';
            else if (atk.base === 'Dark') pIcon = 'ğŸ’€';
            else if (atk.base === 'Normal') pIcon = 'ğŸ‘Š';
            
            // íŠ¹ìˆ˜ ìŠ¤í‚¬ ì•„ì´ì½˜ ì˜¤ë²„ë¼ì´ë“œ
            if (sIdx === 1 && atk.base === 'Metal-Light') pIcon = 'â˜£ï¸'; // ë…ê°€ìŠ¤
            if (sIdx === 2 && atk.base === 'Water-Dark') pIcon = 'â„ï¸'; // ì ˆëŒ€ì˜ë„

            // ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸° (0.4ì´ˆ)
            await UI.fireProjectile(atk, def, pIcon);
        }
        
        // âœ… try-catchë¡œ ìŠ¤í‚¬ ì‹¤í–‰ ë³´í˜¸
        try {
            const playedSound = logic.useSkill(atk, def, sIdx, this);
            if (!playedSound) AudioSys.play('SKILL');

            // [ê°ì„± ì²´í¬] ìŠ¤í‚¬ ì‚¬ìš© í›„ í†µê³„ ê°±ì‹  ì‹œ ê°ì„± í™•ì¸
            atk.checkAwakening();

            // âœ… ì„±ê³µ ì‹œì—ë§Œ ë„¤íŠ¸ì›Œí¬ ì „ì†¡
            if (isOnlineMode && !isRemote) {
                socket.emit('action', {
                    room: myRoom,
                    attackerId: atk.id,
                    attackerTeam: atk.team,
                    targetId: def ? def.id : null,
                    targetTeam: def ? def.team : null,
                    skillIdx: sIdx,
                    mcState: { // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
                        isMindControlling: !!this.isMindControlling,
                        mcTargetId: this.isMindControlling ? this.isMindControlling.id : null,
                        mcCasterId: this.currentMCCasterId
                    }
                });
            }
        } catch(e) {
            console.error('âŒ Skill execution failed:', e);
            this.log(`<span class='log-sys' style='color:red;'>âš ï¸ [${atk.name}] ìŠ¤í‚¬ ì‹¤í–‰ ì˜¤ë¥˜ ë°œìƒ</span>`);
            netRndBuffer = []; // ì‹¤íŒ¨ ì‹œ ë²„í¼ ì´ˆê¸°í™”
        }
        
        // [ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ì€ endTurn()ìœ¼ë¡œ ì´ë™ë¨
        this.endTurn();
    },

    reset: function() {
        // [ìˆ˜ì •] ê°•ì œ ì¢…ë£Œ í‚¬ ìŠ¤ìœ„ì¹˜ ê°€ë™
        this.isOver = true; // ì§„í–‰ ì¤‘ì¸ ë¡œì§ì´ ì¦‰ì‹œ ë©ˆì¶”ë„ë¡ í”Œë˜ê·¸ ì„¤ì •
        this.isProcessing = false;

        // íƒ€ì´ë¨¸ ì œê±°
        if (this.timer) { clearTimeout(this.timer); this.timer = null; }
        if (this.watchdog) { clearTimeout(this.watchdog); this.watchdog = null; }

        // ì˜¤ë””ì˜¤ ì •ë¦¬
        MusicEngine.stop();

        // UI ì •ë¦¬
        UI.closeModal();
        document.getElementById('battle-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));

        // ë°ì´í„° ì´ˆê¸°í™”
        this.selected = [];
        this.pTeam = []; // íŒ€ ì •ë³´ë„ ë‚ ë ¤ì„œ ìœ ë ¹ ì°¸ì¡° ë°©ì§€
        this.eTeam = [];

        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // ì£¼ì˜: init()ì€ ì—¬ê¸°ì„œ í˜¸ì¶œí•˜ì§€ ì•Šê³ , ì˜ì›… ì„ íƒ í™”ë©´ë§Œ ë³´ì—¬ì¤ë‹ˆë‹¤.
        // init()ì€ í˜ì´ì§€ ë¡œë“œ ì‹œ í•œ ë²ˆ, í˜¹ì€ í•„ìš” ì‹œì—ë§Œ í˜¸ì¶œí•˜ë„ë¡ ë³€ê²½
        this.pool = []; 

        // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬ ì¶”ê°€
        if (isOnlineMode) {
                isOnlineMode = false;
                globalRNG = null;
                gameSeed = null;
        }
        window.onload(); // ë‹¤ì‹œ ì´ˆê¸°í™” (Game.init í¬í•¨)
    },
    // [ê°ì„± ì²´í¬] ìŠ¤íƒ¯ ê¸°ë¡ ì‹œ ê°ì„± í™•ì¸
    recordStat: function(unit, type, amount) {
        if (!unit || amount <= 0) return;
        if (type === 'dmg') unit.stats.dmg += amount;
        if (type === 'shield') unit.stats.shieldGiven += amount;
        if (type === 'heal') unit.stats.heal += amount;
        unit.checkAwakening();
    },
    input: function(u) {
    // ì„¸ë‡Œ ìƒíƒœ UI í‘œì‹œ
    const cp = document.querySelector('.control-panel');
    if (cp) {
        cp.style.borderTop = this.isMindControlling ? "5px solid #d500f9" : "5px solid #ff80ab";
    }
    
    const k = u.getKey();
    const s = SKILL_DB[k];
    
    // ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ ë°©ì–´ ì½”ë“œ
    if (!s) {
        console.error("âŒ SKILL_DB missing for key:", k, "Unit:", u.name);
        document.getElementById('p-icon').innerText = 'â“';
        document.getElementById('p-desc').innerText = 'ERROR: ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ';
        document.getElementById('sk-0').innerHTML = '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br><span class="skill-desc">1.0ë°°</span>';
        document.getElementById('sk-1').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        document.getElementById('sk-2').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        [0, 1, 2].forEach(i => document.getElementById(`sk-${i}`).disabled = true);
        this.log(`<span class='log-sys'>âš ï¸ [${u.name}] ìŠ¤í‚¬ ì •ë³´ ì˜¤ë¥˜ ë°œìƒ</span>`);
        return;
    }
    
    const silenced = u.hasStatus('SILENCE');
    
    // íŒ¨ì‹œë¸Œ ì •ë³´
    document.getElementById('p-icon').innerText = s.icon || 'â“';
    document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
    
    // ìŠ¤í‚¬ ë²„íŠ¼ ì •ë³´
    document.getElementById('sk-0').innerHTML = 
        '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br>' +
        '<span class="skill-desc">1.0ë°° í”¼í•´</span>';
    
    document.getElementById('sk-1').innerHTML = 
        '<span class="skill-name">' + (s.s1 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s1d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    document.getElementById('sk-2').innerHTML = 
        '<span class="skill-name">' + (s.s2 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s2d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ
    document.getElementById('sk-0').disabled = false;
    document.getElementById('sk-1').disabled = silenced;
    
    // S2 ë¹„í™œì„±í™” ì¡°ê±´
    let sk2Disable = silenced;
    
    if (k === 'Fire-Light' && (u.s2Count || 0) >= 5) {
        sk2Disable = true;
    }
    
    if (k === 'Tree-Dark') {
        const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
        const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
        if (aliveAllies.length === 0 || u.linkedAllyId !== -1) {
            sk2Disable = true;
        }
    }
    
    document.getElementById('sk-2').disabled = sk2Disable;
    
    if (silenced) {
        this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
    }
    
    // ë„ë°œ í™•ì¸ (ì„¸ë‡Œ ìƒíƒœë¼ë©´ ë„ë°œ ë¬´ì‹œ)
    const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
    const isBrainwashed = this.isMindControlling && this.isMindControlling.id === u.id;

    if (provoked && !isBrainwashed) { // ğŸ§  ì„¸ë‡Œ ì•„ë‹ ë•Œë§Œ ë„ë°œ ì ìš©
        const targetId = parseInt(provoked.type.split('_')[2]);
        const enemies = u.team === 0 ? this.eTeam : this.pTeam;
        const allies = u.team === 0 ? this.pTeam : this.eTeam;
        const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
        
        if (!target || target.isDead) {
            u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
            this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
            UI.floatText(u, "ììœ !", "ft-heal");
            this.render();
        } else {
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput();
            setTimeout(() => this.execute(u, target, 0), 1000);
            return; // ê°•ì œ ê³µê²© ì‹œ í•¨ìˆ˜ ì¢…ë£Œ
        }
    } else if (provoked && isBrainwashed) {
        this.log(`<span class='log-sys'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°°ë¡œ ì¸í•´ ë„ë°œì„ ë¬´ì‹œí•©ë‹ˆë‹¤.</span>`);
    }
    
    this.selectedSkillIdx = -1;
},
    noInput: function() {
        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            b.disabled = true;
            b.classList.remove('selected');
        });
    },
    prepareSkill: function(idx) {
    this.debugLog('Skill Button Clicked', { skillIndex: idx });

    // âœ… ì´ì „ íƒ€ê²ŸíŒ… ì´ˆê¸°í™” (ì¤‘ë³µ ë°©ì§€)
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    [0, 1, 2].forEach(i => {
        const b = document.getElementById(`sk-${i}`);
        if (i === idx) b.classList.add('selected');
        else b.classList.remove('selected');
    });
    
    this.selectedSkillIdx = idx;
        
        // í˜„ì¬ í–‰ë™ ì£¼ì²´ ì°¾ê¸°
        let u;
        if (this.isMindControlling) {
            u = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }

        // [ë””ë²„ê·¸] í–‰ë™ ìœ ë‹› ì •ë³´ ì¶œë ¥
        if (u) this.debugLog('Acting Unit Identified', { name: u.name, id: u.id, isMindControlled: !!this.isMindControlling });

        const k = u.getKey();
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';

        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì¸ë±ìŠ¤ë³„ íƒ€ê²Ÿ íƒ€ì… ëª…í™•í™”
        if (idx === 0) {
            targetType = 'ENEMY'; // í‰íƒ€ëŠ” ë¬´ì¡°ê±´ ê³µê²©
        } else if (idx === 1) {
            // S1 ìŠ¤í‚¬ë“¤ì˜ íƒ€ê²Ÿ íƒ€ì… ì„¤ì •
            // [ìˆ˜ì •] Tree-Darkì˜ S1(ê°€ì‹œì°Œë¥´ê¸°)ì€ ê³µê²©ê¸°ì´ë¯€ë¡œ ENEMYì—¬ì•¼ í•¨
            if (['Tree'].includes(k)) targetType = 'SELF_BUFF';
            else if (['Fire-Light'].includes(k)) targetType = 'ALL_ALLY'; // í¡í˜ˆ ë¶€ì—¬ëŠ” ì „ì²´ ë²„í”„
            else if (['Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; // ë””ë²„í”„ ê³µê²©
            else targetType = 'ENEMY'; // ë‚˜ë¨¸ì§€ëŠ” ëŒ€ë¶€ë¶„ ê³µê²©
        } else if (idx === 2) {
            // S2ëŠ” DBì— ìˆëŠ” target ì†ì„± ì‚¬ìš©
            targetType = s.target || 'ENEMY';
        }

        // íƒ€ê²ŸíŒ… í•¨ìˆ˜ í˜¸ì¶œ
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
    // 1. í–‰ë™ ìœ ë‹› í™•ì •
    if (!actingUnit) {
        if (this.isMindControlling) {
            actingUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            actingUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }
    }

    // 2. ê¸°ì¡´ íƒ€ê²ŸíŒ… ì´ˆê¸°í™”
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    // 3. ìŠ¤í‚¬ íƒ€ì… ë¶„ë¥˜
    const SUPPORT_TYPES = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF', 'TARGET_BUFF', 'HEAL', 'BUFF'];
    const isSupportSkill = SUPPORT_TYPES.includes(targetType);
    const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
    const isSelfOnly = ['SELF', 'SELF_BUFF'].includes(targetType);

    // 4. íŒ€ ì •ì˜ (ì›ë˜ ì†Œì† ê¸°ì¤€)
    const originalAllies = actingUnit.team === 0 ? this.pTeam : this.eTeam;
    const originalEnemies = actingUnit.team === 0 ? this.eTeam : this.pTeam;

    let finalTargets = [];

    // 5. ì„¸ë‡Œ ì—¬ë¶€ì— ë”°ë¥¸ íƒ€ê²Ÿ ê²°ì •
    const isMindControlled = this.isMindControlling && actingUnit.id === this.isMindControlling.id;
    
    if (isSelfOnly) {
        // ìê°€ ë²„í”„ëŠ” ì–¸ì œë‚˜ ìì‹ ì—ê²Œë§Œ
        finalTargets = [actingUnit];
    } 
    else if (isMindControlled) {
        // [ì„¸ë‡Œ ìƒíƒœ] - í”¼ì•„ì‹ë³„ ì—­ì „
        if (isSupportSkill) {
            // í/ë²„í”„ -> ì êµ°(í˜„ì¬ ë‚˜ë¥¼ ì¡°ì¢…í•˜ëŠ” íŒ€)ì—ê²Œ ì‚¬ìš©
            finalTargets = originalEnemies.filter(u => !u.isDead);
        } else {
            // ê³µê²© -> ì•„êµ°(ë‚˜ì˜ ì›ë˜ ë™ë£Œ)ì„ ê³µê²©
            // [ê°œì„ ] ìí•´(Self Attack)ë„ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ì„ í¬í•¨
            finalTargets = originalAllies.filter(u => !u.isDead);
            // ìí•´ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ë„ í¬í•¨ (ì¤‘ë³µ ë°©ì§€ ì²´í¬)
            if (!finalTargets.some(t => t.id === actingUnit.id)) {
                finalTargets.push(actingUnit);
            }
        }
    } else {
        // [ì •ìƒ ìƒíƒœ]
        if (isSupportSkill) {
            finalTargets = originalAllies.filter(u => !u.isDead);
        } else {
            // ì êµ° + "ì„¸ë‡Œë‹¹í•´ì„œ ë°°ì‹ ìê°€ ëœ ì•„êµ°"ë„ ê³µê²© ê°€ëŠ¥í•´ì•¼ í•¨
            const realEnemies = originalEnemies.filter(u => !u.isDead);
            const traitors = originalAllies.filter(u => !u.isDead && (u.hasStatus('MC_WAIT') || u.hasStatus('MC_READY')));
            finalTargets = [...realEnemies, ...traitors];
        }
    }

    // 6. Tree-Dark ì˜ˆì™¸ ì²˜ë¦¬
    if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2) {
        // ì˜í˜¼ê²°ì†ì€ ìì‹  ì œì™¸ (ë‹¨, ì„¸ë‡Œ ìƒíƒœì—ì„œ í˜¼ì ë‚¨ì€ ê²½ìš°ëŠ” ìí•´ ê°€ëŠ¥)
        if (!isMindControlled || finalTargets.length > 1) {
            finalTargets = finalTargets.filter(t => t.id !== actingUnit.id);
        }
    }

    // 7. íƒ€ê²Ÿ ë Œë”ë§
    let targetClass = isSupportSkill ? 'target-ally' : 'target-enemy';
    if (isAOE && !isSupportSkill) targetClass = 'target-aoe';

    let targetCount = 0;

    finalTargets.forEach((t) => {
        const cardId = t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`;
        const el = document.getElementById(cardId);
        
        if (el) {
            el.classList.add(targetClass);
            el.onclick = () => {
                if (Game.isProcessing) return;
                Game.isProcessing = true;
                
                // ì…ë ¥ ì ê¸ˆ
                this.noInput();
                document.querySelectorAll('.unit').forEach(e => {
                    e.classList.remove('target-enemy', 'target-ally', 'target-aoe');
                });
                
                // ì‹¤í–‰
                this.execute(actingUnit, t, this.selectedSkillIdx);
            };
            targetCount++;
        }
    });

// 8. ë””ë²„ê¹… ë° ì˜ˆì™¸ ì²˜ë¦¬ (Option 2 ì ìš©)
    if (targetCount === 0) {
        console.warn('âš ï¸ No valid targets:', {
            skillIdx: this.selectedSkillIdx,
            targetType: targetType,
            actingUnit: actingUnit.name,
            isMindControlled: isMindControlled,
            finalTargets: finalTargets.map(t => t.name)
        });

        // íƒ€ê²Ÿì´ ì—†ëŠ” ê²½ìš° UI í”¼ë“œë°±
        if (isMindControlled && !isSupportSkill) {
            UI.floatText(actingUnit, "ëŒ€ìƒì—†ìŒ", "ft-miss");
            this.log(`<span class='log-sys'>âš ï¸ [${actingUnit.name}] ê³µê²©í•  ìˆ˜ ìˆëŠ” ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>`);
        } else if (!isMindControlled && finalTargets.length === 0) {
            console.error('ğŸš¨ Critical: No targets found in normal state!');
            UI.floatText(actingUnit, "íƒ€ê²Ÿì˜¤ë¥˜", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš¨ [${actingUnit.name}] íƒ€ê²ŸíŒ… ì˜¤ë¥˜ ë°œìƒ</span>`);
        }
        
        // âœ… ìŠ¤í‚¬ ì„ íƒ ì´ˆê¸°í™” ì¶”ê°€ (ë²„ê·¸ ìˆ˜ì •)
        this.selectedSkillIdx = -1;
        document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('selected'));
        return; // í•¨ìˆ˜ ì¢…ë£Œ
    }
}, // ì½¤ë§ˆ í•„ìˆ˜ (ë’¤ì— ai í•¨ìˆ˜ê°€ ìˆìŒ)


    // ========== 3997ë²ˆì§¸ ì¤„ë¶€í„° êµì²´ ==========
ai: function(u) {
        // [ê²€ì¦] ì˜¨ë¼ì¸, ë¡œì»¬ PVPë©´ AI ì‘ë™ ì¤‘ì§€
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;
        
        // 0. ê¸°ë³¸ ê²€ì¦
        if (!u || u.isDead) {
            this.endTurn(true);
            return;
        }

        try {
            this.log(`<span class='log-sys'>ğŸ¤– AI í–‰ë™ ì¤‘: ${u.name}</span>`);

            // 1. ì„¸ë‡Œ íŒì •
            const isBrainwashed = (this.isMindControlling && this.isMindControlling.id === u.id);
            if (isBrainwashed) {
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì„¸ë‡Œ ìƒíƒœë¡œ í–‰ë™!</span>`);
            }

            // 2. ì /ì•„êµ° ì‹ë³„
            let enemies, allies;
            if (isBrainwashed) {
                enemies = u.team === 0 ? this.pTeam : this.eTeam; // ì›ë˜ íŒ€ì´ ì 
                allies = u.team === 0 ? this.eTeam : this.pTeam;
            } else {
                enemies = u.team === 0 ? this.eTeam : this.pTeam; // ìƒëŒ€ íŒ€ì´ ì 
                allies = u.team === 0 ? this.pTeam : this.eTeam;
            }

            // 3. ìƒì¡´ì í•„í„°ë§
            let aliveEnemies = enemies.filter(e => !e.isDead && e.id !== u.id);
            const aliveAllies = allies.filter(a => !a.isDead);

            // [ì˜ˆì™¸] ì„¸ë‡Œ ìƒíƒœì¸ë° ê³µê²© ëŒ€ìƒ ì „ë©¸ ì‹œ ìí•´ í—ˆìš©
            if (aliveEnemies.length === 0 && isBrainwashed) {
                aliveEnemies = [u];
            }

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            // 4. ë„ë°œ(Taunt) ì²˜ë¦¬
            if (!isBrainwashed) {
                const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
                if (provoked) {
                    const targetId = parseInt(provoked.type.split('_')[2]);
                    const taunter = aliveEnemies.find(t => t.id === targetId);
                    if (taunter) {
                        this.execute(u, taunter, 0); // í‰íƒ€ ê°•ì œ
                        return;
                    }
                }
            }

            const silenced = u.hasStatus('SILENCE');
            const k = u.getKey();
            const sk = SKILL_DB[k];

            // ---------------------------------------------------------
            // ğŸ§  [AI Core] í—¬í¼ í•¨ìˆ˜ ì •ì˜
            // ---------------------------------------------------------

            const isAttackSkill = (desc, type) => {
                if (!desc) return false;
                if (desc.includes('ë°°') || desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return true;
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER', 'ATK'].includes(type)) return true;
                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼', 'ì„±ì¥', 'ê²°ì†'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY'];
                if (supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type)) return false;
                return true;
            };

            const isSupportSkill = (desc, type) => {
                if (!desc) return false;
                if (desc.includes('ë°°') && !desc.includes('í') && !desc.includes('íšŒë³µ')) return false;
                if (desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return false;
                if (['CC', 'DEBUFF', 'AOE'].includes(type)) return false;
                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼', 'ì„±ì¥', 'ê²°ì†'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY'];
                return supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type);
            };

            // âš”ï¸ ê³µê²© ì ìˆ˜ ê³„ì‚°
            const getAttackScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                let score = 0;
                const skillDesc = skillIdx === 0 ? "ê¸°ë³¸ê³µê²©" : (skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || ""));
                
                let multiplier = 1.0;
                if (skillIdx > 0 && skillDesc) {
                    const match = skillDesc.match(/([\d.]+)ë°°/) || skillDesc.match(/([\d.]+)%/);
                    if (match) {
                        multiplier = parseFloat(match[1]);
                        if (skillDesc.includes('%')) multiplier /= 100;
                    }
                }

                const aff = Game.calc(u, target);
                const baseDmg = u.getAtk() * multiplier * aff.v;

                // A. í‚¬ ìºì¹˜ (Kill Catch)
                if (baseDmg > 0 && target.hp <= baseDmg && !target.hasStatus('IMMORTAL')) {
                    score += 50000; 
                } else {
                    score += baseDmg;
                }
                
                // B. ìƒì„± ìš°ìœ„
                if (aff.v > 1.0) score += 300;

                // ğŸ”¥ [AI ì‹¬í™”] ì•…ë„í•œ íƒ€ê²ŸíŒ… ë¡œì§
                // 1. ì•½ì ë©¸ì‹œ
                const hpPct = target.hp / target.maxHp;
                if (hpPct < 0.4) score += 1500;
                if (hpPct < 0.2) score += 2000;

                // 2. íëŸ¬/ì„œí¬í„° ì ì‚¬
                const tKey = target.getKey();
                if (SKILL_DB[tKey] && SKILL_DB[tKey].role === 'supp') score += 1000;

                // 3. ì‰´ë“œ ë‚­ë¹„ ë°©ì§€ (Metal ìƒëŒ€ë¡œ)
                if (target.base === 'Metal' && !target.extra && target.shield > 0) {
                    const dmgCap = target.maxHp * 0.3;
                    if (baseDmg > dmgCap * 1.5) score -= 3000; 
                }

                // 4. ê´‘ì—­ê¸° íš¨ìœ¨ ê³„ì‚°
                if (['AOE', 'ALL_ENEMY', 'NUKE_PER'].includes(sk.type) && skillIdx > 0) {
                    let aoeBonus = 0;
                    aliveEnemies.forEach(en => {
                        if (en.id === target.id) return;
                        const subAff = Game.calc(u, en);
                        const subDmg = u.getAtk() * multiplier * subAff.v;
                        aoeBonus += subDmg;
                        if (subDmg >= en.hp) aoeBonus += 2000;
                    });
                    score += aoeBonus;
                }

                // C. CC ì¤‘ë³µ ë°©ì§€
                const ccKeywords = ['ê¸°ì ˆ', 'ë¹™ê²°', 'ì¹¨ë¬µ', 'ì„¸ë‡Œ', 'ì†ë°•', 'STUN', 'FREEZE', 'SILENCE'];
                if (ccKeywords.some(kw => skillDesc.includes(kw))) {
                    if (!target.hasStatus('IMMUNITY') && !target.isNormal) {
                        const hasHardCC = target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('SLEEP');
                        if (hasHardCC) score -= 3000;
                        else score += 500;
                    }
                }

                // D. ë°”ìœ„(Earth-Dark) S2 ê³¼ì‰ ì‚¬ìš© ë°©ì§€
                if (u.getKey() === 'Earth-Dark' && skillIdx === 2) {
                    score -= 3000; 
                    if (!target.hasStatus('STUN') && !target.hasStatus('FREEZE')) {
                         score += 3500;
                    }
                }

                // E. ê³ ë‚œì´ë„ í‰íƒ€ ì–µì œ
                if (this.difficulty !== 'easy' && skillIdx === 0) {
                     if (!silenced) score -= 2000;
                }

                return score;
            };

            // ğŸ›¡ï¸ ì§€ì› ì ìˆ˜ ê³„ì‚°
            const getSupportScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                let score = 0;
                const skillDesc = skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || "");

                // A. í íš¨ìœ¨
                if (skillDesc.includes('í') || skillDesc.includes('HP') || sk.type === 'HEAL') {
                    const pct = target.hp / target.maxHp;
                    if (pct < 0.35) score += 5000; 
                    else if (pct > 0.9) score -= 2000; 
                    else score += (target.maxHp - target.hp) * 2.0;
                }

                // B. ì •í™” ìš°ì„ ìˆœìœ„
                if (skillDesc.includes('ì •í™”')) {
                    if (target.status.length > 0) score += 500;
                    if (target.getKey() === 'Earth-Dark' && target.hasStatus('STUN')) score += 8000; 
                    if (target.hasStatus('STUN') || target.hasStatus('FREEZE')) score += 2000;
                }

                // C. ì‰´ë“œ ë‚­ë¹„ ë°©ì§€
                if (skillDesc.includes('ì‰´ë“œ')) {
                    if (target.shield >= 300) score -= 5000; 
                    else if (target.shield < 50) score += 500;
                }

                // D. ìê°€ ë²„í”„
                if (target.id === u.id && (skillDesc.includes('ì„±ì¥') || sk.type === 'SELF_BUFF')) score += 400;

                // E. í‘¸ë¥¸ë¶ˆ(Fire-Light) ìµœì í™” (ì¤‘ë³µ ë°©ì§€)
                if (u.getKey() === 'Fire-Light') {
                    if (skillIdx === 1) { 
                        if (target.hasStatus('LIFESTEAL_BUFF')) {
                            score -= 5000;
                        } else {
                            const lowestHpAlly = aliveAllies.reduce((min, a) => Math.min(min, a.hp / a.maxHp), 1);
                            if (lowestHpAlly > 0.85) score -= 3000; 
                            else score += 3000; 
                        }
                    } else if (skillIdx === 2) { 
                        score += 500; 
                    }
                }

                return score;
            };

            // ---------------------------------------------------------
            // ğŸš€ í–‰ë™ ëª©ë¡ ìƒì„± ë° ì„ íƒ
            // ---------------------------------------------------------
            let actions = [];

            // A. ê³µê²© í–‰ë™ ìˆ˜ì§‘
            aliveEnemies.forEach(e => {
                actions.push({ idx: 0, target: e, score: getAttackScore(e, 0), type: 'attack' });
                if (!silenced) {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isAttackSkill(desc, sk.type)) {
                            if (k === 'Tree-Dark' && i === 2) return; 
                            actions.push({ idx: i, target: e, score: getAttackScore(e, i), type: 'attack' });
                        }
                    });
                }
            });

            // B. ì§€ì› í–‰ë™ ìˆ˜ì§‘
            if (!silenced) {
                aliveAllies.forEach(a => {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isSupportSkill(desc, sk.type)) {
                            if ((sk.type === 'SELF_BUFF' || sk.type === 'SELF') && a.id !== u.id) return;
                            if (k === 'Tree-Dark' && i === 2 && a.id === u.id) return; 
                            actions.push({ idx: i, target: a, score: getSupportScore(a, i), type: 'support' });
                        }
                    });
                });
            }

            // ë””ë²„ê·¸ ë¡œê·¸
            if (typeof DEBUG !== 'undefined' && DEBUG.enabled) {
                console.groupCollapsed(`ğŸ¤– [${u.name}] í–‰ë™ ì„ íƒ`);
                const debugActions = [...actions].sort((a, b) => b.score - a.score);
                debugActions.slice(0, 5).forEach(a => console.log(`${a.idx===0?'í‰íƒ€':(a.idx===1?'S1':'S2')} -> ${a.target.name} (${a.score.toFixed(0)})`));
                console.groupEnd();
            }

            // C. ìµœì  í–‰ë™ ì„ íƒ
            actions.sort((a, b) => (b.score + Math.random()*10) - (a.score + Math.random()*10));
            let best = actions[0];

            if (!best || !best.target || best.score < -5000) {
                best = { 
                    idx: 0, 
                    target: aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)],
                    type: 'attack'
                };
            }

            if (!isBrainwashed && best.target && best.target.team === u.team) {
                const info = best.idx === 0 ? "í‰íƒ€" : (best.idx === 1 ? sk.s1d : sk.s2d);
                if (best.type === 'attack' || (info && info.includes('ë°°') && sk.type !== 'HEAL')) {
                    best.target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
                    best.idx = 0;
                }
            }

            this.execute(u, best.target, best.idx);

        } catch (e) {
            console.error("AI Logic Critical Error:", e);
            this.endTurn(); 
        }
    },

    die: function(u) {
        if (u.isDead) return;
        u.isDead = true;
        u.hp = 0;

        // [ìˆ˜ì •] 1. ì‚¬ë§í•œ ìœ ë‹›(u)ì´ ì‹œì „í•œ 'ì„¸ë‡Œ ëŒ€ê¸°(MC_WAIT)' ìƒíƒœ ëª¨ë‘ ì œê±°
        [...Game.pTeam, ...Game.eTeam].forEach(target => {
            const wait = target.status.find(s => s.type === 'MC_WAIT');
            if (wait && wait.sourceId === u.id) {
                target.status = target.status.filter(s => s.type !== 'MC_WAIT');
                Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì([${u.name}]) ì‚¬ë§ìœ¼ë¡œ [${target.name}]ì˜ ì„¸ë‡Œ ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
        });

        // [ìˆ˜ì •] 2. í˜„ì¬ 'ì¡°ì¢… ì¤‘'ì¸ ìƒíƒœì—ì„œ ì‹œì „ìê°€ ì£½ì—ˆì„ ë•Œ ê°•ì œ í•´ì œ
        // this.currentMCCasterIdëŠ” ìœ„ì—ì„œ ìƒˆë¡œ ì¶”ê°€í•œ ë³€ìˆ˜ì…ë‹ˆë‹¤.
        if (this.isMindControlling && (this.currentMCCasterId === u.id || !this.currentMCCasterId)) {
             const puppet = this.isMindControlling;
             
             // ì„¸ë‡Œ ìƒíƒœ ì•„ì´ì½˜ ì œê±° (MC_READY ë“± ì”ì—¬ë¬¼)
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             
             this.isMindControlling = null;
             this.currentMCCasterId = null;
             
             Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì ì‚¬ë§! [${puppet.name}]ì˜ ì •ì‹  ì§€ë°°ê°€ ì¦‰ì‹œ í’€ë¦½ë‹ˆë‹¤.</span>`);
             UI.floatText(puppet, "ì§€ë°° í•´ì œ", "ft-heal");
             
             // UI ë³µêµ¬
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab"; 
        }
		
        u.status = [];
        Game.log(`${u.name} íƒˆë½`);
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => {
                if (!e.isDead) e.addStatus('POISON', 1, 0, u);
            });
        }
        const allies = u.team === 0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base === 'Tree' && a.extra === 'Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.revengeAtk += 20;
            thorn.thornStack += 0.3;
            thorn.linkedAllyId = -1;
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`);
            UI.floatText(thorn, "RAGE!", "ft-crit");
        });
    },
    endCheck: function() {
        const pd = this.pTeam.every(u => u.isDead);
        const ed = this.eTeam.every(u => u.isDead);

        if (pd || ed) {
            this.isOver = true;
            if (this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN');
            MusicEngine.stop(); // [Fix] ì‹ í˜• ì—”ì§„ ì •ì§€

            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) {
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if (this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)");
            }
            localStorage.removeItem('et_save_v6');
            return true;
        }
        return false;
    },
    log: function(m) {
        const b = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.innerHTML = m;
        b.appendChild(d);
        b.scrollTop = b.scrollHeight;
    },
    shake: function(u) {
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('shake');
            void el.offsetWidth;
            el.classList.add('shake');
        }
    },
    saveGame: function() {
        if (this.isOver) {
            alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue,
            curr: this.curr,
            turnCount: this.turnCount,
            difficulty: this.difficulty,
            mode: this.mode,
            selected: this.selected,
            // [Fix] ì„¸ë‡Œ ë°ì´í„° ì €ì¥ ì¶”ê°€
            mcCasterId: this.currentMCCasterId || null,
            mcTargetId: this.isMindControlling ? this.isMindControlling.id : null
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },
    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if (savedStage) this.challengeStage = parseInt(savedStage);
        if (!json) {
            alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`);
            return;
        }
        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty;
            this.mode = data.mode;
            this.turnCount = data.turnCount;
            this.curr = data.curr;
            this.queue = data.queue;
            this.selected = data.selected;
            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));
            
            // [ì¶”ê°€] ì„¸ë‡Œ ìƒíƒœ ë³µêµ¬
            this.isMindControlling = null;
            this.currentMCCasterId = data.mcCasterId || null;
            if (data.mcTargetId !== null && data.mcTargetId !== undefined) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                const puppet = allUnits.find(u => u.id === data.mcTargetId);
                if (puppet && !puppet.isDead) {
                    this.isMindControlling = puppet;
                    this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ìƒíƒœë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.</span>");
                }
            }

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
            if (!u) {
                alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
                return;
            }
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) {
            console.error('Save Load Error:', e);
            alert(`âš ï¸ ì„¸ì´ë¸Œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në°ì´í„°ê°€ ì†ìƒë˜ì—ˆê±°ë‚˜ ë²„ì „ì´ ë‹¤ë¦…ë‹ˆë‹¤.\n(ì˜¤ë¥˜ ë‚´ìš©: ${e.message})`);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì´ˆê¸°í™”í•˜ì—¬ ê¼¬ì„ ë°©ì§€
            localStorage.removeItem('et_save_v6'); 
        }
    },
    serializeUnit: function(u) {
        return {
            id: u.id,
            team: u.team,
            base: u.base,
            extra: u.extra,
            hp: u.hp,
            maxHp: u.maxHp,
            shield: u.shield,
            atk: u.atk,
            status: u.status,
            isDead: u.isDead,
            thornStack: u.thornStack,
            linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count,
            elecStacks: u.elecStacks,
            growthStack: u.growthStack,
            stats: u.stats,
            passiveTriggered: u.passiveTriggered,
            revengeAtk: u.revengeAtk,
            isSuper: u.isSuper
        };
    },
    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp;
        u.maxHp = d.maxHp;
        u.shield = d.shield;
        u.atk = d.atk;
        u.status = d.status;
        u.isDead = d.isDead;
        if (d.thornStack) u.thornStack = d.thornStack;
        if (d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if (d.s2Count) u.s2Count = d.s2Count;
        if (d.elecStacks) u.elecStacks = d.elecStacks;
        if (d.growthStack) u.growthStack = d.growthStack;
        if (d.stats) u.stats = d.stats;
        if (d.passiveTriggered) u.passiveTriggered = d.passiveTriggered;
        if (d.revengeAtk) u.revengeAtk = d.revengeAtk;
        if (d.isSuper) u.isSuper = d.isSuper;
        return u;
    },
    // ë°ë¯¸ì§€ ì˜ˆì¸¡ ê³„ì‚°ê¸°
    predictDmg: function(target) {
        if (this.selectedSkillIdx === -1 || !target) return 0;
        
        // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì) ì°¾ê¸°
        let atkUnit;
        if (this.isMindControlling) {
            atkUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            if (tVal === undefined || tVal === null) return 0;
            atkUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal/2)] : this.eTeam[Math.floor((tVal-1)/2)];
        }
        if (!atkUnit || atkUnit.isDead) return 0;

        const k = atkUnit.getKey();
        const s = SKILL_DB[k];
        if (!s) return 0;
        
        let mult = 1.0;
        
        if (this.selectedSkillIdx === 0) {
            mult = 1.0;
        } else {
            const desc = this.selectedSkillIdx === 1 ? s.s1d : s.s2d;
            if (!desc) return 0;
            
            // ë¹„ê³µê²© ìŠ¤í‚¬ íƒ€ì… í•„í„°ë§
            const nonAtkTypes = ['HEAL', 'BUFF', 'ALLY', 'ALL_ALLY', 'SELF_BUFF', 'TARGET_BUFF'];
            if (s.type && nonAtkTypes.includes(s.type)) return 0;
            if (desc.includes('í') || desc.includes('ì‰´ë“œ') || desc.includes('ì •í™”')) return 0;
            
            const match = desc.match(/([\d.]+)ë°°/);
            if (match) mult = parseFloat(match[1]);
        }

        const baseAtk = atkUnit.getAtk();
        const aff = this.calc(atkUnit, target);
        return Math.floor(baseAtk * mult * aff.v);
    },
    calc: (a, d) => {
        let v = 1.0;
        let t = '';
        if (a.isNormal) {
            if (d.isNormal || d.isEnhanced) {
                v = 1.2;
                t = '(ê°•íƒ€)';
            }
        } else {
            const w = {
                'Fire': ['Metal', 'Tree'],
                'Water': ['Fire', 'Metal'],
                'Tree': ['Water', 'Earth'],
                'Metal': ['Tree', 'Earth'],
                'Earth': ['Fire', 'Water']
            };
            const ew = {
                'Light': ['Dark'],
                'Dark': ['Light']
            };
            // [Balance] ê¸°ì´ˆ 5ì†ì„± ì •ì˜
            const basicElements = ['Fire', 'Water', 'Tree', 'Metal', 'Earth'];

            if (d.isNormal) {
                // [ìˆ˜ì •] ìˆœìˆ˜ ê¸°ì´ˆ 5ì†ì„±(ë³´ì¡° ì†ì„±ì´ ì—†ëŠ” ê²½ìš°)ì—ê²Œë§Œ 1.2ë°° í”¼í•´
                // Light, Darkê°€ ì„ì¸ ë³µí•© ì†ì„±ì´ë‚˜, ìˆœìˆ˜ Light/Darkì—ê²ŒëŠ” 1.0ë°°
                if (basicElements.includes(a.base) && !a.extra) {
                    v = 1.2;
                    t = '(ì•½ì )';
                }
            } else {
                if (w[a.base]?.includes(d.base) || ew[a.base]?.includes(d.base)) {
                    v = 1.2;
                    t = '(ì•½ì )';
                } else if (w[d.base]?.includes(a.base)) {
                    v = 0.8;
                    t = '(ì €í•­)';
                }
            }
        }
        if (v === 1.2 && a.extra && d.extra && ((a.extra === 'Light' && d.extra === 'Dark') || (a.extra === 'Dark' && d.extra === 'Light'))) {
            v = 1.3;
            t = '(ì¹˜ëª…íƒ€!)';
        }
        return {
            v,
            t
        };
    }
};

window.onload = function() {
    Game.init();
};
</script>
</body>
</html>
