<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics v20.0 (Bug Fixed Edition)</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fef6fb;
            --panel-bg: #ffffff;
            --text-main: #6b5d5a;
            --accent: #ffb3d9;
            --accent-dark: #ff8fc7;
            --hp-high: #a8e6f7;
            --hp-low: #ffe4b5;
            --shield: #ddb3e6;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: 0 4px 15px rgba(255, 179, 217, 0.15), 0 2px 8px rgba(0, 0, 0, 0.08);
            --card-shadow: 0 6px 20px rgba(255, 179, 217, 0.2), 0 3px 10px rgba(0, 0, 0, 0.1);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffe0f0' opacity='0.4'%3EğŸ¾%3C/text%3E%3C/svg%3E");
            --gradient-soft: linear-gradient(135deg, #fff9fc 0%, #fef0f7 100%);
        }

        body {
            margin: 0;
            background: var(--gradient-soft);
            background-image: var(--paw-pattern);
            background-size: 80px 80px;
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
			touch-action: manipulation; /* [Fix] ì „ì²´ í„°ì¹˜ ë°˜ì‘ ì†ë„ í–¥ìƒ */
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: 0.3s;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
        .screen-shake {
            animation: jelly-bounce 0.5s both;
        }

        @keyframes jelly-bounce {
            0% { transform: scale(1, 1); }
            30% { transform: scale(1.15, 0.85); }
            40% { transform: scale(0.9, 1.1); }
            50% { transform: scale(1.05, 0.95); }
            65% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); }
        }

        /* ì„¸ë‡Œ ì¹´ë“œ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes mind-control-flip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        .mc-flip {
            animation: mind-control-flip 1s ease-in-out;
            transform-style: preserve-3d;
        }

        /* ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ */
        button, .unit, .hero-card, .side-btn { /* í„°ì¹˜ ëŒ€ìƒë“¤ ì¶”ê°€ */
            touch-action: manipulation; /* [Fix] ë”ë¸”íƒ­ ì¤Œ ë°©ì§€ (ë°˜ì‘ì†ë„ í–¥ìƒ) */
            font-family: var(--font-main);
            border-radius: 25px;
            border: none;
            background: linear-gradient(145deg, #ffffff 0%, #fffbfe 100%);
            color: #8b7d7a;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-radius: 20px;
            pointer-events: none;
        }

        button:active {
            transform: translateY(3px) scale(0.98);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .btn-restart {
            padding: 8px 12px;
            font-size: 14px;
            color: var(--accent);
        }

        .btn-restart:hover {
            background: #fff0f5;
        }

        .mute-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #eee;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: 0.2s;
        }

        .mute-btn:active {
            transform: scale(0.9);
        }

        .mute-btn.muted {
            background: #ffebee;
            color: #e57373;
            border-color: #ffcdd2;
        }

        /* ë ˆì´ì•„ì›ƒ */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden;
        }

        #selection-screen {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        #battle-screen {
            display: none;
            padding: 5px;
            height: 100%;
            justify-content: space-between;
        }

        /* ì˜ì›… ì¹´ë“œ (ì„ íƒ í™”ë©´) */
        .hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            overflow-y: auto;
            padding: 5px;
            flex: 1;
        }

        /* [ì„ íƒ í™”ë©´ìš© ì¹´ë“œ ìŠ¤íƒ€ì¼] ì „íˆ¬ ìœ ë‹›(.unit) ìŠ¤íƒ€ì¼ì„ ë² ì´ìŠ¤ë¡œ í•¨ */
        .hero-card {
            /* .unit í´ë˜ìŠ¤ì™€ í•¨ê»˜ ì‚¬ìš©ë  ê²ƒì´ë¯€ë¡œ, ë ˆì´ì•„ì›ƒ ê´€ë ¨ë§Œ ì¬ì •ì˜ */
            position: relative;
            cursor: pointer;
            transition: 0.2s;
            /* ê·¸ë¦¬ë“œ ì•ˆì—ì„œ ê½‰ ì°¨ê²Œ */
            width: 100% !important; 
            max-width: none !important;
            height: 200px !important; /* ë†’ì´ í†µì¼ */
            margin: 0;
            opacity: 0.9;
        }

        .hero-card:hover { transform: translateY(-3px); z-index: 10; opacity: 1; }
        .hero-card:active { transform: scale(0.98); }

        /* [ì„ íƒë¨ íš¨ê³¼] */
        .hero-card.selected {
            border: 3px solid #ffb3d9 !important; /* ë¶€ë“œëŸ¬ìš´ í•‘í¬ í…Œë‘ë¦¬ */
            box-shadow: 0 0 20px rgba(255, 179, 217, 0.6), inset 0 0 15px rgba(255, 179, 217, 0.2) !important;
            transform: translateY(-5px);
            z-index: 20;
            opacity: 1;
        }

        /* ì„ íƒ ì²´í¬ í‘œì‹œ (ìš°ì¸¡ ìƒë‹¨) */
        .hero-card.selected::after {
            content: 'âœ…';
            position: absolute;
            top: -10px; right: -10px;
            font-size: 24px;
            background: #fff;
            border-radius: 50%;
            width: 30px; height: 30px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 30;
        }

        /* ì „íˆ¬ ìœ ë‹› (Battle Unit) */
        .field-row {
            flex: 2; /* 1ì—ì„œ 2ë¡œ ë³€ê²½í•˜ì—¬ ìƒ/í•˜ë‹¨ ì¹´ë“œ ì˜ì—­ì„ ë” ë„“ê²Œ í™•ë³´ */
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            perspective: 1000px;
            padding: 5px 0;
            min-height: 0;
        }

        /* === [ì‹ ê·œ] ìœ ë‹› ì¹´ë“œ ë””ìì¸ === */
    .unit {
        width: 30vw;          /* ëª¨ë°”ì¼: í™”ë©´ ë„ˆë¹„ì˜ 30% */
        max-width: 160px;     /* PC/íƒœë¸”ë¦¿: ìµœëŒ€ 160pxê¹Œì§€ í™•ëŒ€ (ê¸°ì¡´ 110px) */
        height: 220px;        /* ë†’ì´ ëŒ€í­ í™•ëŒ€ (ê¸°ì¡´ 150px) */
        background: linear-gradient(145deg, #ffffff 0%, #fffbfe 100%);
        border-radius: 20px;
        position: relative;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-shadow: var(--card-shadow);
        border: 3px solid rgba(255, 255, 255, 0.8);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        user-select: none;
        cursor: pointer;
    }

    /* [í°íŠ¸/UI í¬ê¸° ë³´ì •] ì¹´ë“œê°€ ì»¤ì§„ ë§Œí¼ ê¸€ìì™€ ì•„ì´ì½˜ë„ í‚¤ì›€ */
    .unit .card-name { font-size: 14px; margin-bottom: 4px; }
    .unit .card-atk { font-size: 13px; padding: 3px 6px; }
    .unit .tiny-icon { width: 30px; height: 30px; font-size: 18px; }
    .unit .card-badge { top: 8px; left: 8px; gap: 4px; }
    .unit .status-bar { height: 8px; }

    /* ë°°ê²½ ì´ë¯¸ì§€ ì˜ì—­ */
    .unit-img-bg {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background-size: cover;
        background-position: center;
        z-index: 0;
        transition: 0.3s;
    }

    /* ì£½ì—ˆì„ ë•Œ í‘ë°± ì²˜ë¦¬ */
    .unit.dead .unit-img-bg {
        filter: grayscale(1) brightness(0.7);
    }

    /* ì •ë³´ ì˜¤ë²„ë ˆì´ (í•˜ë‹¨ ê²€ì€ ê·¸ë¼ë°ì´ì…˜) */
    .unit-info-overlay {
        position: relative;
        z-index: 2;
        background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.5) 70%, transparent 100%);
        padding: 6px 4px;
        width: 100%;
        box-sizing: border-box;
        color: #fff;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    /* ìƒë‹¨ ì†ì„± ì•„ì´ì½˜ */
    .card-badge {
        position: absolute;
        top: 4px; left: 4px;
        width: 24px; height: 24px;
        background: rgba(255,255,255,0.9);
        border-radius: 50%;
        display: flex; justify-content: center; align-items: center;
        font-size: 16px;
        z-index: 2;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        border: 1px solid #eee;
    }

    /* ìš°ì¸¡ ìƒë‹¨ ê³µê²©ë ¥ */
    .card-atk {
        position: absolute;
        top: 5px; right: 5px;
        background: rgba(0,0,0,0.6);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 10px;
        color: #fff;
        font-weight: bold;
        z-index: 2;
        border: 1px solid rgba(255,255,255,0.2);
    }

    /* ì´ë¦„ í…ìŠ¤íŠ¸ */
    .card-name {
        font-size: 11px;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 1px 2px #000;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 2px;
    }

    /* ìƒíƒœ íƒœê·¸ ì»¨í…Œì´ë„ˆ (ìœ„ì¹˜ ì¡°ì •) */
    .tag-container {
        position: absolute;
        bottom: 40px;
        left: 0; right: 0;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
    }

    /* ì„ íƒ/íƒ€ê²Ÿ ì´í™íŠ¸ */
    .unit.active-turn { border-color: var(--accent); transform: translateY(-5px); box-shadow: 0 0 15px var(--accent); }
    .unit.target-enemy { border-color: #ff5252; background: #ffebee; }
    /* contentì—ì„œ ì´ëª¨ì§€ ì‚­ì œ */
    .unit.target-enemy::after { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:40px; z-index:10; text-shadow:0 0 10px red; opacity:0.8; }

    /* ê¸°ì¡´ ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (ê°•ì œ ì ìš©) */

    /* ê¸°ì¡´ ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (ê°•ì œ ì ìš©) */
    .unit-info-overlay .status-bar { height: 6px; background: rgba(255,255,255,0.3); border: none; margin-top:2px; width: 100%; }

        /* ê°ì„± ìŠ¤íƒ€ì¼ (Super Hero) */
        .unit.super-hero {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.5) !important;
            animation: super-pulse 1.5s infinite alternate;
            z-index: 10;
        }

        @keyframes super-pulse {
            0% { box-shadow: 0 0 10px #ffb300; border-color: #ffb300; }
            100% { box-shadow: 0 0 25px #ff6f00; border-color: #ffca28; }
        }

        .unit.active-turn {
            border-color: var(--accent);
            transform: translateY(-12px) scale(1.05);
            z-index: 5;
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3);
        }

        .unit.target-enemy:hover {
            border-color: #ff7043;
            background: #ffebee;
            cursor: crosshair;
            transform: scale(1.05) rotate(2deg);
        }

        .unit.target-ally:hover {
            border-color: #66bb6a;
            background: #e8f5e9;
            cursor: pointer;
            transform: scale(1.05) rotate(-2deg);
        }

        .unit.target-aoe {
            border-color: #ff7043;
            background: #ffebee;
            animation: jelly-bounce 1s infinite;
            cursor: pointer;
        }

        .unit.dead {
            opacity: 0.6;
            filter: grayscale(1);
            pointer-events: none;
            border-color: #cfd8dc;
            transform: scale(0.9) rotate(5deg);
            box-shadow: none;
        }

        /* [ëª¨ì–‘ í†µì¼] ëª¨ë“  ì—­í• êµ° ë‘¥ê·¼ ì‚¬ê°í˜•ìœ¼ë¡œ ê³ ì • */
        .unit.role-tank, .unit.role-nuker, .unit.role-supp { border-radius: 12px !important; }

        /* [ì‹ ê·œ] ì™¼ìª½ ìƒë‹¨ ì†ì„± ì•„ì´ì½˜ ì»¨í…Œì´ë„ˆ */
        .card-badge {
            position: absolute;
            top: 5px; left: 5px;
            width: auto !important; height: auto !important;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            display: flex;
            flex-direction: row; /* ì˜†ìœ¼ë¡œ ë‚˜ë€íˆ */
            gap: 2px;
            z-index: 5;
        }
        /* ê°œë³„ ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ */
        .tiny-icon {
            width: 24px; height: 24px;
            background: rgba(255,255,255,0.95);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: 1px solid #ddd;
        }

        .attr-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-bottom: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            color: #fff;
            position: relative;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            border: 3px solid #fff;
            flex-shrink: 0;
        }

        .mini-attr-box {
            position: absolute;
            bottom: -2px;
            right: -2px;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 12px;
            border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mini-icon { font-size: 10px; line-height: 1; }

        .elec-badge {
            position: absolute;
            /* [ìˆ˜ì •] ì¹´ë“œ ì•ˆìª½ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°°ì¹˜í•˜ì—¬ ì˜ë¦¼ ë°©ì§€ */
            top: 30px;  
            right: 4px;
            background: #ffeb3b;
            color: #f57f17;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        /* [ì‹ ê·œ] ë‚˜ë¬´ ìŠ¤íƒ ë±ƒì§€ (Metal-Dark ì°¸ê³ ) */
        .tree-badge {
            position: absolute;
            /* [ìˆ˜ì •] ì¹´ë“œ ì•ˆìª½ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°°ì¹˜í•˜ì—¬ ì˜ë¦¼ ë°©ì§€ */
            top: 30px; 
            right: 4px;
            background: #66bb6a; /* ì´ˆë¡ìƒ‰ */
            color: #fff;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

		/* [ì‹ ê·œ] í‘¸ë¥¸ë¶ˆ í­ì£¼ ìŠ¤íƒ ë±ƒì§€ */
        .fire-badge {
            position: absolute;
            top: 30px; 
            right: 4px;
            background: #ff5252; /* ê°•ë ¬í•œ ë¶‰ì€ìƒ‰ */
            color: #fff;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        .status-bar {
            width: 85%;
            height: 10px;
            background: #eceff1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #a8e6f7 0%, #7dd3ed 100%);
            border-radius: 10px;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.5);
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
        }

        .shield-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #ddb3e6 0%, #d4a0dd 100%);
            opacity: 0.85;
            border-radius: 10px;
            transition: width 0.3s;
            box-shadow: inset 0 1px 3px rgba(255, 255, 255, 0.5);
        }

        .control-panel {
            flex: 0 0 auto;
            max-height: 45vh;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.98) 0%, rgba(254, 251, 254, 0.95) 100%);
            border-radius: 30px 30px 0 0;
            box-shadow: 0 -8px 30px rgba(255, 179, 217, 0.2), 0 -4px 15px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            border-top: 4px solid var(--accent);
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        /* [ë ˆì´ì•„ì›ƒ ì••ì¶•] í—¤ë”ì— íƒ€ì„ë¼ì¸ í†µí•© */
        .cp-header {
            padding: 5px 10px;
            background: #fff8e1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px dashed #ffe082;
            font-size: 13px;
            height: 40px; /* ë†’ì´ ê³ ì • */
            flex-shrink: 0;
        }
        
        /* ê¸°ì¡´ íƒ€ì„ë¼ì¸ ì»¨í…Œì´ë„ˆ ì‚­ì œ (í—¤ë”ë¡œ ì´ë™ë¨) */
        .timeline-container { display: none; } 

        /* [ì‹ ê·œ] ì™¼ìª½ ì‚¬ì´ë“œ í”Œë¡œíŒ… ì»¨íŠ¸ë¡¤ */
        /* [ì‚¬ì´ë“œ ë©”ë‰´ ìŠ¤íƒ€ì¼] */
.side-controls { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 9999; }
.side-btn { width: 44px; height: 44px; border-radius: 50%; background: #fff; border: 2px solid #ddd; font-size: 22px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.2); cursor: pointer; transition: all 0.2s; position: relative; z-index: 10; }
.side-btn:active { transform: scale(0.9); }
.side-btn:hover { border-color: #ff80ab; transform: scale(1.1); }
.main-menu-btn { background: #5d4037; color: #fff; border-color: #5d4037; }

/* ìˆ¨ê²¨ì§„ í´ë” */
.dock-folder { display: none; flex-direction: column; gap: 8px; padding-top: 5px; }
.dock-folder.show { display: flex; animation: slide-down 0.2s forwards; }
@keyframes slide-down { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

/* [ìˆ˜ì •] ê°•ì œ ìœ„ì¹˜ ê³ ì •(top:0) ì œê±° ë° ë””ìì¸ ì •ì˜ */
.settings-modal, .save-menu {
    position: absolute !important; /* ì•„ì´ì½˜ ê·¼ì²˜ì— ë¶™ë„ë¡ ì„¤ì • */
    z-index: 10000 !important;     /* ì œì¼ ìœ„ì— í‘œì‹œ (ë°°ì†/ìë™ë²„íŠ¼ë³´ë‹¤ ìœ„) */

    background: rgba(255, 255, 255, 0.95);
    border: 2px solid var(--text-main);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    border-radius: 20px;
    width: 200px;
    padding: 15px;
    display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
    flex-direction: column;
    gap: 10px;

    /* top, left ë“± ìœ„ì¹˜ ê°’ì€ HTML íƒœê·¸ì—ì„œ ì§ì ‘ ì§€ì •í•¨ */
}
        .side-btn:active { transform: scale(0.9); }
        
        /* ì €ì¥/ë¡œë“œ íŒì—… ë©”ë‰´ */
        .save-menu {
            display: none;
            position: absolute; left: 50px; top: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px; padding: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 2px solid #ffcc80;
            flex-direction: column; gap: 5px;
            width: 120px;
            backdrop-filter: blur(5px);
        }
        .save-opt {
            padding: 8px; border: 1px solid #ddd; border-radius: 10px;
            background: #fff; font-size: 12px; cursor: pointer; text-align: center; color: #555; font-weight: bold;
        }
        .save-opt:hover { background: #fff3e0; color: #f57c00; }

        .timeline-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
            margin-right: 5px;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); }
        }

        .tl-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            border: 2px solid #eee;
            position: relative;
            flex-shrink: 0;
            transition: 0.3s;
            background: #fff;
            box-shadow: 0 2px 0 #ddd;
        }

        .tl-node.curr {
            border-color: var(--accent);
            transform: scale(1.3);
            z-index: 2;
            border-width: 3px;
            animation: active-pulse 1.5s infinite;
        }

        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container {
            flex: 1;
            padding: 5px 10px; /* íŒ¨ë”© ì¶•ì†Œ */
            overflow-y: auto;
            font-size: 12px;
            border-bottom: 2px solid #f0f0f0;
            background: #fff;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            min-height: 30px;  /* ìµœì†Œ ë†’ì´ ì¶•ì†Œ */
            max-height: 60px;  /* ìµœëŒ€ ë†’ì´ ëŒ€í­ ì¶•ì†Œ (120 -> 60) */
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            background: linear-gradient(145deg, #ffffff 0%, #fffbfe 100%);
            border-radius: 10px;
            word-break: keep-all;
            border-left: 3px solid var(--accent);
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 5px rgba(255, 179, 217, 0.1);
        }

        .log-ally { color: #29b6f6; font-weight: bold; }
        .log-enemy { color: #ff7043; font-weight: bold; }
        .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }

        /* [UI ê°œì„ ] ë†’ì´ ìœ ë™ì  ë³€ê²½ (ì˜ë¦¼ ë°©ì§€) */
        .btn-group {
            display: flex;
            min-height: 60px; /* 80px -> 60pxë¡œ ì¶•ì†Œ */
            height: auto;
            flex-shrink: 0;
            padding: 4px;     /* íŒ¨ë”© ì•½ê°„ ì¶•ì†Œ */
            gap: 4px;
            background: #fff5f8;
        }

        .skill-btn {
            flex: 1;
            border: none;
            background: linear-gradient(145deg, #ffffff 0%, #fffbfe 100%);
            border-radius: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 6px;
            box-shadow: 0 3px 12px rgba(255, 179, 217, 0.15), 0 2px 6px rgba(0, 0, 0, 0.08);
            border: 2px solid rgba(255, 179, 217, 0.2);
            transform: translateY(0);
        }

        .skill-btn::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            border-radius: 15px;
            pointer-events: none;
        }

        .skill-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(255, 179, 217, 0.25), 0 3px 8px rgba(0, 0, 0, 0.12);
        }
        .skill-btn:active:not(:disabled) { 
            transform: translateY(1px); 
            box-shadow: inset 0 2px 8px rgba(255, 179, 217, 0.2);
        }
        .skill-btn.selected { 
            background: linear-gradient(145deg, #ffe8f5 0%, #ffd9ed 100%); 
            color: #d946a6; 
            box-shadow: inset 0 0 0 3px var(--accent), 0 4px 15px rgba(255, 179, 217, 0.3);
            border-color: var(--accent);
        }
        .skill-btn:disabled { 
            background: linear-gradient(145deg, #f9f9f9 0%, #f0f0f0 100%); 
            color: #c4c4c4; 
            cursor: not-allowed; 
            box-shadow: none; 
            transform: none; 
            border-color: #e8e8e8;
        }
        
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }

        .passive-panel {
            background: #e0f2f1;
            padding: 2px 8px;  /* íŒ¨ë”© ì¶•ì†Œ */
            font-size: 11px;
            color: #00695c;
            display: flex;
            align-items: center;
            border-radius: 8px;
            margin: 2px 5px;   /* ì—¬ë°± ëŒ€í­ ì¶•ì†Œ */
            border: 1px solid #b2dfdb;
            flex-shrink: 0;
            height: 24px;      /* ë†’ì´ ê°•ì œ ê³ ì • */
        }

        .passive-icon { margin-right: 5px; font-size: 14px; }

        .btn-start {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 20px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 5px 0 #c2185b, 0 10px 15px rgba(0, 0, 0, 0.15);
            transition: 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(5px); box-shadow: 0 0 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-rnd {
            background: #b39ddb;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            box-shadow: 0 4px 0 #7e57c2;
        }

        .btn-rnd:active { transform: translateY(4px); box-shadow: none; }

        .tag-container {
            position: absolute;
            top: auto;          /* ìƒë‹¨ ê³ ì • í•´ì œ */
            bottom: 55px;       /* í•˜ë‹¨ ì´ë¦„í‘œ ë°”ë¡œ ìœ„ë¡œ ìœ„ì¹˜ ë³€ê²½ */
            left: 5px;
            right: 5px;
            display: flex;
            justify-content: center;
            gap: 3px;
            flex-wrap: wrap-reverse; /* íƒœê·¸ê°€ ìŒ“ì¼ ë•Œ ìœ„ìª½ìœ¼ë¡œ ìŒ“ì´ë„ë¡ ì„¤ì • */
            z-index: 10;
            pointer-events: none;
            /* max-height ì œí•œì„ í’€ì–´ ì—¬ëŸ¬ ê°œê°€ ê±¸ë ¤ë„ ë³´ì´ê²Œ í•¨ */
        }

        .tag {
            padding: 2px 4px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 1px;
            white-space: nowrap;
            height: 14px;
            display: flex;
            align-items: center;
        }

        .tag.poison { background: #d4a5d7; color: #fff; }
        .tag.stun { background: #fff9c4; color: #6d4c41; }
        .tag.freeze { background: #b3e5fc; color: #fff; }
        .tag.silence { background: #b0bec5; color: #fff; }
        .tag.evade { background: #90caf9; color: #fff; }
        .tag.burn { background: #ffb3a7; color: #fff; }
        .tag.banish { background: #90a4ae; color: #fff; }
        .tag.bind { background: #a5d6a7; color: #2e7d32; }
        .tag.trap { background: #f0f4c3; color: #6d4c41; }
        .tag.atkdown { background: #9fa8da; color: #fff; }
        .tag.growth { background: #c5e1a5; color: #33691e; }
        .tag.blind { background: #e0e0e0; color: #6d4c41; }
        .tag.immunity { background: #fff; color: #6d4c41; border: 2px solid #ffb3d9; }
        .tag.healdown { background: #bcaaa4; color: #fff; }
        /* [ì‹ ê·œ] ì¹˜ìœ  ê°ì†Œ ìˆ˜ì¹˜ë³„ ìƒ‰ìƒ êµ¬ë¶„ */
        .tag.heal-20 { background: #ab47bc; color: #fff; } /* ë³´ë¼ìƒ‰ (ë…) */
        .tag.heal-50 { background: #fb8c00; color: #fff; } /* ì£¼í™©ìƒ‰ (ëª¨ë˜) */
        .tag.heal-critical { background: #c62828; color: #fff; font-weight:bold; animation: jelly-bounce 2s infinite; } /* ê³ ìœ„í—˜ */
        .tag.atkup { background: #ef5350; color: #fff; }
        .tag.taunt {
            background: #212121;
            color: #ff5252;
            border: 1px solid #ff1744;
            box-shadow: 0 0 4px rgba(255, 23, 68, 0.6);
            font-weight: 900;
        }
        .tag.karma {
            background: #512da8;
            color: #fff;
            border: 1px solid #d1c4e9;
            animation: jelly-bounce 2s infinite;
        }
        /* ì„ ê³µë°©ì–´ ë©´ì—­ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.start-immunity { background: #00bcd4; color: #fff; border: 1px solid #80deea; box-shadow: 0 0 5px #00e5ff; }
        /* [ì‹ ê·œ] ì„¸ë‡Œ ê´€ë ¨ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.mc-wait { background: #5e35b1; color: #fff; border: 1px solid #b39ddb; animation: jelly-bounce 2s infinite; }
        .tag.mc-ready { background: #d500f9; color: #fff; border: 2px solid #ea80fc; box-shadow: 0 0 10px #d500f9; font-weight:900; }

        .bg-Fire { background: linear-gradient(135deg, #ffcccb, #ffb3ba); }
        .bg-Water { background: linear-gradient(135deg, #b3e5fc, #81d4fa); }
        .bg-Tree { background: linear-gradient(135deg, #c8e6c9, #a5d6a7); color: #2e7d32; }
        .bg-Metal { background: linear-gradient(135deg, #f5f5f5, #cfd8dc); }
        .bg-Earth { background: linear-gradient(135deg, #ffe4b3, #ffd9a3); }
        .bg-Light { background: linear-gradient(135deg, #fff9c4, #fff59d); color: #6d4c41; }
        .bg-Dark { background: linear-gradient(135deg, #e1bee7, #ce93d8); }
        .bg-Normal { background: linear-gradient(135deg, #ffffff, #f5f5f5); color: #6d4c41; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fffde7, #fff9c4); border: 3px solid #ffd54f; color: #6d4c41; box-shadow: 0 0 20px rgba(255, 245, 157, 0.6); }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #f3e5f5, #e1bee7); border: 3px solid #ba68c8; box-shadow: 0 0 20px rgba(225, 190, 231, 0.6); }

        /* [ë°ë¯¸ì§€ í°íŠ¸ ì„¸ë¶„í™”] */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 28px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        .ft-dmg { color: #ff7043; }
        .ft-crit { color: #ffa726; font-size: 36px; text-shadow: 2px 2px 0 #d84315; }
        .ft-heal { color: #26a69a; animation: floatUpSlow 1.2s ease-out forwards; }
        .ft-miss { color: #b0bec5; font-size: 20px; }
        .ft-weak { color: #d32f2f; font-size: 32px; font-weight: 900; animation: shake-dmg 0.4s ease-in-out; }
        .ft-resist { color: #78909c; font-size: 18px; opacity: 0.8; }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        @keyframes floatUpSlow {
            0% { transform: translate(-50%, 0); opacity: 0; }
            50% { transform: translate(-50%, -40px); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        @keyframes shake-dmg {
            0%, 100% { transform: translate(-50%, -20px); }
            25% { transform: translate(-55%, -20px); }
            75% { transform: translate(-45%, -20px); }
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 248, 225, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 35px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3);
            overflow-y: auto;
            max-height: 80vh;
            border: 5px solid #ffcc80;
            position: relative;
        }

        /* [ì»·ì‹ ] ìŠ¤íƒ€ì¼ */
        #cut-in-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cut-in-img {
            font-size: 120px;
            animation: cut-in-zoom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .cut-in-text {
            font-size: 40px;
            color: #fff;
            font-weight: 900;
            margin-top: 20px;
            animation: slide-up 0.5s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes cut-in-zoom {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes slide-up {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* [íˆ´íŒ] ìŠ¤íƒ€ì¼ */
        #tooltip-view {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 150;
            max-width: 200px;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
            text-align: left;
        }

        .tooltip-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 45vh; }
            .btn-group { min-height: 72px; height: auto; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 10px; display: block; line-height: 1.2; }
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
/* [ì‹ ê·œ] ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° & ê°ì •í‘œí˜„ */
        .hp-preview {
            position: absolute;
            top: 0; bottom: 0;
            background: rgba(255, 23, 68, 0.8); /* ë¶‰ì€ìƒ‰ ë°ë¯¸ì§€ ê²½ê³  */
            z-index: 5; pointer-events: none;
            transition: all 0.1s;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
            animation: blink-preview 0.5s infinite alternate;
        }
        @keyframes blink-preview { from { opacity: 0.4; } to { opacity: 0.9; } }
        .emote-bubble {
            position: absolute; top: -45px; left: 50%; transform: translateX(-50%);
            background: #fff; border: 3px solid #333; border-radius: 20px;
            padding: 8px 12px; font-size: 24px; z-index: 50;
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            white-space: nowrap; pointer-events: none;
        }
        @keyframes pop-in { from { transform: translateX(-50%) scale(0); } to { transform: translateX(-50%) scale(1); } }
        
        .emote-menu {
            position: absolute; display: flex; gap: 8px; 
            background: rgba(255,255,255,0.95); padding: 8px; 
            border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 100; border: 2px solid #eee;
            animation: fade-up 0.2s;
        }
        @keyframes fade-up { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
        .emote-btn { 
            font-size: 22px; cursor: pointer; transition: 0.2s; 
            width: 36px; height: 36px; border-radius: 50%; 
            display:flex; align-items:center; justify-content:center;
        }
        .emote-btn:hover { transform: scale(1.2); background: #f0f0f0; }
        /* [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (ì‹œê°„ ì •ì§€ íš¨ê³¼) */
        body.hit-stopped .unit,
        body.hit-stopped .float-text {
            animation-play-state: paused !important;
            transition: none !important;
        }
       /* [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë° íƒ€ê²© ì´í™íŠ¸ */
        .projectile {
            position: absolute;
            font-size: 24px;
            z-index: 150;
            pointer-events: none;
            transition: all 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        
        /* [Phase 1] ì†ì„±ë³„ íˆ¬ì‚¬ì²´ ê¶¤ì  ì• ë‹ˆë©”ì´ì…˜ */
        .projectile.trajectory-arc {
            /* ë¶ˆ ê³„ì—´: í¬ë¬¼ì„  (ìœ„ë¡œ ì‚´ì§ íŠ€ì–´ì˜¬ëë‹¤ ë–¨ì–´ì§) */
            transition: all 0.3s cubic-bezier(0.5, -0.3, 0.5, 1.3);
        }
        
        .projectile.trajectory-wave {
            /* ë¬¼ ê³„ì—´: ë¬¼ê²° */
            animation: wave-motion 0.3s ease-in-out;
        }
        @keyframes wave-motion {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        .projectile.trajectory-spin {
            /* ë‚˜ë¬´ ê³„ì—´: íšŒì „ */
            animation: spin-motion 0.3s linear;
        }
        @keyframes spin-motion {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .projectile.trajectory-straight {
            /* ì‡ /ë…¸ë§ ê³„ì—´: ë¹ ë¥¸ ì§ì„  */
            transition: all 0.2s linear;
        }
        
        /* [Phase 1] ì§€ë©´ ì´í™íŠ¸ ë ˆì´ì–´ */
        .ground-effect-layer {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            height: 30px;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }
        
        /* [Phase 1] ì§€ë©´ ê· ì—´ ì´í™íŠ¸ */
        .ground-crack {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #8B4513, transparent);
            animation: crack-appear 0.3s ease-out forwards;
            opacity: 0;
        }
        @keyframes crack-appear {
            0% { width: 0%; opacity: 0; }
            50% { opacity: 0.8; }
            100% { width: 80%; opacity: 0; }
        }
        
        /* [ê°œì„ ] ì†ì„±ë³„ ì§€ë©´/ë°°ê²½ ì´í™íŠ¸ */
        /* í™”ì—¼ íŒŒí‹°í´ */
        .fire-particle {
            position: absolute;
            font-size: 20px;
            animation: fire-rise 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes fire-rise {
            0% { transform: translateY(0) scale(0.5); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }
        
        /* ë¬¼ë³´ë¼ ì´í™íŠ¸ */
        .water-splash {
            position: absolute;
            font-size: 18px;
            animation: splash-out 0.35s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes splash-out {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0.5); opacity: 0; }
        }
        
        /* ì–¼ìŒ íš¨ê³¼ */
        .ice-frame {
            position: absolute;
            inset: -3px;
            border: 3px solid rgba(135, 206, 250, 0.8);
            border-radius: 20px;
            animation: ice-freeze 0.4s ease-out forwards;
            pointer-events: none;
            z-index: 15;
            box-shadow: 0 0 15px rgba(135, 206, 250, 0.6), inset 0 0 15px rgba(255, 255, 255, 0.3);
        }
        @keyframes ice-freeze {
            0% { opacity: 0; transform: scale(1.2); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1); }
        }
        
        /* ì„œë¦¬ íŒŒí‹°í´ */
        .frost-particle {
            position: absolute;
            font-size: 12px;
            color: #E0F7FA;
            animation: frost-float 0.5s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes frost-float {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) rotate(360deg); opacity: 0; }
        }
        
        /* ì „ê¸° ìŠ¤íŒŒí¬ */
        .electric-spark {
            position: absolute;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, #FFEB3B, transparent);
            animation: spark-flash 0.25s ease-out forwards;
            pointer-events: none;
            z-index: 10;
            transform-origin: top center;
        }
        @keyframes spark-flash {
            0% { height: 0; opacity: 1; }
            50% { height: 25px; opacity: 1; }
            100% { height: 20px; opacity: 0; }
        }
        
        /* ëŒ íŒŒí¸ */
        .rock-debris {
            position: absolute;
            font-size: 16px;
            animation: debris-fly 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            pointer-events: none;
            z-index: 10;
        }
        @keyframes debris-fly {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) rotate(720deg); opacity: 0; }
        }
        
        /* ì–´ë‘  ì†Œìš©ëŒì´ */
        .dark-vortex {
            position: absolute;
            inset: -5px;
            border-radius: 20px;
            background: radial-gradient(circle, transparent 30%, rgba(75, 0, 130, 0.3) 70%, rgba(0, 0, 0, 0.5));
            animation: vortex-spin 0.5s ease-out forwards;
            pointer-events: none;
            z-index: 14;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.6);
        }
        @keyframes vortex-spin {
            0% { opacity: 0; transform: rotate(0deg) scale(0.8); }
            50% { opacity: 1; transform: rotate(180deg) scale(1); }
            100% { opacity: 0; transform: rotate(360deg) scale(1.1); }
        }
        
        /* ì„¬ê´‘ í­ë°œ (Light) */
        .light-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, transparent 70%);
            animation: flash-expand 0.3s ease-out forwards;
            pointer-events: none;
            z-index: 13;
        }
        @keyframes flash-expand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        
        /* ì‹­ì ë°˜ì§ì„ */
        .cross-shine {
            position: absolute;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, white, transparent);
            animation: shine-fade 0.3s ease-out forwards;
            pointer-events: none;
            z-index: 14;
            left: 50%;
            transform: translateX(-50%);
        }
        @keyframes shine-fade {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* [Phase 1] ì†ì„±ë³„ ì„íŒ©íŠ¸ ì´í™íŠ¸ */
        .impact-effect {
            position: absolute;
            font-size: 40px;
            z-index: 151;
            pointer-events: none;
            animation: impact-pop 0.3s ease-out forwards;
        }
        @keyframes impact-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
        
        /* [ê°œì„ ] ì¹´ë“œ í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ - íƒ€ê²©ê° ê°•í™” */
        @keyframes card-shake-light {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-2px, 0) rotate(0deg); }
            75% { transform: translate(2px, 0) rotate(0deg); }
        }
        @keyframes card-shake-medium {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            20% { transform: translate(-5px, -2px) rotate(-1deg); }
            40% { transform: translate(5px, 2px) rotate(1deg); }
            60% { transform: translate(-5px, 2px) rotate(-1deg); }
            80% { transform: translate(5px, -2px) rotate(1deg); }
        }
        @keyframes card-shake-heavy {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            15% { transform: translate(-8px, -3px) rotate(-2deg); }
            30% { transform: translate(8px, 3px) rotate(2deg); }
            45% { transform: translate(-8px, 3px) rotate(-2deg); }
            60% { transform: translate(8px, -3px) rotate(2deg); }
            75% { transform: translate(-4px, 0) rotate(-1deg); }
        }
        
        /* í”ë“¤ë¦¼ ì ìš© í´ë˜ìŠ¤ */
        .unit.shake-light { animation: card-shake-light 0.1s ease-out; }
        .unit.shake-medium { animation: card-shake-medium 0.15s ease-out; }
        .unit.shake-heavy { animation: card-shake-heavy 0.2s ease-out; }
        
        /* ì†ì„±ë³„ ì„íŒ©íŠ¸ ìƒ‰ìƒ */
        .impact-fire { 
            animation: impact-burst 0.4s ease-out forwards;
            filter: drop-shadow(0 0 10px #ff6b00);
        }
        @keyframes impact-burst {
            0% { transform: translate(-50%, -50%) scale(0.3) rotate(0deg); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.8) rotate(360deg); opacity: 0; }
        }
        
        .impact-water { 
            filter: drop-shadow(0 0 8px #00bcd4);
        }
        
        .impact-tree { 
            filter: drop-shadow(0 0 8px #4caf50);
        }
        
        .impact-metal { 
            animation: impact-flash 0.25s ease-out forwards;
            filter: drop-shadow(0 0 10px #fff);
        }
        @keyframes impact-flash {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; filter: brightness(3); }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; filter: brightness(1); }
        }
/* [ì‹ ê·œ] ì˜¤ë””ì˜¤ ì„¤ì • UI */
        .settings-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .settings-btn:active { transform: scale(0.9); }

        .settings-modal {
            display: none; position: absolute; top: 60px; right: 15px;
            width: 240px; background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 15px; z-index: 110;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); border: 2px solid #ffcc80;
            backdrop-filter: blur(5px); flex-direction: column; gap: 10px;
        }
        .set-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #5d4037; font-weight: bold; }
        .vol-slider { flex: 1; margin-left: 10px; accent-color: #ff80ab; height: 6px; }
        
        .bgm-select { display: flex; gap: 5px; margin-top: 5px; }
        .bgm-opt { 
            flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 10px; 
            background: #fff; font-size: 11px; cursor: pointer; text-align: center; color: #888;
        }
        .bgm-opt.active { background: #fff8e1; border-color: #ffb74d; color: #f57c00; font-weight: bold; }
        
        .toggle-btn {
            width: 40px; height: 20px; background: #ccc; border-radius: 20px;
            position: relative; cursor: pointer; transition: 0.3s;
        }
        .toggle-btn.on { background: #66bb6a; }
        .toggle-btn::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            transition: 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-btn.on::after { left: 22px; }
        /* =========================================
   [ìƒˆë¡œìš´ í„´ í™œì„±í™” ë””ìì¸ ì ìš©]
   ê¸°ì¡´ì˜ íŠ€ì–´ì˜¤ë¦„ ë° ë‘êº¼ìš´ í…Œë‘ë¦¬ë¥¼ ì œê±°í•˜ê³ ,
   ë ˆì´ì•„ì›ƒì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ë¹›(Glow) íš¨ê³¼ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.
========================================= */

/* 1. í™œì„±í™”ëœ ì¹´ë“œ ìŠ¤íƒ€ì¼ ì¬ì •ì˜ */
.unit.active-turn {
    /* [ì¬ìˆ˜ì •] ì´ì›ƒ ì¹´ë“œë¥¼ ê°€ë¦¬ì§€ ì•Šë„ë¡ í™•ëŒ€/íšŒì „ ì œê±° */
    /* ìœ„ë¡œë§Œ ì‚´ì§(-5px) ë– ì˜¤ë¥´ê²Œ í•˜ì—¬ "ë‚˜ ì—¬ê¸° ìˆì–´" ì‹ í˜¸ë§Œ ì¤ë‹ˆë‹¤ */
    transform: translateY(-5px) !important; 
    
    /* ëŒ€ì‹  í…Œë‘ë¦¬ë¥¼ ì•„ì£¼ ì§„í•˜ê³  ë‘ê»ê²Œ(3px -> 4px) ë³€ê²½í•˜ì—¬ ì‹œì¸ì„± í™•ë³´ */
    border: 4px solid #ff4081 !important; 
    z-index: 10 !important; /* í…Œë‘ë¦¬ê°€ ì˜ ë³´ì´ë„ë¡ ë ˆì´ì–´ ìˆœì„œ ë³´ì • */

    /* ë‚´ë¶€ê°€ í™˜í•˜ê²Œ ë¹„ì¹˜ëŠ” í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼ ì¶”ê°€ */
    box-shadow: 0 10px 20px rgba(255, 64, 129, 0.4), inset 0 0 15px rgba(255, 255, 255, 0.8) !important;
    
    transition: transform 0.2s ease-out, border 0.2s, box-shadow 0.2s;
    /* ì‹¬ì¥ ë°•ë™ì²˜ëŸ¼ ê¹œë¹¡ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ ìœ ì§€ */
    animation: active-glow-pulse 1.5s infinite ease-in-out;
}

/* 2. ë¹›ì´ ìˆ¨ì‰¬ë“¯ ì¼ë ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
@keyframes active-glow-pulse {
    0%, 100% {
        /* ë¹›ì´ ì€ì€í•  ë•Œ */
        box-shadow: 
            0 0 10px 2px var(--accent),          /* ì™¸ë¶€ í›„ê´‘ */
            inset 0 0 5px rgba(255, 255, 255, 0.3); /* ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸ */
    }
    50% {
        /* ë¹›ì´ ê°€ì¥ ê°•í•  ë•Œ */
        box-shadow: 
            0 0 20px 5px var(--accent),          /* ë” ë„“ê³  ì§„í•œ ì™¸ë¶€ í›„ê´‘ */
            inset 0 0 15px rgba(255, 255, 255, 0.5); /* ë” ê°•í•œ ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸ */
    }
}

/* 3. í”Œë ˆì´ì–´ ì¹´ë“œ ì¶”ê°€ ë³´ì • (í˜¹ì‹œ ëª¨ë¥¼ ë¯¸ì„¸ ê²¹ì¹¨ ë°©ì§€) */
/* í”Œë ˆì´ì–´ ì¹´ë“œëŠ” ì»¨íŠ¸ë¡¤ íŒ¨ë„ê³¼ ê°€ê¹Œìš°ë¯€ë¡œ í•˜ë‹¨ ë§ˆì§„ì„ ì‚´ì§ í™•ë³´ */
#player-row .unit.active-turn {
    margin-bottom: 4px; 
    transition: margin-bottom 0.3s ease;
}
/* ë¹„í™œì„± ìƒíƒœì¼ ë•Œ ìì—°ìŠ¤ëŸ½ê²Œ ë³µê·€ */
#player-row .unit:not(.active-turn) {
     margin-bottom: 0;
     transition: margin-bottom 0.3s ease;
}
/* í•˜ë‹¨ ë©”ë‰´ìš© ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜ */
@keyframes slide-up-menu { 
    from { opacity: 0; transform: translateY(20px); } 
    to { opacity: 1; transform: translateY(0); } 
}
.dock-folder.show { 
    animation: slide-up-menu 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards !important; 
}
/* [ì¤‘ìš”] ë©”ë‰´ê°€ íŒ¨ë„ ë°–ìœ¼ë¡œ íŠ€ì–´ë‚˜ì™€ë„ ì˜ë¦¬ì§€ ì•Šê²Œ í•¨ */
.control-panel {
    overflow: visible !important;
}
/* [ê¸´ê¸‰ ìˆ˜ì •] í•˜ë‹¨ íŒ¨ë„ ë° ë©”ë‰´ ê³„ì¸µ ìµœìƒìœ„ë¡œ ê²©ìƒ */
.control-panel {
    z-index: 5000 !important; /* ìœ ë‹›(100), ì´í™íŠ¸(999)ë³´ë‹¤ ë¬´ì¡°ê±´ ë†’ê²Œ */
    overflow: visible !important; /* ë©”ë‰´ê°€ íŒ¨ë„ ë°–ìœ¼ë¡œ íŠ€ì–´ë‚˜ê°€ë„ ë³´ì´ê²Œ */
}

/* ë©”ë‰´ ì•ˆì˜ íŒì—…ë“¤(ì €ì¥/ì„¤ì •) ìœ„ì¹˜ ë° í´ë¦­ ë³´ì • */
.dock-folder {
    z-index: 6000 !important; /* íŒ¨ë„ë³´ë‹¤ ë” ë†’ê²Œ */
    pointer-events: auto !important; /* í´ë¦­ ê°•ì œ í—ˆìš© */
}

/* [ë³µêµ¬] ì„¤ì •/ì €ì¥ íŒì—…ì°½: absoluteë¡œ ë³€ê²½í•˜ì—¬ ì•„ì´ì½˜ ê¸°ì¤€ìœ¼ë¡œ ë°°ì¹˜ */
.settings-modal, .save-menu {
    position: absolute !important; 
    /* top, left ë“±ì€ HTML íƒœê·¸ì—ì„œ ê°œë³„ ì§€ì •í•˜ê±°ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš© */
    transform: none !important; 
    z-index: 9999 !important;

    background: rgba(255, 255, 255, 0.95);
    border: 2px solid var(--text-main);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    border-radius: 20px;
    width: 200px;
    padding: 15px;
    display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
    flex-direction: column;
    gap: 10px;
}
/* [ì‹ ê·œ] ì‹¤ë“œ ê²Œì´ì§€ ë° ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ë³´ì • */
.status-bar {
    position: relative; /* ì‹¤ë“œ ê²¹ì¹˜ê¸°ë¥¼ ìœ„í•œ ê¸°ì¤€ì  */
    background: #444; /* ë¹ˆ ê³µê°„ ë°°ê²½ìƒ‰ */
    overflow: hidden; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ ìœ ì§€ */
}

.hp-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    z-index: 1; /* ì²´ë ¥ì€ 1ì¸µ */
    transition: width 0.3s ease;
}

.shield-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    background-color: var(--shield); /* ë³´ë¼ìƒ‰ (#ce93d8) */
    opacity: 0.75; /* ì‚´ì§ íˆ¬ëª…í•˜ê²Œ í•´ì„œ ì²´ë ¥ê³¼ ê²¹ì³ ë³´ì´ê²Œ */
    z-index: 2; /* ì‹¤ë“œëŠ” ì²´ë ¥ ìœ„ì— 2ì¸µìœ¼ë¡œ í‘œì‹œ */
    pointer-events: none;
    transition: width 0.3s ease;
    box-shadow: 0 0 5px rgba(206, 147, 216, 0.5); /* ë¹›ë‚˜ëŠ” íš¨ê³¼ */
}
/* =========================================
   [ì—…ê·¸ë ˆì´ë“œ] ìŠ¤í‚¬ ì´í™íŠ¸ (VFX) ì‹œìŠ¤í…œ V2
   ========================================= */
.vfx-layer {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10000; /* ìœ ë‹›ë³´ë‹¤ ë¬´ì¡°ê±´ ìœ„ (10000) */
    font-size: 80px; /* í¬ê¸° 2ë°° í™•ëŒ€ (40px -> 80px) */
    display: flex;
    justify-content: center;
    align-items: center;
    white-space: nowrap;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.5)); /* ê·¸ë¦¼ì ì¶”ê°€ë¡œ ê°€ì‹œì„± í™•ë³´ */
}

/* 1. íƒ€ê²©/í­ë°œ: í™”ë©´ì„ ëš«ê³  ë‚˜ì˜¬ ë“¯í•œ í™•ëŒ€ */
@keyframes vfx-boom {
    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; filter: brightness(2.0); } /* ë°ê²Œ ë¹›ë‚¨ */
    100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; }
}

/* 2. ë² ê¸°: ë¹ ë¥´ê³  ê°•ë ¬í•œ ê¶¤ì  */
@keyframes vfx-slash {
    0% { transform: translate(-50%, -50%) scale(0.5) rotate(-45deg); opacity: 0; }
    20% { transform: translate(-50%, -50%) scale(1.2) rotate(0deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5) rotate(45deg); opacity: 0; }
}

/* 3. íšŒë³µ: ì²œì²œíˆ ìœ„ë¡œ ì˜¬ë¼ê°€ë©° ë°˜ì§ì„ */
@keyframes vfx-heal {
    0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
    50% { transform: translate(-50%, -50px) scale(1.2); opacity: 1; text-shadow: 0 0 20px #4caf50; }
    100% { transform: translate(-50%, -100px) scale(1.5); opacity: 0; }
}

/* 4. ë§ˆë²•: íšŒì „í•˜ë©° ì»¤ì§ */
@keyframes vfx-magic {
    0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(3) rotate(720deg); opacity: 0; }
}
/* [2P ì „ìš© ìŠ¤íƒ€ì¼: íŒŒë€ìƒ‰/ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€í™˜] */
        .unit.team-1 .unit-img, 
        .hero-card.p2-selected .unit-img-bg {
            filter: hue-rotate(180deg) brightness(1.1) !important;
        }
        .unit.team-1 .hp-fill {
        background: #5c6bc0 !important;
        }
        /* 2P ì„ íƒ ì¹´ë“œ ê°•ì¡° */
        .hero-card.p2-selected {
            border: 3px solid #5c6bc0 !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px #5c6bc0;
        }
		/* ğŸ“± [ì´ˆì†Œí˜• í™”ë©´ ìµœì í™”] ë†’ì´ê°€ 600px ì´í•˜ì¸ êµ¬í˜• ê¸°ê¸°ìš© íŒ¨ì¹˜ (ê°¤ëŸ­ì‹œ S25+ ë“±ì—ì„œëŠ” ì ìš© ì•ˆ ë¨) */
    @media (max-height: 600px) {
        /* 1. ì¹´ë“œ ë†’ì´ ì¶•ì†Œ (220px -> 160px) - ì •ë§ í™”ë©´ì´ ì‘ì„ ë•Œë§Œ ì¤„ì„ */
        .unit {
            height: 160px !important;
            width: 30vw !important;
        }

        /* 2. ì¹´ë“œ ë‚´ë¶€ ìš”ì†Œ í¬ê¸° ë° ìœ„ì¹˜ ì¬ì¡°ì • */
        .unit .card-name { font-size: 10px; margin-bottom: 2px; }
        .unit .tiny-icon { width: 18px; height: 18px; font-size: 12px; }
        .unit .card-badge { top: 2px; left: 2px; }
        .unit .attr-icon { width: 32px; height: 32px; font-size: 18px; }
        .unit .elec-badge, .unit .tree-badge, .unit .fire-badge { top: 25px; width: 16px; height: 16px; font-size: 9px; }

        /* 3. ì²´ë ¥ë°” ë‘ê»˜ ì¶•ì†Œ */
        .unit .status-bar { height: 5px; margin-top: 2px; }

        /* 4. ì»¨íŠ¸ë¡¤ íŒ¨ë„ í—¤ë” ì¶•ì†Œ */
        .cp-header { height: 28px; font-size: 10px; }

        /* 5. ìŠ¤í‚¬ ë²„íŠ¼ í¬ê¸° ì¶•ì†Œ */
        .btn-group { min-height: 45px; }
        .skill-name { font-size: 11px; }
        .skill-desc { font-size: 9px; display: none; } /* ì •ë§ ì¢ì„ ë•Œë§Œ ì„¤ëª… ìˆ¨ê¹€ */
    }

    /* ğŸ“± [ì´ˆì†Œí˜• ë„ˆë¹„] ì•„ì´í° SE (ë„ˆë¹„ 375px ì´í•˜) ëŒ€ì‘ */
    @media (max-width: 380px) {
        .unit { width: 31vw; } /* ê½‰ ì°¨ê²Œ */
        .card-atk { font-size: 9px; padding: 1px 4px; }
        .side-controls { transform: scale(0.8); left: 5px; top: 10px; } /* ë©”ë‰´ ë²„íŠ¼ ì‘ê²Œ */
    }

    /* [Fix] ì „ê¸° ì´í™íŠ¸ ê°•í™”: ë” ë°ê³ , ë” ì˜¤ë˜ ì§€ì†ë˜ë„ë¡ ë³€ê²½ */
    .lightning-bolt {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        /* ë…¸ë€ìƒ‰ + í°ìƒ‰ ê·¸ë¼ë°ì´ì…˜ìœ¼ë¡œ ë²ˆê°œ ëŠë‚Œ ê°•í™” */
        background: linear-gradient(135deg, transparent 40%, rgba(255, 235, 59, 0.8) 50%, #ffffff 60%, transparent 70%);
        background-size: 200% 200%;
        animation: lightning-flash 0.5s ease-out forwards; /* 0.2s -> 0.5s */
        pointer-events: none; z-index: 20;
        border-radius: 15px;
        mix-blend-mode: hard-light; /* ë°°ê²½ê³¼ ê°•í•˜ê²Œ í•©ì„± */
        box-shadow: 0 0 20px #ffeb3b; /* ë°œê´‘ íš¨ê³¼ ì¶”ê°€ */
    }
    @keyframes lightning-flash {
        0% { opacity: 0; background-position: 0% 0%; }
        20% { opacity: 1; background-position: 100% 100%; } /* ë²ˆê°œê°€ ì§€ë‚˜ê°€ëŠ” ì—°ì¶œ */
        40% { opacity: 0.5; }
        60% { opacity: 1; } /* í•œ ë²ˆ ë” ë²ˆì©! */
        100% { opacity: 0; }
    }
    .mind-control-wave {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 20px; height: 20px; border: 4px solid #d500f9; border-radius: 50%;
        animation: mc-pulse 0.8s ease-out forwards; pointer-events: none; z-index: 100;
        box-shadow: 0 0 15px #d500f9;
    }
    @keyframes mc-pulse {
        0% { width: 20px; height: 20px; opacity: 1; border-width: 4px; }
        100% { width: 200px; height: 200px; opacity: 0; border-width: 0px; }
    }
	/* [ì‹ ê·œ] ë¹›ì˜ í­ë°œ (ë°ì€ í™©ê¸ˆë¹›) */
    .impact-light-hit { filter: brightness(2.0) sepia(1) hue-rotate(-50deg); }
	/* [Patch v19.14] ë°°ì†/ì˜¤í†  ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .battle-controls { position: absolute; right: 55px; top: 50%; transform: translateY(-50%); display: flex; gap: 5px; z-index: 101; }
    .btn-battle-toggle { background: #fff; border: 1px solid #ddd; border-radius: 12px; padding: 4px 8px; font-size: 11px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: 0.2s; color: #555; font-family: var(--font-main); min-width: 30px; }
    /* [Fix v19.15] ë²„íŠ¼ ëˆŒë¦¼ íš¨ê³¼ ìˆ˜ì • (ìœ„ì¹˜ ì´ë™ ì œê±°) */
    .btn-battle-toggle:active { transform: scale(0.95); }
    .btn-battle-toggle.active-speed { background: #ff9800; color: #fff; border-color: #f57c00; box-shadow: 0 0 8px #ffb74d; }
    .btn-battle-toggle.active-auto { background: #4caf50; color: #fff; border-color: #388e3c; box-shadow: 0 0 8px #81c784; }
</style>
<script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="tooltip-view"></div>
<div id="flash-overlay"></div>
<!-- [ì»·ì‹ ] ì˜¤ë²„ë ˆì´ -->
<div id="cut-in-overlay">
    <div class="cut-in-img" id="cut-in-emoji">ğŸ¦</div>
    <div class="cut-in-text" id="cut-in-msg">FINISH!</div>
</div>
<!-- [íˆ´íŒ] ë·° -->

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v19.05 Fixed (Effect)</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="UI.showCollection()">ğŸ’ Codex</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="tutorial">ğŸ“š íŠœí† ë¦¬ì–¼ (ê¸°ì´ˆ)</option>
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
 
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="btn-online" class="btn-start" style="flex:1; font-size:16px; background: linear-gradient(135deg, #4db6ac 0%, #00897b 100%); color: white; box-shadow: 0 5px 0 #00695c, 0 10px 15px rgba(0, 105, 92, 0.3); border: 2px solid rgba(255,255,255,0.3);" onclick="UI.openOnlineModal()">
                ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
            </button>
            <button id="btn-start" class="btn-start" style="flex:1; font-size:16px;" onclick="Game.start()" disabled>
                âš”ï¸ ì „íˆ¬ ì‹œì‘
            </button>
        </div>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header" style="position:relative; padding-right:50px;">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width: 60%;">Ready... ğŸ±</span>
                
                <div class="battle-controls">
                    <button id="btn-speed" class="btn-battle-toggle" onclick="Game.toggleSpeed()">â–¶</button>
                    <button id="btn-auto" class="btn-battle-toggle" onclick="Game.toggleAuto()">ğŸ¤–</button>
                </div>

                <div style="position:absolute; right:5px; top:50%; transform:translateY(-50%); z-index: 102;">
                    <div class="side-btn main-menu-btn" onclick="UI.toggleDock()" style="width:32px; height:32px; font-size:16px; margin:0;" title="ë©”ë‰´">âš™ï¸</div>
                    
                    <div id="dock-folder" class="dock-folder" style="position:absolute; bottom:110%; right:0; flex-direction:column-reverse; background:transparent; padding-bottom:5px;">
                        <div class="side-btn" onclick="Game.reset()" title="í™ˆ" style="width:32px; height:32px; font-size:16px;">ğŸ </div>
                        
                        <div style="position:relative;">
                        <div class="side-btn" onclick="UI.toggleSettings()" title="ì†Œë¦¬" style="width:32px; height:32px; font-size:16px;">ğŸµ</div>
                        <div id="audio-settings" class="settings-modal" style="top:45px !important; right:-10px !important; bottom:auto !important; left:auto !important;">

                            <div class="set-row"><span>BGM</span><div class="toggle-btn on" id="tog-bgm" onclick="AudioSys.toggleChannel('bgm')"></div></div>
                            <div class="set-row" style="margin-top:5px;"><span style="font-size:10px; color:#888;">Vol</span><input type="range" class="vol-slider" min="0" max="100" value="50" oninput="AudioSys.setBgmVolume(this.value)"></div>

                            <div class="bgm-select" style="flex-wrap:wrap; justify-content: center; margin-top:8px;">
                                <div class="bgm-opt active" onclick="UI.selectBGM('Start', this)">Start</div>
                                <div class="bgm-opt" onclick="UI.selectBGM('Calm', this)">Calm</div>
                                <div class="bgm-opt" onclick="UI.selectBGM('Groove', this)">Groove</div>
                                <div class="bgm-opt" onclick="UI.selectBGM('Surprise', this)">Surprise</div>
                                <div class="bgm-opt" onclick="UI.selectBGM('Duck_step', this)">Duck</div>
                                <div class="bgm-opt" onclick="UI.selectBGM('Trip', this)">Trip</div>
                            </div>

                            <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:8px 0;">

                            <div class="set-row"><span>SFX</span><div class="toggle-btn on" id="tog-sfx" onclick="AudioSys.toggleChannel('sfx')"></div></div>
                            <div class="set-row" style="margin-top:5px;"><span style="font-size:10px; color:#888;">Vol</span><input type="range" class="vol-slider" min="0" max="100" value="50" oninput="AudioSys.setSfxVolume(this.value)"></div>

                        </div>
                    </div>

                        <div style="position:relative;">
                            <div class="side-btn" onclick="UI.toggleSaveMenu()" title="ì €ì¥" style="width:32px; height:32px; font-size:16px;">ğŸ’¾</div>
                            <div id="save-menu-popup" class="save-menu" style="top:45px !important; right:-10px !important; bottom:auto !important; left:auto !important;">
                                <div class="save-opt" onclick="Game.saveGame(); UI.toggleSaveMenu()">ğŸ’¾ì €ì¥</div>
                                <div class="save-opt" onclick="Game.loadGame(); UI.toggleSaveMenu()">ğŸ“‚ë¡œë“œ</div>
                            </div>
                        </div>

                        <div class="side-btn" onclick="UI.showGuide()" title="ê°€ì´ë“œ" style="width:32px; height:32px; font-size:16px;">ğŸ“–</div>
                        <div class="side-btn" onclick="UI.showCollection()" title="ë„ê°" style="width:32px; height:32px; font-size:16px;">ğŸ’</div>
                    </div>
                </div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>

// ==========================================
// ğŸ® GAME CONFIGURATION (v20.0)
// ==========================================
const GAME_CONFIG = {
    SAVE_VERSION: 'v7.0',
    SCHEMA_VERSION: 2,
    AI_THINK_TIME: 1000,
    ANIMATION_DELAY: 300,
    SUDDEN_DEATH_ROUND: 15,
    MAX_LOG_ENTRIES: 50
};

let socket;
// ==================== [ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸°] ====================
class SeededRandom {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0) this.seed += 2147483646;
    }
    
    next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    }
}

let globalRNG = null; // ì „ì—­ RNG ì¸ìŠ¤í„´ìŠ¤
if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {},
        emit: () => {},
        connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ");
}

let myRole = null;
let myRoom = null;
let isOnlineMode = false;
let netRndBuffer = []; // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ í˜¸í™˜ì„± ìœ ì§€
let netRndIdx = 0;
let isReplaying = false;
let gameSeed = null; // ì„œë²„ì—ì„œ ë°›ì€ ì‹œë“œ ì €ì¥

// [New] ë””ë²„ê·¸ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë„êµ¬
const DEBUG = {
    enabled: false, // ì½˜ì†”ì—ì„œ DEBUG.toggle()ë¡œ ì¼¤ ìˆ˜ ìˆìŒ
    log: function(...args) { if (this.enabled) console.log('%c[DEBUG]', 'color:cyan; font-weight:bold;', ...args); },
    error: function(...args) { if (this.enabled) console.error('%c[DEBUG ERR]', 'color:red; font-weight:bold;', ...args); },
    toggle: function() { this.enabled = !this.enabled; console.log(`ğŸ•µï¸ Debug Mode: ${this.enabled ? 'ON' : 'OFF'}`); }
};

const PERF = {
    timers: {},
    start: function(label) { if(DEBUG.enabled) this.timers[label] = performance.now(); },
    end: function(label) {
        if (DEBUG.enabled && this.timers[label]) {
            const t = performance.now() - this.timers[label];
            console.log(`%câ±ï¸ [PERF] ${label}: ${t.toFixed(2)}ms`, 'color:orange');
            delete this.timers[label];
        }
    }
};

// [ì¶”ê°€] ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('âš ï¸ Global Error:', {
        message: msg,
        line: lineNo,
        column: columnNo,
        error: error
    });
    
    // ê²Œì„ì´ ì´ë¯¸ ëë‚¬ê±°ë‚˜, Game ê°ì²´ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    if (typeof Game === 'undefined' || Game.isOver) return false;

    // ê²Œì„ ì¤‘ë‹¨ ë°©ì§€ (ìë™ ë³µêµ¬ ì‹œë„)
    if (Game.timer) clearTimeout(Game.timer);
    if (Game.watchdog) clearTimeout(Game.watchdog);
    
    // UIì— ì•Œë¦¼ í‘œì‹œ (Game.logê°€ ìˆë‹¤ë©´)
    if (Game.log) {
        Game.log("<span class='log-sys' style='color:red;'>âš ï¸ ì˜¤ë¥˜ ë°œìƒ! ìë™ ë³µêµ¬(í„´ ë„˜ê¸°ê¸°) ì‹œë„ ì¤‘...</span>");
    }

    // 1ì´ˆ ë’¤ ê°•ì œë¡œ í„´ì„ ë„˜ê²¨ì„œ ê²Œì„ì„ ì‚´ë¦¼
    setTimeout(() => {
        try {
            if (Game.endTurn) Game.endTurn();
        } catch(e) {
            console.error('Recovery failed:', e);
            alert("ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
        }
    }, 1000);
    
    return true; // ì—ëŸ¬ê°€ ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë¹¨ê°›ê²Œ ë„ë°°ë˜ëŠ” ê²ƒì„ ë°©ì§€
};

function getNetRandom() {
    // ì˜¨ë¼ì¸ ëª¨ë“œ: ì„œë²„ ì‹œë“œ ê¸°ë°˜ RNG ì‚¬ìš©
    if (isOnlineMode && globalRNG) {
        return globalRNG.next();
    }
    // ì˜¤í”„ë¼ì¸ ëª¨ë“œ: ì¼ë°˜ ë‚œìˆ˜
    return Math.random();
}

socket.on('gameStart', (data) => {
    isOnlineMode = true;
    myRole = data.role;
    myRoom = data.room;
    gameSeed = data.seed; // ì„œë²„ ì‹œë“œ ì €ì¥
    
    // ğŸ² ì‹œë“œ ê¸°ë°˜ RNG ì´ˆê¸°í™”
    globalRNG = new SeededRandom(gameSeed);
    console.log(`ğŸ² RNG ì´ˆê¸°í™” ì™„ë£Œ (Seed: ${gameSeed})`);
    
	// [Fix] ì˜¨ë¼ì¸ BGM ìë™ ì¬ìƒ
    MusicEngine.play('Battle_Piano');
	
    UI.closeModal();
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display = 'none';
    document.getElementById('battle-screen').style.display = 'flex';
    document.getElementById('logs').innerHTML = '';
    Game.difficulty = 'online';
    Game.mode = 'pvp';
    Game.turnCount = 1;
    Game.isOver = false;

    if (myRole === 'player2') Game.queue = [1, 0, 3, 2, 5, 4];
    else Game.queue = [0, 1, 2, 3, 4, 5];
    Game.curr = 0;
    Game.isProcessing = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra);
    });
    const enemyIndices = data.enemyDeck;
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(enIds[i], 1, original.base, original.extra);
    });
    Game.render();

    // [ì„ /í›„ê³µ ë³´ì •] ì˜¨ë¼ì¸ ëª¨ë“œ: í›„ê³µì—ê²Œ ë°©ì–´ë§‰ ë¶€ì—¬
    if (myRole === 'player2') {
        Game.pTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.log("<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ ë³´ë„ˆìŠ¤: ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ìƒíƒœ!</span>");
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.eTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.timer = setTimeout(() => Game.turn(), 1000);
    }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    
    if (attacker) {
        // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
        if (data.mcState) {
            if (data.mcState.isMindControlling) {
                const mcTarget = allUnits.find(u => u.id === data.mcState.mcTargetId);
                Game.isMindControlling = mcTarget || null;
                Game.currentMCCasterId = data.mcState.mcCasterId || null;
            } else {
                Game.isMindControlling = null;
                Game.currentMCCasterId = null;
            }
        }
        
        // RNGëŠ” ì´ë¯¸ ë™ê¸°í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ ë¶ˆí•„ìš”
        Game.execute(attacker, target, data.skillIdx, true);
    }
});

socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)");
    
    // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬
    isOnlineMode = false;
    globalRNG = null;
    gameSeed = null;
    Game.isMindControlling = null;
    Game.currentMCCasterId = null;
});

socket.on('waiting', (msg) => {
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.innerText = "â³ " + msg;
        btn.disabled = true;
    }
});

socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.disabled = false;
        btn.innerText = "ì…ì¥í•˜ê¸° ğŸš€";
    }
});

function startOnlineGame(code) {
    AudioSys.init();
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
    }
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    socket.emit('findMatch', {
        deck: Game.selected,
        roomCode: code
    });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };
const IMAGE_DB = {
    // [ê¸°ì´ˆ ì†ì„±]
    'Fire': './fire.png',
    'Water': './water.png',
    'Tree': './tree.png',
    'Metal': './metal.png',
    'Earth': './earth.png',
    'Light': './light.png',
    'Dark': './dark.png',
    'Normal': './normal.png',

    // [ë¹› ì¡°í•©]
    'Fire-Light': './fire_light.png',    // (ì™„ë£Œ) í‘¸ë¥¸ë¶ˆ
    'Water-Light': './water_light.png', // ì¦ê¸°
    'Tree-Light': './tree_light.png',   // ìˆ²
    'Metal-Light': './metal_light.png', // ë…ê°€ìŠ¤
    'Earth-Light': './earth_light.png', // ëª¨ë˜

    // [ì–´ë‘  ì¡°í•©]
    'Fire-Dark': './fire_dark.png',     // ê²€ì€ë¶ˆ
    'Water-Dark': './water_dark.png',   // ì–¼ìŒ
    'Tree-Dark': './tree_dark.png',     // ê°€ì‹œ
    'Metal-Dark': './metal_dark.png',   // ì „ê¸°
    'Earth-Dark': './earth_dark.png',   // ë°”ìœ„

    // [ê°•í™” ì†ì„±]
    'Light-Light': './light_enhanced.png', // ì²œì‚¬/ì„±ê¸°ì‚¬
    'Dark-Dark': './dark_enhanced.png',    // ì•…ë§ˆ/ì‹¬ì—°

    // [ê¸°ë³¸ê°’] (ì´ë¯¸ì§€ê°€ ì—†ê±°ë‚˜ ì´ë¦„ì´ í‹€ë ¸ì„ ë•Œ ë‚˜ì˜¤ëŠ” ì´ë¯¸ì§€)
    'Default': 'https://via.placeholder.com/150/cccccc/ffffff?text=No+Image'
};
const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.1ë°°+40%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15', type:'CC', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë°›ëŠ” í”¼í•´ MaxHP 20% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 20%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ë¿Œë¦¬ë¬¶ê¸°', s1d:'3í„´ê°„ ì•„êµ°í”¼í•´ 40%ëŒ€ì‹ ë°›ìŒ(ì•„êµ°60%)', s2:'ì¹˜ìœ ì˜ ì', s2d:'HP+100/ì •í™”(CCí•´ì œì‹œ ë€ê°â†‘)', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', desc:'ìˆ˜í˜¸í˜• íƒ±ì»¤<br>í”¼í•´ ë¶„ì‚° + ë€ê° íŒ¨ì‹œë¸Œ', passive:'ğŸŒ³ ê±°ëª©: ë°›ëŠ” í”¼í•´ê°€ 15% ê°ì†Œí•©ë‹ˆë‹¤. S2ë¡œ í–‰ë™ë¶ˆê°€ë¥¼ í•´ì œí•˜ë©´ ë€ê°ìœ¨ì´ 5%ì”© ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 25%).'},
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(3í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 30%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ 1íšŒ ìë™ íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.5ë°° +í™”ìƒ(60%)', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(30%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ / ìœ ë¦¬ëŒ€í¬', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2R ê³µ+15, 3~6R ê³µ+10, 7R~ ê³µ+5' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'âš–ï¸', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°© (ì•½ì :ë‹¨ì¼ê¸°ì´ˆ5ì†ì„±) + ì„œë¸Œíƒ±í‚¹', passive:'ğŸ² ë©´ì—­: í–‰ë™ ì œì–´ê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ,ì„¸ë‡Œ)ì— ê±¸ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.'},
    
    // [ìˆ˜ì •] ìê°€í™”ìƒ íŒ¨ì‹œë¸Œ ì„¤ëª… ì‚­ì œ
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ(100%)', s2:'ì†Œê°', s2d:'1.0ë°°+ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€íƒ€', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì—­ì´ìš© / ê°•ë ¥í•œ ê´‘ì—­ ë„íŠ¸', passive:'ğŸ”¥ ì†Œê°: S2 ì‚¬ìš© ì‹œ ì ì˜ ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€ í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.35ë°°+ìê°€ê¸°ì ˆ(1í„´)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ ì‚¬ìš© í›„ 1í„´ê°„ [ë°˜ë™] ìƒíƒœê°€ ë©ë‹ˆë‹¤. ë°˜ë™ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 15 ì¦ê°€í•˜ê³  ë°›ëŠ” ì¹˜ìœ /ì‹¤ë“œê°€ 30% ê°ì†Œí•˜ë©°, ì´ëŠ” ì •í™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.4ë°°+ë²„í”„í•´ì œ+(ê¸°ì ˆ25%/ì¹¨ë¬µ20%)', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ë²„í”„ íŒŒê´´ / ê¸°ì ˆ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°+ë°ë¯¸ì§€20%ì‰´ë“œ', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²° + ìê°€ì‰´ë“œ', passive:'â„ï¸ ì–¼ìŒ ê°‘ì˜·: S1 ì‚¬ìš© ì‹œ ì…íŒ ë°ë¯¸ì§€ì˜ 20%ë§Œí¼ ì‰´ë“œë¥¼ íšë“í•©ë‹ˆë‹¤.' },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'ì´ˆê¸°3ë€+í”¼ê²©ì1.0ë°°(CCì¶”ê°€íƒ€1.3ë°°/ë‚˜ë¬´ë³´í˜¸ìì „ì´)', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ë…(35) ë° ì¹˜ìœ ê°ì†Œ20% 3í„´', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë‚˜ë¬´(Tree) ì¹´ìš´í„° / íë°´', passive:null },
    
    // [ìˆ˜ì •] ì†ë°• -> ëª¨ë˜ì§€ì˜¥(ì§€ì†í”¼í•´) ëª…ì‹œ
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°(ê´€í†µ)+ì‰´ë“œíƒ€ê²©0.6ë°°', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•(60) ë° ì¹˜ìœ ê°ì†Œ(50%) 2í„´', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì‰´ë“œ íŒŒê´´ì / íëŸ¬ ì–µì œ', passive:null },
    
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë³µìˆ˜(ê³„ìˆ˜ì¦ê°€)', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì˜êµ¬ ì¦ê°€.' },
    
    // [ìˆ˜ì •] 1.5ë°°->1.4ë°°, íëŸ‰ í‘œê¸° ìˆ˜ì •, íŒ¨ì‹œë¸Œ ì¶”ê°€
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.4ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´ 110 íšŒë³µ', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:'ğŸ’§ ìƒëª…ìˆ˜: S1/S2 ì‚¬ìš© ì‹œ 20% í™•ë¥ ë¡œ ì²´ë ¥ì´ ê°€ì¥ ë‚®ì€ ì•„êµ°ì„ 50 ì¶”ê°€ ì¹˜ìœ í•©ë‹ˆë‹¤.' },
    
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.3ë°°+ë¹ˆì‚¬ì•„êµ° ì‰´ë“œ40', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + ë³´í˜¸ë§‰', passive:null },
    
    // [ìˆ˜ì •] ì¤‘ì²© ì‹œ íš¨ê³¼ ê°•í™” ëª…ì‹œ
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15(ì¤‘ì²©ì‹œ+20)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    
    // [ìˆ˜ì •] ê³µê¹ ìˆ˜ì¹˜ ì¡°ê±´ ëª…ì‹œ
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(í”¼í•´ëŸ‰30%ë°˜ì‚¬/CCë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.4ë°°/ê³µ20~35%â†“', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    
    // [ìˆ˜ì •] ì½”ìŠ¤íŠ¸ 20% -> 12% ìˆ˜ì •
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.8ë°°+ì¹¨ë¬µ(1í„´)', s2:'ì •ì‹ ì§€ë°°', s2d:'HP12%ì†Œëª¨/ì„¸ë‡Œ(30~55%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ§ ', desc:'ì‹¬ì—°ì˜ ì§€ë°°ì<br>ì  ì œì–´ê¶Œ íƒˆì·¨', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ì„¸ë‡Œ ì„±ê³µë¥ ì€ ê¸°ë³¸ 30%ì´ë©°, ëŒ€ìƒì˜ ì²´ë ¥ì´ ë‚®ì„ìˆ˜ë¡ ìµœëŒ€ 55%ê¹Œì§€ ì¦ê°€í•©ë‹ˆë‹¤. ì„±ê³µ ì‹œ ë‹¤ìŒ í„´ ì ì„ 1íšŒ ì¡°ì¢…í•©ë‹ˆë‹¤.' }
};

// [ì‹ ê·œ] Emotion Alias Database (English)
const EMOTION_DB = {
    'Fire': { t: 'Rage', d: 'Burning instinct of destruction' },
    'Water': { t: 'Sorrow', d: 'Cold grief that freezes the heart' },
    'Tree': { t: 'Vigor', d: 'Unstoppable life force' },
    'Metal': { t: 'Coldness', d: 'Reason without emotion' },
    'Earth': { t: 'Stoicism', d: 'Unshakable calmness' },
    'Light': { t: 'Bliss', d: 'Pure joy and light' },
    'Dark': { t: 'Terror', d: 'Fear of the unknown' },
    'Normal': { t: 'Void', d: 'Emptiness unaffected by anything' },
    
    'Fire-Light': { t: 'Passion', d: 'Rage sublimated into positivity' },
    'Fire-Dark': { t: 'Madness', d: 'Uncontrollable frenzy' },
    'Water-Light': { t: 'Compassion', d: 'Sorrow that embraces others' },
    'Water-Dark': { t: 'Misery', d: 'Solidified pain and cold' },
    'Tree-Light': { t: 'Hope', d: 'A forest embracing everyone' },
    'Tree-Dark': { t: 'Obsession', d: 'Twisted love and pain' },
    'Metal-Light': { t: 'Critique', d: 'Sharp and piercing analysis' },
    'Metal-Dark': { t: 'Thrill', d: 'Hidden stimulating excitement' },
    'Earth-Light': { t: 'Tenacity', d: 'Persistence that never lets go' },
    'Earth-Dark': { t: 'Pride', d: 'Overwhelming weight of arrogance' },
    'Light-Light': { t: 'Salvation', d: 'Liberation from suffering' },
    'Dark-Dark': { t: 'Domination', d: 'Power to control minds' }
};

// [ì‹ ê·œ] Title Manager (Unlock System)
const TitleManager = {
    unlocked: JSON.parse(localStorage.getItem('et_titles_en') || '[]'),
    unlock: function(key) {
        if (!this.unlocked.includes(key)) {
            this.unlocked.push(key);
            localStorage.setItem('et_titles_en', JSON.stringify(this.unlocked));
            return true;
        }
        return false;
    }
};

const ChallengeDB = [
    /* === [Lv.1-3] ì´ˆê¸‰: ê¸°ë³¸ ê¸°ë¯¹ í•™ìŠµ === */
    // 1. [ì…ë¬¸] íƒ±ì»¤ ëŒíŒŒ
    { name: "ë¶€ë™ì˜ ì² ì˜¹ì„±", desc: "ì‡ (Metal)ê°€ ì•ì„ ë§‰ê³  ìˆìŠµë‹ˆë‹¤. ë’¤ì— ìˆ¨ì€ ë”œëŸ¬ë¶€í„° ë…¸ë¦¬ì„¸ìš”!", team: ['Metal', 'Fire', 'Water'] },

    // 2. [ìœ ì§€ë ¥] í¡í˜ˆê³¼ í
    { name: "ë¶‰ì€ ê·€ì¡±", desc: "ë•Œë ¤ì„œ íšŒë³µí•˜ëŠ” í¡í˜ˆê·€ë“¤ì…ë‹ˆë‹¤. í•œ ëª…ì”© í™•ì‹¤í•˜ê²Œ ëŠì–´ì•¼ í•©ë‹ˆë‹¤.", team: ['Fire-Light', 'Tree', 'Fire-Dark'] },

    // 3. [ì‹¬ë¦¬ì „] ë°˜ì‚¬ì™€ ë³µìˆ˜
    { name: "ë”œë ˆë§ˆì˜ ìˆ²", desc: "ì–´ë‘ (Dark)ì„ ì¹˜ë©´ ë°˜ì‚¬ë˜ê³ , ë‚˜ë¬´(Tree-Dark)ë¥¼ ë‚¨ê¸°ë©´ ê´´ë¬¼ì´ ë©ë‹ˆë‹¤.", team: ['Dark', 'Tree-Dark', 'Normal'] },

    /* === [Lv.4-6] ì¤‘ê¸‰: íŠ¹ìˆ˜ ê³µëµ í•„ìš” === */
    // 4. [íšŒí”¼] íšŒí”¼ ë©”ì»¤ë‹ˆì¦˜
    { name: "ì‹ ê¸°ë£¨ ì‘ì „", desc: "ì¦ê¸°(Water-Light)ëŠ” ìœ„ê¸° ì‹œ íšŒí”¼í•©ë‹ˆë‹¤. ë…ì´ë‚˜ í•œë°© ë”œì´ í•„ìš”í•©ë‹ˆë‹¤.", team: ['Water-Light', 'Fire-Dark', 'Light'] },

    // 5. [ë°©ì–´] ì¢€ë¹„ ë²½
    { name: "ë¶ˆë©¸ì˜ ìš”ìƒˆ", desc: "ì£½ì§€ ì•ŠëŠ” ì¢€ë¹„ ì¡°í•©. ì‡ (Metal)ë¥¼ ëš«ì„ ê°•ë ¥í•œ í™”ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.", team: ['Metal', 'Tree', 'Water'] },

    // 6. [ì €ê²©] íë°´ ì „ìˆ 
    { name: "ëª¨ë˜ í­í’", desc: "ì¹˜ìœ  ê°ì†Œ íš¨ê³¼ë¡œ ë‹¹ì‹ ì˜ íëŸ¬ë¥¼ ë¬´ë ¥í™”ì‹œí‚µë‹ˆë‹¤.", team: ['Earth-Light', 'Metal-Light', 'Earth'] },

    /* === [Lv.7-10] ìƒê¸‰: ë©”íƒ€ ìµœê°• ì¡°í•© === */
    // 7. [ë©”íƒ€1] ë¬´í•œ CC ì§€ì˜¥
    { name: "ì ˆëŒ€ ì˜ë„", desc: "ì–¼ë¦¬ê³ , ê¸°ì ˆì‹œí‚¤ê³ , ì¡°ì¢…í•©ë‹ˆë‹¤. ë‹¹ì‹ ì—ê²Œ í„´ì€ ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤.", team: ['Water-Dark', 'Metal-Dark', 'Dark-Dark'] },

    // 8. [ë©”íƒ€2] ë¬´í•œ ì½¤ë³´
    { name: "ëŒ€ì§€ì˜ ì§„ê²©", desc: "ì²œì‚¬(Light-Light)ê°€ ë°”ìœ„(Earth-Dark)ì˜ ê¸°ì ˆ íŒ¨ë„í‹°ë¥¼ ì§€ì›Œì¤ë‹ˆë‹¤. ë¬´í•œ í•µí€ì¹˜ë¥¼ ì¡°ì‹¬í•˜ì„¸ìš”.", team: ['Metal', 'Earth-Dark', 'Light-Light'] },

    // 9. [ë©”íƒ€3] ë¶ˆì‚¬ ì„œí¬íŠ¸
    { name: "ì„±ì—­ì˜ ì§€ë°°ì", desc: "ë¬´í•œ ì‰´ë“œì™€ ì •í™”, ê·¸ë¦¬ê³  ì„¸ë‡Œ. ê°€ì¥ ë¶ˆì¾Œí•œ ê²½í—˜ì„ ì„ ì‚¬í•©ë‹ˆë‹¤.", team: ['Light-Light', 'Dark-Dark', 'Water-Light'] },

    // 10. [ìµœì¢…ë³´ìŠ¤] The Apex
    { name: "The Apex (ì •ì )", desc: "ë„ë°œ(Metal), ì„¸ë‡Œ(Dark-Dark), ì •í™”(Light-Light). ì´ ê²Œì„ì˜ ìµœê°•ìë“¤ì…ë‹ˆë‹¤.", team: ['Metal', 'Dark-Dark', 'Light-Light'] }
];

// [Online] ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸° (ë™ê¸°í™” í•„ìˆ˜)
// Math.random() ëŒ€ì‹  ì´ê±¸ ì¨ì•¼ ë‘ í”Œë ˆì´ì–´ì˜ ê²°ê³¼ê°€ ë˜‘ê°™ìŠµë‹ˆë‹¤.
const RNG = {
    seed: 1,
    init: function(s) { 
        this.seed = s % 2147483647; 
        if (this.seed <= 0) this.seed += 2147483646; 
    },
    next: function() {
        // Park-Miller ì•Œê³ ë¦¬ì¦˜ (ê°€ë³ê³  ë¹ ë¦„)
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    },
    // ë²”ìœ„ ëœë¤ (min ~ max)
    range: function(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
};

const Common = {
    logAction: function(game, type, source, target, value, extra='') {
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else { msg = `[${source.name.split(' ')[0]}] ${extra}`; }
        game.log(msg);
    },
    // [ê³µìœ  ë¡œì§] ë°ë¯¸ì§€ ë¶„ì‚° ì²˜ë¦¬ê¸°
    distributeDamage: function(atk, def, dmg, game, isFire, ignoreShield) {
        // 1. ë°©ì–´ìê°€ ë‚˜ë¬´ê°€ ì•„ë‹ˆê³ , ì•„êµ° ì¤‘ì— [ë¿Œë¦¬ë¬¶ê¸°(ROOT_GUARD)] ì¼œì§„ ë‚˜ë¬´ê°€ ìˆëŠ”ì§€ í™•ì¸
        const allies = def.team === 0 ? game.pTeam : game.eTeam;
        const protector = allies.find(u => u.id !== def.id && !u.isDead && u.base === 'Tree' && u.hasStatus('ROOT_GUARD'));

        // 2. ë³´í˜¸ìê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ëŒ€ë¡œ ë‹¨ì¼ í”¼ê²©
        if (!protector) {
            const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
            return { targetAct: act, split: false };
        }

        // 3. ë°ë¯¸ì§€ ë¶„ì‚° (ë‚˜ë¬´ 40% : ë³´í˜¸ëŒ€ìƒ 60%)
        // [Fix] ì†Œìˆ˜ì  ë²„ë¦¼ìœ¼ë¡œ ì¸í•œ 0 ë°ë¯¸ì§€ ë°©ì§€ (ìµœì†Œ 1 ë³´ì¥ ë¡œì§ì€ ì œì™¸í•˜ë˜ ê³„ì‚° ëª…í™•í™”)
        const shareDmg = Math.floor(dmg * 0.4); 
        const originalDmg = dmg - shareDmg;

        // [ì´í™íŠ¸] ì—°ê²°ì„  í‘œí˜„
        if (!game.isProcessing) {
            UI.fireProjectile(protector, def, 'ğŸŒ¿'); 
        }

        // 4. ë°ë¯¸ì§€ ì ìš©
        const act1 = def.takeDamage(originalDmg, isFire, ignoreShield, atk);
        const act2 = protector.takeDamage(shareDmg, isFire, ignoreShield, atk);

        // 5. ë¡œê·¸ ì¶œë ¥
        game.log(`<span class="log-sys" style="color:#66bb6a;">ğŸ›¡ï¸ [${protector.name}] í”¼í•´ ë¶„ë‹´! <b style="color:#ff7043;">(-${act2})</b></span>`);
        UI.floatText(protector, `-${act2} (ëŒ€ì‹ ë§ê¸°)`, "ft-dmg");

        return { targetAct: act1, split: true };
    },

    basicAttack: function(atk, def, game) {
        // 1. ì†Œë¦¬ëŠ” ê³µê²© ì‹œë„ ì‹œ ë°”ë¡œ ì¬ìƒ (ì·¨í–¥ì— ë”°ë¼ ì‹¤ëª…ì¼ ë•Œ ëŒ ìˆ˜ë„ ìˆìŒ)
        AudioSys.play('HIT');

        // 2. ì‹¤ëª…(BLIND) ì²´í¬ ë¡œì§ (ê¸°ì¡´ ì½”ë“œ ë³µêµ¬)
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { 
            Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)");
            UI.floatText(atk, "BLINDED", "ft-miss"); 
            return; // ì‹¤ëª…ì´ë©´ ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ (ë°ë¯¸ì§€ X, ì´í™íŠ¸ X)
        }

        // 3. ì‹¤ëª…ì´ ì•„ë‹ ë•Œë§Œ ê³µê²© ë¡œê·¸ ë° ì´í™íŠ¸ ì¶œë ¥
        game.log(`<b>[${atk.name}]</b> ê³µê²©! âš”ï¸`);
        
        // [ì´í™íŠ¸] ê³µê²© ì„±ê³µ ì‹œì—ë§Œ ìƒ¥! (ì‹¤ëª…ì¼ ë• ì•ˆ ë‚˜ì˜´)
        UI.playVFX(def, 'slash'); 

        // 4. ë°ë¯¸ì§€ ê³„ì‚°
        const act = Common.applyDamage(atk, def, 1.0, game);
        if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
    },

    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { 
            UI.floatText(atk, "BLINDED", "ft-miss");
            Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); 
            return -1; 
        }
        
        const baseAtk = atk.getAtk();
        const applyAffinity = (def.team !== atk.team) || (game.isMindControlling);
        const aff = applyAffinity ? game.calc(atk, def) : {v:1, t:''};

        // [ìˆ˜ì •] ìµœì¢… ë°ë¯¸ì§€ ì‚°ì¶œ
        const rawDmg = Math.floor(baseAtk * mult * aff.v);
        
        // [ìˆ˜ì •] ë¶„ì‚° ë¡œì§ í˜¸ì¶œ
        const res = Common.distributeDamage(atk, def, rawDmg, game, isFire, ignoreShield);
        const act = res.targetAct;

        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) { 
            let type = act>=200 ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type); 
            game.shake(def);
            
            // [ê°œì„ ] íˆíŠ¸ìŠ¤í†± ì ìš© (í‚¬ ì—¬ë¶€ íŒì •)
            const isKill = (def.hp <= 0);
            if (typeof UI !== 'undefined' && UI.hitStop) {
                // ê´‘ì—­ ê³µê²© ì—¬ë¶€ëŠ” ìƒìœ„ì—ì„œ íŒë‹¨í•˜ê¸° ì–´ë ¤ìš°ë¯€ë¡œ ì¼ë‹¨ ë‹¨ì¼ ê³µê²©ìœ¼ë¡œ ì²˜ë¦¬
                UI.hitStop(act, false, true, isKill);
            }

            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.30));
                if(healAmt > 0) { 
                    atk.heal(healAmt);
                    const buff = atk.status.find(s => s.type === 'LIFESTEAL_BUFF');
                    if (buff && buff.sourceId !== -1 && buff.sourceId !== atk.id) {
                        const allUnits = [...game.pTeam, ...game.eTeam];
                        const provider = allUnits.find(u => u.id === buff.sourceId);
                        if(provider) game.recordStat(provider, 'heal', healAmt);
                    } else {
                        Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)");
                    }
                }
            }
        } else { 
            Common.logAction(game, 'miss', atk, def, 0);
            UI.floatText(def, "MISS", "ft-miss"); 
        }
        return act;
    },
    // [ìˆ˜ì •] ì„¸ë‡Œ ìƒíƒœì¼ ë•Œ í”¼ì•„ì‹ë³„ ë°˜ì „ ë¡œì§ (ê´‘ì—­ê¸° ë²„ê·¸ ìˆ˜ì •)
    forEachAlly: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì ì´ ë‚´ ì•„êµ°
        }
        const team = effectiveTeam === 0 ? game.pTeam : game.eTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    },
    forEachEnemy: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì›ë˜ ì•„êµ°ì´ ì 
        }
        const team = effectiveTeam === 0 ? game.eTeam : game.pTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    }
};

const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                UI.playVFX(def, 'fire'); // [ì´í™íŠ¸] ë¶ˆê½ƒ ë°œì‚¬
                
                // [Balance] í™”ìƒ í™•ë¥  60% ìœ ì§€, ê³„ìˆ˜ 1.5ë¡œ ë„ˆí”„
                const act = Common.applyDamage(atk, def, 1.5, game, false, true);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.60) def.addStatus('BURN', 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                // [ì´í™íŠ¸] ì  ì „ì²´ í­ë°œ
                Common.forEachEnemy(atk, game, (e) => UI.playVFX(e, 'fire'));

                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if (act !== -1) {
                         Common.logAction(game, 'dmg', atk, e, act, "");
                         if (game.netRandom() < 0.30) e.addStatus('BURN', 2, 0, atk);
                    }
                });
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                UI.playVFX(def, 'water');
                // [Balance] 1.5ë°° -> 1.4ë°° ë„ˆí”„
                const act = Common.applyDamage(atk, def, 1.4, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    UI.playVFX(a, 'heal');
                    // [Fix] ê¸°ë³¸ íëŸ‰ 110ìœ¼ë¡œ ìƒí–¥
                    const h = a.heal(110);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
            }

            // [New Passive] S1, S2 ì‚¬ìš© ì‹œ 20% í™•ë¥ ë¡œ ìµœì € ì²´ë ¥ ì•„êµ° ì¹˜ìœ 
            if (sIdx > 0 && game.netRandom() < 0.20) {
                const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                // ì²´ë ¥ì´ ê°€ì¥ ë‚®ì€(ì ˆëŒ€ê°’ ê¸°ì¤€) ì•„êµ° ì°¾ê¸°
                const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                if (target) {
                    UI.playVFX(target, 'heal');
                    const h = target.heal(50);
                    game.recordStat(atk, 'heal', h);
                    UI.floatText(target, "+50(P)", "ft-heal");
                    game.log(`<span class='log-sys'>ğŸ’§ [íŒ¨ì‹œë¸Œ] ${target.name} ì¶”ê°€ ì¹˜ìœ  (+${h})</span>`);
                }
            }
            
            if (sIdx === 2) return false; // S2ëŠ” ê³µê²©ì´ ì•„ë‹ˆë¯€ë¡œ íˆ¬ì‚¬ì²´ ì†Œë¦¬ ë°©ì§€
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                // S1: ë¿Œë¦¬ ë¬¶ê¸° (ìì‹ ì—ê²Œ ìˆ˜í˜¸ ë²„í”„)
                game.log(`<b>[${atk.name}]</b> ë¿Œë¦¬ ë¬¶ê¸° ğŸªµ`);
                AudioSys.play('POWER_UP');
                UI.playVFX(atk, 'leaf');
                
                // ROOT_GUARD: ì•„êµ° í”¼í•´ 50% ëŒ€ì‹  ë°›ìŒ
                atk.addStatus('ROOT_GUARD', 3, 0, atk);
                UI.floatText(atk, "ìˆ˜í˜¸íƒœì„¸", "ft-heal");
                Common.logAction(game, 'buff', atk, atk, 0, "(3í„´ê°„ í”¼í•´ë¶„ì‚°)");
                return false;
            } else {
                // S2: ì¹˜ìœ ì˜ ì (í 140 + ì¡°ê±´ë¶€ íŒ¨ì‹œë¸Œ ê°•í™”)
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                UI.playVFX(def, 'heal');
                
                // 1. í ì‹¤í–‰ [Balance] 140 -> 100 ë„ˆí”„
                const h = def.heal(100);
                
                // 2. í–‰ë™ë¶ˆê°€ CC ì²´í¬ (ê¸°ì ˆ, ë¹™ê²°, ìˆ˜ë©´ ë“±)
                // (ì¼ë°˜ ë””ë²„í”„ì¸ ì¹¨ë¬µ, ì†ë°• ë“±ì€ ì œì™¸í•˜ê³  ì™„ë²½í•œ í–‰ë™ë¶ˆê°€ë§Œ ì¹´ìš´íŠ¸í•˜ì—¬ ë°¸ëŸ°ìŠ¤ ì¡°ì ˆ)
                const hardCC = ['STUN', 'FREEZE', 'SLEEP', 'BANISH'];
                const hasHardCC = def.status.some(s => hardCC.includes(s.type));
                
                // 3. ì •í™”
                def.cleanse();
                
                // 4. CC í•´ì œ ì„±ê³µ ì‹œ íŒ¨ì‹œë¸Œ ê°•í™” (ìµœëŒ€ 2ìŠ¤íƒ = +10%)
                let extraMsg = "(ì •í™”)";
                if (hasHardCC) {
                    if (atk.treeStack < 2) {
                        atk.treeStack++;
                        UI.floatText(atk, "ê±°ëª©ì„±ì¥!", "ft-crit");
                        extraMsg += " + ğŸ›¡ï¸ì„±ì¥";
                    } else {
                        UI.floatText(atk, "MAX", "ft-miss");
                    }
                }

                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, extraMsg);
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                UI.playVFX(def, 'slash');
                // [Fix] ë”œ 1.1ë°°ë¡œ í•˜í–¥
                const act = Common.applyDamage(atk, def, 1.1, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Fix] ì‰´ë“œ í¡ìˆ˜ëŸ‰ 40%ë¡œ ìƒí–¥
                    const absorb = Math.floor(act * 0.40);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                UI.playVFX(def, 'magic');
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                atk.checkAwakening(); // [Fix] ì‰´ë“œ ìµœëŒ€ì¹˜(400) ì œí•œ ì ìš©
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸŒ‘`);
                UI.playVFX(def, 'rock');
                
                // [Balance] ë²„í”„ 1ê°œ íŒŒê´´ (ëŒë¡œ ê¹¨ë¶€ìˆ˜ê¸°)
                let dispelled = false;
                // [Fix] ìŠ¤íƒ ê°ì†Œ ì‹œ ì‹¤ì œ ìŠ¤íƒ¯ë„ í•¨ê»˜ ì°¨ê° (ë¬´í•œ ìŠ¤íƒ ë°©ì§€)
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) { 
                    def.s2Count--; 
                    def.atk = Math.max(10, def.atk - 20); // ê³µê²©ë ¥ 20 íšŒìˆ˜
                    dispelled = true; 
                    UI.floatText(def, "í­ì£¼í•´ì œ", "ft-miss");
                }
                else if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) { 
                    def.elecStacks--; 
                    def.atk = Math.max(10, def.atk - 10); // ê³µê²©ë ¥ 10 íšŒìˆ˜
                    dispelled = true; 
                    UI.floatText(def, "ê³¼ë¶€í•˜í•´ì œ", "ft-miss");
                }
                else if (def.getKey() === 'Tree' && def.treeStack > 0) { 
                    def.treeStack--; 
                    dispelled = true; 
                    // ë‚˜ë¬´ëŠ” takeDamageì—ì„œ treeStackì„ ì‹¤ì‹œê°„ ì°¸ì¡°í•˜ë¯€ë¡œ ë³„ë„ ìŠ¤íƒ¯ ì°¨ê° ë¶ˆí•„ìš”
                }
                if (!dispelled) {
                    const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT', 'DMG_RED', 'GROWTH', 'LIFESTEAL_BUFF', 'ROOT_GUARD', 'START_IMMUNITY'];
                    const idx = def.status.findIndex(s => buffs.includes(s.type));
                    if (idx !== -1) {
                        def.status.splice(idx, 1);
                        UI.floatText(def, "íŒŒê´´", "ft-miss");
                        dispelled = true;
                    }
                }
                if(dispelled) game.log(" (ğŸ’¥ ë²„í”„ íŒŒê´´!)");

                // [Balance] 1.4ë°° ë°ë¯¸ì§€
                const act = Common.applyDamage(atk, def, 1.4, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if (game.netRandom() < 0.25) def.addStatus('STUN', 1, 0, atk);
                    else if (game.netRandom() < 0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u => !u.isDead).length;
                const eAlive = game.eTeam.filter(u => !u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                Common.forEachEnemy(atk, game, (e) => {
                    UI.playVFX(e, 'rock');
                    const act = Common.applyDamage(atk, e, mult, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                UI.playVFX(def, 'magic');
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    UI.playVFX(a, 'heal');
                    // [Balance] ë°˜ë™ ìƒíƒœ ëŒ€ìƒì€ ì‹¤ë“œ íšë“ 30% ê°ì†Œ
                    let sVal = 70;
                    if (a.hasStatus('EARTH_RECOIL')) sVal = Math.floor(sVal * 0.7);

                    a.shield += sVal;
                    
                    const existing = a.status.find(s => s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    a.addStatus('LIGHT_MIGHT', 2, nextVal);
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                UI.playVFX(def, 'vortex');
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    UI.playVFX(e, 'vortex');
                    // [Balance] 0.3ë°° -> 0.4ë°° ìƒí–¥
                    const act = Common.applyDamage(atk, e, 0.4, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s => s.type === 'ATK_DOWN');
                        e.status = e.status.filter(s => s.type !== 'ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear ? 35 : 20, atk);
                        if (e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                if (atk.hp > 30) {
                    atk.hp -= 30;
                    UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                    if (target) {
                        target.shield += 60;
                        game.recordStat(atk, 'shield', 60);
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í¡í˜ˆ ë¶€ì—¬ ğŸ©¸`);
                Common.forEachAlly(atk, game, (a) => {
                    UI.playVFX(a, 'fire');
                    // [Fix] ë²„í”„ ì´ë¦„ í†µì¼ (VAMP -> LIFESTEAL_BUFF)
                    a.addStatus('LIFESTEAL_BUFF', 3, 0, atk);
                });
            } else {
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                UI.playVFX(atk, 'fire');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                // íŒ€ì›ì—ê²Œë§Œ ë²„í”„ ë¶€ì—¬ (ìê¸° ìì‹  ì œì™¸)
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id === atk.id) return; // ë³¸ì¸ ì œì™¸
                    // ê¸°ì¡´ ë²„í”„ ì œê±° í›„ ìƒˆë¡œ ë¶€ì—¬ (ì¤‘ì²© ë°©ì§€, ê°±ì‹ )
                    a.status = a.status.filter(s => s.type !== 'ATK_BUFF_SMALL');
                    a.addStatus('ATK_BUFF_SMALL', 2);
                });
                game.render(); // UI ê°•ì œ ê°±ì‹ 
                return false;
            }
        }
    },
    'Water-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                UI.playVFX(def, 'water');
                const act = Common.applyDamage(atk, def, 0.9, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.3) {
                        def.addStatus('BLIND', 1, 0, atk);
                        game.log(" (ì‹¤ëª…!)");
                    }
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ â˜£ï¸`);
                AudioSys.play('HEAL');
                UI.playVFX(def, 'heal');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt);
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id !== atk.id) {
                        UI.playVFX(a, 'heal');
                        a.addStatus('EVADE', 2);
                    }
                });
                return false;
            }
        }
    },
    'Tree-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                UI.playVFX(def, 'heal');
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Balance] ìµœì € ì²´ë ¥ ì•„êµ°ì—ê²Œ ì‰´ë“œ 40 ë¶€ì—¬
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => (a.hp/a.maxHp) - (b.hp/b.maxHp))[0];
                    if (target) {
                        UI.playVFX(target, 'heal');
                        let sVal = 40;
                        if (target.hasStatus('EARTH_RECOIL')) sVal = Math.floor(sVal * 0.7);

                        target.shield += sVal;
                        game.recordStat(atk, 'shield', sVal);
                        UI.floatText(target, `+${sVal}ğŸ›¡ï¸`, "ft-heal");
                        Common.logAction(game, 'shield', atk, target, sVal, "(ë³´í˜¸)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    UI.playVFX(a, 'heal');
                    // [Balance] í ë¨¼ì € ì ìš© (ë°˜ë™/ì¹˜ìœ ê°ì†Œ ì ìš© í›„ ì •í™”)
                    a.heal(70);
                    a.cleanse(); 
                    Common.logAction(game, 'heal', atk, a, 70, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // [S1] ê°€ìŠ¤íƒ„ (ë‚˜ë¬´ ì €ê²© + í­ë°œ)
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                
                // 1. ë‚˜ë¬´(Tree) ë³´í˜¸ì í™•ì¸
                const allies = def.team === 0 ? game.pTeam : game.eTeam;
                const protector = allies.find(u => u.id !== def.id && !u.isDead && u.base === 'Tree' && u.hasStatus('ROOT_GUARD'));
                
                // 2. ì´ˆê¸° 3 ë°ë¯¸ì§€ (ê³µìš© ë¶„ì‚° ë¡œì§ ì‚¬ìš©!)
                // ì´ë ‡ê²Œ í•´ì•¼ ë‚˜ë¬´ê°€ ë¼ì–´ë“¤ì–´ ë°ë¯¸ì§€ë¥¼ ë‚˜ëˆ  ê°–ê³ , ë¡œê·¸ë„ ì •ìƒ ì¶œë ¥ë©ë‹ˆë‹¤.
                Common.distributeDamage(atk, def, 3, game, false, true); 
                
                // 3. í­ë°œ ëŒ€ìƒ ì„ ì • (ë³¸ì²´ + ë³´í˜¸ì)
                // ë³´í˜¸ìê°€ ìˆë‹¤ë©´ ë¬´ì¡°ê±´ ê°€ìŠ¤ ì „ì´ ëŒ€ìƒìœ¼ë¡œ í¬í•¨
                let targets = [def];
                if (protector) {
                    targets.push(protector);
                    game.log(`<span class="log-crit">â˜£ï¸ [${protector.name}] ê°€ìŠ¤ ì „ì´!</span>`);
                }

                // 4. ì—°ì‡„ í­ë°œ (ì¦‰ì‹œ ì‹¤í–‰ - ì˜¤ë¥˜ ë°©ì§€)
                targets.forEach((t) => {
                    if (t.isDead) return;

                    const isCC = t.hasStatus('STUN') || t.hasStatus('FREEZE') || t.hasStatus('SLEEP');
                    const mult = isCC ? 1.3 : 1.0;
                    
                    // ì‹œê° íš¨ê³¼ (ì¦‰ì‹œ ì¬ìƒ)
                    UI.playVFX(t, 'magic');
                    
                    // ë°ë¯¸ì§€ ì ìš©
                    const act = Common.applyDamage(atk, t, mult, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, t, act, isCC ? "(CCì¶”ê°€íƒ€)" : "(ê°€ìŠ¤í­ë°œ)");
                    }
                });
            } else { // [S2] ë§¹ë… ì‚´í¬
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    UI.playVFX(e, 'poison');
                    e.addStatus('POISON', 3, 0, atk);
                    // [Balance] í íš¨ìœ¨ 20% ê°ì†Œ
                    e.addStatus('HEAL_DOWN', 3, 20, atk); 
                });
                game.log("<span class='log-sys'>(ì „ì²´ ì¤‘ë… + ì¹˜ìœ íš¨ìœ¨ 20% ê°ì†Œ)</span>");
            }
        }
    },
    'Earth-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                UI.playVFX(def, 'rock');
                // 1. ì²´ë ¥ ì§ì ‘ íƒ€ê²© (ì‰´ë“œ ë¬´ì‹œ 1.3ë°°)
                const hpAct = Common.applyDamage(atk, def, 1.3, game, true);
                
                if (hpAct !== -1) { // ëª…ì¤‘í–ˆì„ ë•Œë§Œ ì‹¤í–‰
                    Common.logAction(game, 'dmg', atk, def, hpAct, "(ì‰´ë“œë¬´ì‹œ)");
                    
                    // 2. ì‰´ë“œ ì¶”ê°€ íƒ€ê²© (0.6ë°°)
                    if (def.shield > 0) {
                        const aff = game.calc(atk, def);
                        const shieldDmg = Math.floor(atk.getAtk() * 0.6 * aff.v);
                        def.shield = Math.max(0, def.shield - shieldDmg); // ì•ˆì „í•œ ì°¨ê° (HPë¡œ ì•ˆ ë„˜ì–´ê°)
                        UI.floatText(def, `-${shieldDmg}ğŸ›¡ï¸`, "ft-dmg");
                        game.log(`<span class='log-ally'>[ì¶”ê°€íƒ€]</span> ì‰´ë“œ íŒŒê´´ : -${shieldDmg}`);
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                UI.playVFX(def, 'vortex');
                // ì†ë°•(TRAP) ë¶€ì—¬
                def.addStatus('TRAP', 2, 60, atk); // ë°ë¯¸ì§€ 60 ëª…ì‹œ
                
                // [Fix] ì¹˜ìœ  ê°ì†Œ 50% ë¶€ì—¬ (ì •í™”ë˜ì§€ ì•ŠìŒ)
                def.addStatus('HEAL_DOWN', 2, 50, atk); 
                game.log("<span class='log-sys'>(ì¹˜ìœ íš¨ìœ¨ 50% ê°ì†Œ)</span>");
            }
        }
    },
    'Water-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                UI.playVFX(def, 'ice');
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Balance] ì…íŒ í”¼í•´ì˜ 20% ì‰´ë“œ íšë“ (íŒ¨ì‹œë¸Œ)
                    const shieldAmt = Math.floor(act * 0.2);
                    if (shieldAmt > 0) {
                        atk.shield += shieldAmt;
                        game.recordStat(atk, 'shield', shieldAmt);
                        UI.floatText(atk, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                UI.playVFX(def, 'magic');
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                // [Balance] íŒ¨ì‹œë¸Œ(ìê°€ í™”ìƒ) ì‚­ì œë¨
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                UI.playVFX(def, 'fire');
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => {
                        UI.playVFX(e, 'fire');
                        e.addStatus('BURN', 2, 0, atk);
                    });
                }
            } else {
                // [Balance] íŒ¨ì‹œë¸Œ(ìê°€ í™”ìƒ) ì‚­ì œë¨
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                UI.playVFX(def, 'fire');
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    // [Balance] ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€ ë°ë¯¸ì§€
                    const extra = def.getAtk();
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act + extra, "(ê³µê²©ë ¥ë¹„ë¡€)");
                } else {
                    Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                UI.playVFX(def, 'vortex');
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                UI.playVFX(def, 'magic');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                UI.playVFX(def, 'lightning'); // âš¡ ë²ˆê°œ ì´í™íŠ¸
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (atk.elecStacks < 3) {
                        atk.elecStacks++;
                        atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    UI.playVFX(e, 'lightning'); // [Fix] def -> e (ê° ì ì—ê²Œ ê°œë³„ ë²ˆê°œ)
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                UI.playVFX(def, 'rock'); // [ì´í™íŠ¸] ëŒë©ì´ ì¿µ
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                UI.playVFX(def, 'rock'); // [ì´í™íŠ¸] ê°•ë ¥í•œ ë°”ìœ„
                
                // 2.35ë°° ë°ë¯¸ì§€ + ë°˜ë™ ë¡œì§ ìœ ì§€
                const act = Common.applyDamage(atk, def, 2.35, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                
                // [Balance] ë©´ì—­ ì œê±°
                if (atk.hasStatus('IMMUNITY')) {
                    atk.status = atk.status.filter(s => s.type !== 'IMMUNITY');
                    UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss");
                }

                // ê¸°ì ˆ ë¶€ì—¬ (2í„´)
                const ex = atk.status.find(s => s.type === 'STUN');
                if (ex) ex.turn = 2;
                else atk.status.push({ type: 'STUN', turn: 2, val: 0 });

                // ë°˜ë™ ë¶€ì—¬ (ë°›ëŠ” í”¼í•´ 15 ì¦ê°€, 2í„´)
                const recoil = atk.status.find(s => s.type === 'EARTH_RECOIL');
                if (recoil) recoil.turn = 2;
                else atk.status.push({ type: 'EARTH_RECOIL', turn: 2, val: 15 });

                UI.floatText(atk, "ğŸ’¤íœ´ì‹+ë°˜ë™", "ft-miss");
                game.log("(ë°˜ë™: ê¸°ì ˆ + ë°›ëŠ”ë°ë¯¸ì§€ ì¦ê°€)");
            }
        }
    },
    'Light-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                UI.playVFX(def, 'magic');
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    UI.playVFX(a, 'heal');
                    // [Balance] ë°˜ë™ ìƒíƒœ ëŒ€ìƒì€ ì‹¤ë“œ íšë“ 30% ê°ì†Œ
                    let sVal = 50;
                    if (a.hasStatus('EARTH_RECOIL')) sVal = Math.floor(sVal * 0.7);

                    a.shield += sVal;
                    a.cleanse(); // ì •í™”ëŠ” ê·¸ëŒ€ë¡œ ìˆ˜í–‰ (ë°˜ë™ì€ ì •í™”ë¶ˆê°€ ì†ì„±ì´ë¯€ë¡œ ì•ˆ ì§€ì›Œì§)
                    game.recordStat(atk, 'shield', sVal);
                    Common.logAction(game, 'shield', atk, a, sVal, "(ì •í™”)");
                });
                return false;
            }
        }
    },
'Dark-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`);
                UI.playVFX(def, 'vortex');
                const act = Common.applyDamage(atk, def, 0.8, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                // ì„¸ë‡Œ ìŠ¤í‚¬
                game.log(`<b>[${atk.name}]</b> ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ ğŸ§ `);
        
                // [ì œì•½ 1] ì´ë¯¸ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
                if (game.isMindControlling) {
                    game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                    UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                    return;
                }
                
                // [ì œì•½ 2] ë©´ì—­ ì²´í¬
                if (def.getKey() === 'Dark-Dark' || def.hasStatus('IMMUNITY') || (def.isNormal && !def.extra)) {
                    game.log("<span class='log-sys'>ğŸš« ì •ì‹  ì§€ë°°ê°€ í†µí•˜ì§€ ì•ŠëŠ” ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                    UI.floatText(def, "ë©´ì—­", "ft-miss");
                    return;
                }

                // 1. ì½”ìŠ¤íŠ¸ ì§€ë¶ˆ
                const cost = Math.floor(atk.hp * 0.12);
                atk.hp = Math.max(1, atk.hp - cost);
                UI.floatText(atk, `HPì†Œëª¨(-${cost})`, "ft-miss");
                
                // 2. í™•ë¥  ê³„ì‚°
                const missingPct = 1.0 - (def.hp / def.maxHp);
                let chance = 0.30 + (missingPct * 0.25);
                
                // ğŸŸ¢ [ìˆ˜ì •ë¨] ì±Œë¦°ì§€ ëª¨ë“œ(hell ë‚œì´ë„) + 'ì êµ°(Team 1)'ì¼ ë•Œë§Œ 100% ì ìš©
            if (game.difficulty === 'hell' && atk.team === 1) {
                chance = 1.00;
                game.log("<span class='log-sys' style='color:#ff5252;'>âš ï¸ [BOSS] ì ì˜ ì •ì‹ ì§€ë°° í™•ë¥ ì´ ëŒ€í­ ìƒìŠ¹í•©ë‹ˆë‹¤! (100%)</span>");
            }

                // 3. ì„±ê³µ/ì‹¤íŒ¨ íŒì •
                if (game.netRandom() < chance) {
                    UI.playVFX(def, 'mc-wave'); // ğŸ§  ì •ì‹ ì§€ë°° íŒŒë™
                    def.addStatus('MC_WAIT', 1, 0, atk, true); 
                    game.log(` ğŸŒ€ <b>[${def.name}]</b> ì •ì‹  ì§€ë°° ì‹œì‘! (1í„´ í›„ ìŠ¤í‚µ, ê·¸ ë‹¤ìŒ ì¡°ì¢…)`);
                    UI.floatText(def, "ì„¸ë‡Œ ëŒ€ê¸°", "ft-crit");
                    AudioSys.play('DEBUFF');
                } else {
                    game.log(" (ì •ì‹ ë ¥ìœ¼ë¡œ ì €í•­í–ˆìŠµë‹ˆë‹¤!)");
                    UI.floatText(def, "ì €í•­", "ft-miss");
                }
            }
        }
    }
}; // SKILL_LOGIC ë

class Unit {
    constructor(id, team, base, extra) {
        this.id = id;
        this.team = team;
        this.base = base;
        this.extra = extra;
        // [Balance] ê¸°ë³¸ ì²´ë ¥ +100 ìƒí–¥ (ì „íˆ¬ í˜¸í¡ ì¡°ì ˆ)
        this.maxHp = 700;
        // ê°€ì‹œ(Tree-Dark)ëŠ” íƒ±ì»¤í˜• ë”œëŸ¬ë¼ ë” ë†’ê²Œ ìœ ì§€ (+100 ì°¨ì´)
        if (base === 'Tree' && extra === 'Dark') this.maxHp = 800;
        // í‘¸ë¥¸ë¶ˆ(Fire-Light)ì€ ì„œë¸Œ íƒ±ì»¤ë¼ ì•½ê°„ ë†’ê²Œ ìœ ì§€ (+50 ì°¨ì´)
        if (base === 'Fire' && extra === 'Light') this.maxHp = 750;
        // [Balance] ë¶ˆ(Fire) ê¸°ë³¸ ì²´ë ¥ 50 ë„ˆí”„ (ìœ ë¦¬ëŒ€í¬ í™”)
        if (base === 'Fire' && !extra) this.maxHp = 650;
        this.hp = this.maxHp;
        this.evadeTriggered = false;
        this.revengeAtk = 0;
        this.shield = (base === 'Metal' && !extra) ? 100 : 0;

        if (this.team === 1 && typeof Game !== 'undefined' && (Game.difficulty === 'hell' || Game.difficulty === 'hard')) {
            this.atk = 70;
        } else {
            this.atk = 55 + (id * 7 % 15);
        }

        this.status = [];
        this.isDead = false;
        this.thornStack = 0;
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.growthStack = 0;
        this.treeStack = 0; // [Tree] íŒ¨ì‹œë¸Œ ìŠ¤íƒ (0~2)
        this.resist = 0;
        this.stats = {
            dmg: 0,
            heal: 0,
            shieldGiven: 0,
            taken: 0,
            kills: 0
        };
        this.isSuper = false;
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base === 'Light' && this.extra === 'Dark') || (this.base === 'Dark' && this.extra === 'Light');
        this.isEnhanced = (this.base === this.extra && (this.base === 'Light' || this.base === 'Dark'));

        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() {
        if (this.isNormal) return 'Normal';
        if (this.isEnhanced) return `${this.base}-${this.extra}`;
        return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base;
    }

    checkAwakening() {
        // [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ëª¨ë“œì—ì„œëŠ” ê°ì„± ë°œë™ ê¸ˆì§€ (ë„ê° ì˜¤ì—¼ ë°©ì§€)
        if (typeof Game !== 'undefined' && Game.difficulty === 'tutorial') return;

        if (this.isSuper) return;
        let trigger = false;
        // [Balance] ì‰´ë“œ ìµœëŒ€ëŸ‰ 400ìœ¼ë¡œ ì œí•œ
        if (this.shield > 400) this.shield = 400;

        if (this.isSuper) return;
        const key = this.getKey();
        const role = SKILL_DB[key].role;
        let awakened = false;
        if (role === 'nuker') {
            if (this.stats.kills >= 2 || this.stats.dmg >= 1500) awakened = true;
        } else if (role === 'tank') {
            if (this.stats.taken >= 1000) awakened = true;
        } else if (role === 'supp') {
            if ((this.stats.heal + this.stats.shieldGiven) >= 1000) awakened = true;
        }
if (awakened) {
            this.isSuper = true;
            
            // [Modified] Emotion Awakening Logic
            const emo = EMOTION_DB[key];
            if (emo) {
                const isNew = TitleManager.unlock(key);
                const titleText = `[${emo.t}] Awakened!`;
                UI.floatText(this, titleText, "ft-crit");
                
                if (isNew) {
                    setTimeout(() => {
                        Game.log(`<span class="log-crit" style="color:#d500f9;">ğŸ† New Title Unlocked: [${emo.t}]</span>`);
                        // ì•Œë¦¼ ë©”ì‹œì§€ëŠ” í•œ ë²ˆë§Œ
                        const bubble = document.createElement('div');
                        bubble.style.cssText = "position:fixed; top:20%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.8); color:#fff; padding:15px 25px; border-radius:30px; z-index:9999; font-size:18px; box-shadow:0 5px 15px rgba(0,0,0,0.3); animation:floatUp 2s forwards;";
                        bubble.innerHTML = `ğŸ’ New Emotion: <b>${emo.t}</b><br><span style='font-size:12px; color:#aaa;'>${emo.d}</span>`;
                        document.body.appendChild(bubble);
                        setTimeout(() => bubble.remove(), 2500);
                    }, 500);
                }
            } else {
                UI.floatText(this, "âš¡AWAKENING!!âš¡", "ft-crit");
            }

            AudioSys.play('AWAKEN');
            Game.render();
        }
    }

    getAtk() {
        let v = this.atk;
        if (this.base === 'Fire' && !this.extra) {
            // [ìˆ˜ì •] í„´(í–‰ë™ìˆ˜) ëŒ€ì‹  ë¼ìš´ë“œ(ì‚¬ì´í´) ê¸°ì¤€ ì ìš©
            const r = (typeof Game !== 'undefined' && Game.globalRound) ? Game.globalRound : 1;
            
            if (r <= 2) v += 15;      // 1~2ë¼ìš´ë“œ (ì´ˆë°˜)
            else if (r <= 6) v += 10; // 3~6ë¼ìš´ë“œ (ì¤‘ë°˜)
            else v += 5;              // 7ë¼ìš´ë“œ ì´í›„ (í›„ë°˜)
        }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        const lightMight = this.status.find(s => s.type === 'LIGHT_MIGHT');
        if (lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        if (this.hasStatus('ATK_BUFF_SMALL')) v += 10;

        // [ì‹ ê·œ] ë°ë¯¸ì§€ 10% ì¦ê°€ ë²„í”„ ì ìš© (ìµœì¢… ê³±ì—°ì‚°)
        if (this.hasStatus('DMG_UP_10')) v = Math.floor(v * 1.1);
        
        v = Math.max(10, v);
        const ads = this.status.filter(s => s.type === 'ATK_DOWN');
        if (ads.length > 0) {
            ads.forEach(s => {
                if (s.val > 0) v -= Math.floor(v * (s.val / 100));
                else v -= 15;
            });
        }
        return Math.max(0, v);
    }

    resetTurn() {
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
    }

    takeDamage(dmg, isFire = false, ignoreShield = false, source = null) {
        // [Tree íŒ¨ì‹œë¸Œ] ê±°ëª©: ê¸°ë³¸ 15% ë€ê° + ìŠ¤íƒë‹¹ 5% (ìµœëŒ€ 25%)
        if (this.base === 'Tree' && !this.extra) {
            const reducePct = 0.15 + (this.treeStack * 0.05);
            dmg = Math.floor(dmg * (1.0 - reducePct));
        }

        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);

        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            // [Balance] íŒ¨ì‹œë¸Œ ë°œë™ ì¡°ê±´ ì™„í™” (MaxHP 30% -> 20%)
            const cap = Math.floor(this.maxHp * 0.20);
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal");
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) {
            if (Game.netRandom() < 0.40) {
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                this.status = this.status.filter(s => s.type !== 'EVADE');
                return -1;
            }
        }
        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            if (karma && !isDarkVsDark) {
                const reflectDmg = Math.floor(dmg * 0.3);
                if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null);
                    this.stats.dmg += actualReflect;
                    UI.floatText(source, reflectDmg, "ft-crit");
                }
            }
        }

        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) {
            if (this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg;
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield;
                this.shield = 0;
            }
        } else {
            hpDmg = dmg;
        }
        if (hpDmg > 0 && this.hasStatus('EARTH_RECOIL')) {
            hpDmg += 15;
            this.stats.taken += 15;
            UI.floatText(this, "Crack(+15)", "ft-crit");
        }
        this.hp = Math.max(0, this.hp - hpDmg);

        if (this.hp <= 0 && source) {
            source.stats.kills = (source.stats.kills || 0) + 1;
            if (source.isSuper && !source.isDead) {
                const allies = source.team === 0 ? Game.pTeam : Game.eTeam;
                const aliveAllies = allies.filter(a => !a.isDead);
                if (aliveAllies.length === 1 && aliveAllies[0].id === source.id) {
                    UI.showCutIn(source);
                }
            }
            if (source.checkAwakening) source.checkAwakening();
        }

        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.evadeTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        this.checkAwakening();

        // [Fix] HPê°€ 0 ì´í•˜ë©´ ì¦‰ì‹œ ì‚¬ë§ ì²˜ë¦¬ (ë°˜ì‚¬ ë°ë¯¸ì§€ ì¢€ë¹„í™” ë°©ì§€)
        if (this.hp <= 0 && !this.isDead) {
            if (typeof Game !== 'undefined' && Game.die) {
                Game.die(this);
            }
        }
        
        // [ê°œì„ ] ì¹´ë“œ í”ë“¤ë¦¼ íš¨ê³¼ ì ìš© (ë„íŠ¸ ë°ë¯¸ì§€ ì œì™¸)
        if (source && hpDmg > 0 && typeof UI !== 'undefined' && UI.shakeCard) {
            UI.shakeCard(this, hpDmg + shieldDmg);
        }

        return hpDmg + shieldDmg;
    }

    addStatus(type, turn, val = 0, source = null, force = false) {
        const CC_LIST = ['STUN', 'FREEZE', 'BANISH', 'SILENCE', 'SLEEP'];
        
        // 1. ì„ ê³µ ë°©ì–´ë§‰ ì²´í¬
        if (this.hasStatus('START_IMMUNITY') && !force) {
            if (CC_LIST.includes(type) || type.startsWith('PROVOKED')) { 
                UI.floatText(this, "ğŸ›¡ï¸CCë°©ì–´", "ft-miss");
                return;
            }
        }

        // 2. ì—…ë³´(Karma) ë°˜ì‚¬ ì²´í¬
        if (source && source.id !== this.id && !force) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            const isPuppet = (this.hasStatus('MC_READY') || (Game.isMindControlling && Game.isMindControlling.id === this.id));
            
            if (karma && !isDarkVsDark && !isPuppet) {
                if (Game.netRandom() < 0.5) {
                    UI.floatText(this, "ë°˜ì‚¬!", "ft-crit");
                    Game.log(`<span class='log-crit'>ğŸ‘ï¸ [${this.name}]ì˜ ì—…ë³´ ë°œë™! [${source.name}]ì—ê²Œ ${type} ë°˜ì‚¬</span>`);
                    source.addStatus(type, turn, val, null, true);
                    return;
                }
            }
        }

        // 3. ë…¸ë§ ë©´ì—­ ì²´í¬
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE'];
        if (this.isNormal && !force && NORMAL_IMMUNE.includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }

        // ğŸ”¥ 4. ì¤‘ì²© ê°€ëŠ¥ ìƒíƒœì´ìƒ(ê³µê²©/ì¹˜ìœ  ê°ì†Œ) ìµœìš°ì„  ì²˜ë¦¬
        if (type === 'ATK_DOWN' || type === 'HEAL_DOWN') {
            const s = this.status.filter(s => s.type === type);
            if (s.length < 2) {
                this.status.push({ type, turn, val, sourceId: source ? source.id : -1 });
            } else {
                const shortest = s.sort((a, b) => a.turn - b.turn)[0];
                shortest.turn = turn;
                shortest.val = val; 
                if (source) shortest.sourceId = source.id;
            }
            return;
        }

        // 5. ê·¸ ì™¸ ì¼ë°˜ ìƒíƒœì´ìƒ (ì¤‘ë³µ ì‹œ ë®ì–´ì“°ê¸°/ê°±ì‹ )
        const existing = this.status.find(s => s.type === type);
        if (existing && !force) {
            if (turn > existing.turn) {
                existing.turn = turn;
                existing.val = val;
                existing.sourceId = source?.id;
            }
            return;
        }
        
        // 6. ìƒí˜¸ ë°°íƒ€ì  ìƒíƒœì´ìƒ ì œê±°
        const MUTUALLY_EXCLUSIVE = {
            'STUN': ['FREEZE', 'BANISH', 'SLEEP'],
            'FREEZE': ['STUN', 'BANISH', 'SLEEP'],
            'BANISH': ['STUN', 'FREEZE', 'SLEEP'],
            'SLEEP': ['STUN', 'FREEZE', 'BANISH']
        };
        
        if (MUTUALLY_EXCLUSIVE[type]) {
            const removed = [];
            MUTUALLY_EXCLUSIVE[type].forEach(conflictType => {
                const conflict = this.status.find(s => s.type === conflictType);
                if (conflict) {
                    removed.push(conflictType);
                    this.status = this.status.filter(s => s.type !== conflictType);
                }
            });
            if (removed.length > 0) {
                Game.log(`<span class='log-sys'>[${this.name}] ${removed.join(', ')} ìƒíƒœê°€ ${type}ìœ¼ë¡œ ëŒ€ì²´ë¨</span>`);
            }
        }
        
        // 7. íšŒí”¼ ì²´í¬
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return;
                }
            }
        }

        // 8. ë„ë°œ ë° ê¸°íƒ€ ë©´ì—­
        if (this.isNormal && !force && type.startsWith('PROVOKED')) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH', 'SLEEP'];
     if (HARD_CC.includes(type)) {
         if (this.hasStatus('IMMUNITY') && !force) {
             UI.floatText(this, "ë©´ì—­", "ft-miss");
             return;
         }

         // [ì‹ ê·œ] ì‹œì „ìê°€ í–‰ë™ ë¶ˆê°€(CC) ìƒíƒœê°€ ë˜ë©´ ì •ì‹  ì§€ë°° ì¦‰ì‹œ í•´ì œ
         if (typeof Game !== 'undefined' && Game.currentMCCasterId === this.id) {
              // í˜„ì¬ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒ ì°¾ê¸°
              const puppet = Game.isMindControlling || [...Game.pTeam, ...Game.eTeam].find(u => u.hasStatus('MC_WAIT') && u.status.find(s=>s.type==='MC_WAIT').sourceId === this.id);

              if (puppet) {
                  Game.log(`<span class='log-sys'>ğŸ’« ì‹œì „ì([${this.name}])ê°€ ë¬´ë ¥í™”ë˜ì–´ ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤!</span>`);
                  UI.floatText(this, "ì •ì‹ ë¶•ê´´", "ft-crit");

                  // ì„¸ë‡Œ ê´€ë ¨ ìƒíƒœ(ëŒ€ê¸°/ì¤€ë¹„) ëª¨ë‘ ì œê±°
                  puppet.status = puppet.status.filter(s => s.type !== 'MC_READY' && s.type !== 'MC_WAIT');

                  // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” (í˜„ì¬ ì¡°ì¢… ì¤‘ì´ì—ˆë‹¤ë©´ ì œì–´ê¶Œ ë°˜í™˜)
                  if (Game.isMindControlling && Game.isMindControlling.id === puppet.id) {
                      Game.isMindControlling = null;
                      Game.currentMCCasterId = null;

                      // UI ë³µêµ¬ (í…Œë‘ë¦¬ ìƒ‰ìƒ ì´ˆê¸°í™”)
                      const cp = document.querySelector('.control-panel');
                      if(cp) cp.style.borderTop = "5px solid #ccc"; 
                  }
              }
         }

         if (!source || source.id !== this.id || force) {
             this.status.push({
                 type: 'IMMUNITY',
                 turn: turn + 1
             });
         }
     }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'HEAL_DOWN'].includes(type)) return;
        
        // 9. ìµœì¢… ë“±ë¡
        this.status.push({
            type,
            turn,
            val,
            sourceId: source ? source.id : -1
        });
    }
    hasStatus(type) {
        return this.status.some(s => s.type === type);
    }
    cleanse() {
        const bad = ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'KARMA_VICTIM'];
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM'));
    }
    dispel() {
        const buffs = ['EVADE', 'DMG_RED', 'ATK_BUFF', 'GROWTH', 'LIGHT_MIGHT'];
        const has = this.status.some(s => buffs.includes(s.type));
        this.status = this.status.filter(s => !buffs.includes(s.type));
        return has;
    }

    tickStatus() {
        let log = [];
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const findSource = (id) => allUnits.find(u => u.id === id) || null;

        // 1. ë… (Poison)
        const poison = this.status.find(s => s.type === 'POISON');
        if (poison) {
            const src = findSource(poison.sourceId);
            const d = this.takeDamage(35, false, false, src); // í‚¬ ë¡œê·¸ë¥¼ ìœ„í•´ src ì „ë‹¬
            if (src) Game.recordStat(src, 'dmg', d);          // í†µê³„ ê¸°ë¡
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`);
        }

        // 2. í™”ìƒ (Burn)
        const burn = this.status.find(s => s.type === 'BURN');
        if (burn) {
            const src = findSource(burn.sourceId);
            const d = this.takeDamage(20, false, false, src);
            if (src) Game.recordStat(src, 'dmg', d);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`);
        }

        // 3. ëª¨ë˜ì§€ì˜¥ (Trap)
        const trap = this.status.find(s => s.type === 'TRAP');
        if (trap) {
            const src = findSource(trap.sourceId);
            // [Balance] ì†ë°• ë°ë¯¸ì§€ 40 -> 60 ìƒí–¥ ìœ ì§€
            const d = this.takeDamage(60, false, false, src);
            if (src) Game.recordStat(src, 'dmg', d);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`);
        }
        return log;
    }
    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    heal(amount) {
        // [ìˆ˜ì •] ì¹˜ìœ  ê°ì†Œ ë° ë°˜ë™ ë¡œì§ í†µí•©
        let totalReduction = 0;
        
        // 1. ê¸°ì¡´ ì¹˜ìœ  ê°ì†Œ(HEAL_DOWN)
        const healDebuffs = this.status.filter(s => s.type === 'HEAL_DOWN');
        if (healDebuffs.length > 0) {
            totalReduction += healDebuffs.reduce((sum, s) => sum + (s.val || 0), 0);
        }

        // 2. ë°˜ë™(EARTH_RECOIL) ìƒíƒœ: ì¹˜ìœ ëŸ‰ 30% ì¶”ê°€ ê°ì†Œ
        if (this.hasStatus('EARTH_RECOIL')) {
            totalReduction += 30;
            UI.floatText(this, "ë°˜ë™(ì¹˜ìœ â†“)", "ft-miss");
        }

        // ìµœì¢… ê°ì†Œ ì ìš©
        if (totalReduction > 0) {
            const originalAmount = amount;
            const multiplier = Math.max(0, (100 - totalReduction) / 100);
            amount = Math.floor(amount * multiplier);

            // [ë””ë²„ê·¸ ë¡œê·¸]
            console.log(`ğŸ’‰ [Healing] ${this.name}: ${originalAmount} -> ${amount} (ê°ì†Œìœ¨: ${totalReduction}%)`);
            
            if (amount === 0 && originalAmount > 0) {
                UI.floatText(this, "ì¹˜ìœ ì°¨ë‹¨", "ft-miss");
            }
        }

        const prev = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + amount);
        const diff = this.hp - prev;
        if (diff > 0) {
            UI.floatText(this, diff, 'ft-heal');
        }
        this.checkAwakening();
        return diff;
    }
}

const AudioSys = {
    ctx: null,
    bgmVol: 0.5, // ë°°ê²½ìŒì•… ë³¼ë¥¨
    sfxVol: 0.5, // íš¨ê³¼ìŒ ë³¼ë¥¨
    bgmMuted: false,
    sfxMuted: false,

    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.loadSettings(); // [í•µì‹¬] ì €ì¥ëœ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    resume: function() {
        this.init();
    },

    // [ì‹ ê·œ] ì„¤ì • ì €ì¥ (ë³¼ë¥¨ ì¡°ì ˆ/í† ê¸€ ì‹œ í˜¸ì¶œ)
    saveSettings: function() {
        const data = {
            bgmVol: this.bgmVol,
            sfxVol: this.sfxVol,
            bgmMuted: this.bgmMuted,
            sfxMuted: this.sfxMuted
        };
        localStorage.setItem('et_audio_settings', JSON.stringify(data));
    },

    // [ì‹ ê·œ] ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° (initì—ì„œ í˜¸ì¶œ)
    loadSettings: function() {
        const saved = localStorage.getItem('et_audio_settings');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                // ë°ì´í„° ë¡œë“œ
                if(data.bgmVol !== undefined) this.bgmVol = data.bgmVol;
                if(data.sfxVol !== undefined) this.sfxVol = data.sfxVol;
                if(data.bgmMuted !== undefined) this.bgmMuted = data.bgmMuted;
                if(data.sfxMuted !== undefined) this.sfxMuted = data.sfxMuted;

                // UI(ìŠ¬ë¼ì´ë”) ê°•ì œ ë™ê¸°í™”
                setTimeout(() => {
                    const bgmSlider = document.querySelector('input[oninput*="setBgmVolume"]');
                    if(bgmSlider) bgmSlider.value = this.bgmVol * 100;

                    const sfxSlider = document.querySelector('input[oninput*="setSfxVolume"]');
                    if(sfxSlider) sfxSlider.value = this.sfxVol * 100;

                    const bgmBtn = document.getElementById('tog-bgm');
                    if(bgmBtn) {
                        if (this.bgmMuted) bgmBtn.classList.remove('on');
                        else bgmBtn.classList.add('on');
                    }

                    const sfxBtn = document.getElementById('tog-sfx');
                    if(sfxBtn) {
                        if (this.sfxMuted) sfxBtn.classList.remove('on');
                        else sfxBtn.classList.add('on');
                    }
                }, 100); // DOM ë Œë”ë§ í›„ ì ìš©

            } catch (e) { console.error("ì„¤ì • ë¡œë“œ ì‹¤íŒ¨", e); }
        }
    },

    // [ì‹ ê·œ] BGM ë³¼ë¥¨ ì¡°ì ˆ
    setBgmVolume: function(val) {
        this.bgmVol = val / 100;
        if (MusicEngine && MusicEngine.currentAudio) {
            MusicEngine.currentAudio.volume = this.bgmVol;
        }
        this.saveSettings(); // ë³€ê²½ ì¦‰ì‹œ ì €ì¥
    },

    // [ì‹ ê·œ] SFX ë³¼ë¥¨ ì¡°ì ˆ
    setSfxVolume: function(val) {
        this.sfxVol = val / 100;
        this.saveSettings(); // ë³€ê²½ ì¦‰ì‹œ ì €ì¥
    },

    toggleChannel: function(type) {
        if (type === 'bgm') {
            this.bgmMuted = !this.bgmMuted;
            document.getElementById('tog-bgm').classList.toggle('on');

            if(this.bgmMuted) {
                MusicEngine.stop();
            } else {
                if (MusicEngine.currentAudio && MusicEngine.currentAudio.paused) {
                    MusicEngine.currentAudio.play();
                } else {
                    MusicEngine.play('Start'); 
                }
            }
        } else {
            this.sfxMuted = !this.sfxMuted;
            document.getElementById('tog-sfx').classList.toggle('on');
        }
        this.saveSettings(); // ìƒíƒœ ë³€ê²½ ì €ì¥
    },

    playTone: function(freq, type, duration, vol, detune = 0, isBGM = false) {
        if (!this.ctx) return;
        if (isBGM && this.bgmMuted) return;
        if (!isBGM && this.sfxMuted) return;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.value = freq;
        if (detune !== 0) osc.detune.value = detune;

        // [ìˆ˜ì •] íš¨ê³¼ìŒ ì¦í­ ë¡œì§ ì¶”ê°€
        let baseVol = isBGM ? this.bgmVol : this.sfxVol;

        // âš¡ [ì¦í­] íš¨ê³¼ìŒ(SFX)ì´ë¼ë©´ 2.5ë°° ë” í¬ê²Œ ì¶œë ¥
        if (!isBGM) {
            baseVol *= 2.5; 
        }

        // ìµœì¢… ë³¼ë¥¨ ê³„ì‚° (ë„ˆë¬´ ì»¤ì„œ ì°¢ì–´ì§€ì§€ ì•Šê²Œ ìµœëŒ€ 1.0ìœ¼ë¡œ ì œí•œ ì•ˆì „ì¥ì¹˜)
        let finalVol = vol * baseVol;
        if (finalVol > 1.0) finalVol = 1.0; 

        gain.gain.setValueAtTime(0, t);
        // íƒ€ê²©ê°ì„ ìœ„í•´ 0.02ì´ˆë§Œì— ë¹ ë¥´ê²Œ ìµœê³  ë³¼ë¥¨ ë„ë‹¬ (ê¸°ì¡´ 0.05ë³´ë‹¤ ë¹ ë¦„)
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration + 0.1);
    },

    play: function(type) {
        if (this.sfxMuted) return;
        this.init();
        switch (type) {
            case 'HIT': this.playTone(150, 'square', 0.1, 0.2); break;
            case 'CRITICAL': 
                this.playTone(800, 'sawtooth', 0.2, 0.3); 
                setTimeout(()=>this.playTone(1200, 'square', 0.1, 0.2), 50);
                break;
            case 'SKILL': this.playTone(400, 'sine', 0.3, 0.2); break;
            case 'HEAL': 
                this.playTone(600, 'sine', 0.15, 0.2);
                setTimeout(()=>this.playTone(800, 'sine', 0.3, 0.2), 150);
                break;
            case 'DEBUFF': this.playTone(300, 'sawtooth', 0.3, 0.15); break;
            case 'POWER_UP':
                this.playTone(300, 'square', 0.1, 0.15);
                setTimeout(()=>this.playTone(450, 'square', 0.1, 0.15), 100);
                break;
            case 'WIN': 
                [0,200,400,600].forEach((d,i)=> setTimeout(()=>this.playTone(523+(i*100),'triangle',0.3,0.3), d));
                break;
            case 'CUTIN': this.playTone(100, 'sawtooth', 0.8, 0.4); break;
            case 'AWAKEN': this.playTone(200, 'square', 0.5, 0.3); break;
        }
    },
    speak: function(unit) {
        if(this.sfxMuted) return;
        this.init();
        const base = 400 + (unit.id*50);
        for(let i=0; i<2; i++) {
            setTimeout(()=> this.playTone(base+(Math.random()*100-50), 'triangle', 0.08, 0.15), i*80);
        }
    }
};

// ==========================================
// ğŸ¹ Music Engine (Hybrid: MP3 File + Synth Fallback)
// ==========================================
const MusicEngine = {
    mode: 'FILE', // 'FILE'(MP3) or 'SYNTH'(ì „ììŒ ì•ˆì „ëª¨ë“œ)
    ctx: null, 
    isPlaying: false, 
    currentAudio: null, // HTMLAudioElement
    wasPlayingBeforeHide: false, // [Fix] ë°±ê·¸ë¼ìš´ë“œ ì¬ìƒ ìƒíƒœ ì¶”ì  ë³€ìˆ˜ ì´ˆê¸°í™”

    // [Synth Fallback Data] íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì‚¬ìš©í•  ìºë…¼ ë°ì´í„°
    canon: {
        melody: [587, 554, 494, 440, 392, 370, 392, 440, 587, 0, 494, 0, 494, 554, 587, 659, 740, 587, 659, 587, 554, 494, 554, 440, 392, 440, 494, 554, 370, 440, 494, 554],
        bass:   [293, 0, 220, 0, 246, 0, 185, 0, 196, 0, 293, 0, 196, 0, 220, 0, 293, 220, 246, 293, 185, 246, 196, 220, 196, 220, 293, 220, 293, 370, 440, 554],
        step: 0
    },
    timeoutId: null, 
    bgmOscillators: [],

    init: () => {
        if (!MusicEngine.ctx) { MusicEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (MusicEngine.ctx.state === 'suspended') MusicEngine.ctx.resume();
    },

    // [í•µì‹¬] ì¬ìƒ í•¨ìˆ˜
    play: (trackName) => {
        MusicEngine.init(); 
        MusicEngine.stop(); // ê¸°ì¡´ ê³¡ ì •ì§€
        MusicEngine.isPlaying = true;

        // [New] ì—”ë”© BGM íŠ¹ìˆ˜ ì²˜ë¦¬: ì„±ê³µ ì‹œì—ë§Œ ê¸°ì¡´ BGM ì •ì§€ (ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ BGM ìœ ì§€)
 if (trackName === 'ending') {
     let filename = "ending.mp3";
     const newAudio = new Audio(filename);
     if (typeof AudioSys !== 'undefined') newAudio.volume = AudioSys.bgmVol;

     // ê¸°ì¡´ ê³¡ì„ ë„ì§€ ì•Šê³  ë¨¼ì € ì¬ìƒ ì‹œë„
     const playPromise = newAudio.play();
     if (playPromise !== undefined) {
         playPromise.then(() => {
             console.log("ğŸµ Ending BGM started. Stopping previous track.");
             MusicEngine.stop(); // ì¬ìƒ ì„±ê³µ í™•ì¸ í›„ ê¸°ì¡´ BGM ì •ì§€

             MusicEngine.isPlaying = true;
             MusicEngine.currentAudio = newAudio;
             // ì—”ë”©ì€ ë°˜ë³µ/ëœë¤ ì¬ìƒ í•˜ì§€ ì•ŠìŒ
         }).catch(e => {
             console.warn("âš ï¸ Ending BGM failed (Missing/Blocked). Keeping offline BGM.", e);
             // ì‹¤íŒ¨ ì‹œ stop()ì„ í˜¸ì¶œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ê¸°ì¡´ BGMì´ ê³„ì† ë‚˜ì˜´
         });
     }
     return;
 }

 // [ì¼ë°˜ ë¡œì§] ê¸°ì¡´ BGM ì¦‰ì‹œ ì •ì§€ í›„ ì¬ìƒ
 MusicEngine.stop(); 
 MusicEngine.isPlaying = true;

 // 1. ì•ˆì „ ëª¨ë“œ(Synth)
 if (MusicEngine.mode === 'SYNTH') {
     MusicEngine.canon.step = 0;
     MusicEngine.loopCanon();
     return;
 }

 // 2. MP3 íŒŒì¼ ëª¨ë“œ
 let filename = trackName;
 if (!filename.toLowerCase().endsWith('.mp3')) filename += ".mp3";

 MusicEngine.currentAudio = new Audio(filename);
 if (typeof AudioSys !== 'undefined') MusicEngine.currentAudio.volume = AudioSys.bgmVol;

 MusicEngine.currentAudio.onended = () => {
     MusicEngine.playRandom();
 };

 MusicEngine.currentAudio.onerror = (e) => {
     console.warn(`âš ï¸ [MusicEngine] Failed to load "${filename}". Switching to SYNTH mode.`);
     MusicEngine.mode = 'SYNTH'; 
     MusicEngine.currentAudio = null;
     MusicEngine.play('Canon_Piano'); 
 };

 MusicEngine.currentAudio.play().catch(e => {
     console.error("ğŸš« Autoplay blocked:", e);
 });
    },

    // [ëœë¤ ì¬ìƒ] Start ì œì™¸í•œ ë‚˜ë¨¸ì§€ ê³¡ ì¤‘ ì„ íƒ
    playRandom: () => {
        // [Update] Trip ì¶”ê°€
        const playlist = ['Calm', 'Groove', 'Surprise', 'Duck_step', 'Trip'];
        const nextTrack = playlist[Math.floor(Math.random() * playlist.length)];
        MusicEngine.play(nextTrack);
    },

    stop: () => {
        MusicEngine.isPlaying = false;

        // MP3 ì •ì§€
        if (MusicEngine.currentAudio) {
            MusicEngine.currentAudio.pause();
            MusicEngine.currentAudio.currentTime = 0;
            MusicEngine.currentAudio = null;
        }

        // Synth ì •ì§€
        clearTimeout(MusicEngine.timeoutId);
        MusicEngine.bgmOscillators.forEach(o => { try{o.stop();}catch(e){} });
        MusicEngine.bgmOscillators = [];
    },

    // [Fallback] ê¸°ì¡´ ì „ììŒ ìƒì„±ê¸° (ìœ ì§€)
    playTone: (freq, type, duration, vol) => {
        if (!MusicEngine.ctx) return;
        const t = MusicEngine.ctx.currentTime;
        const osc = MusicEngine.ctx.createOscillator();
        const gain = MusicEngine.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;

        const master = (typeof AudioSys !== 'undefined') ? AudioSys.bgmVol : 0.5;
        const finalVol = vol * master * 0.3;

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain); 
        gain.connect(MusicEngine.ctx.destination);
        osc.start(t); 
        osc.stop(t + duration + 0.1);

        MusicEngine.bgmOscillators.push(osc);
        osc.onended = () => {
            const i = MusicEngine.bgmOscillators.indexOf(osc);
            if (i > -1) MusicEngine.bgmOscillators.splice(i, 1);
        };
    },

    loopCanon: function() {
        if (!this.isPlaying) return;
        const idx = this.canon.step;
        const mNote = this.canon.melody[idx];
        const bNote = this.canon.bass[idx];

        if(mNote) {
            this.playTone(mNote, 'sine', 0.5, 0.3);
            this.playTone(mNote * 2, 'triangle', 0.2, 0.1);
        }
        if(bNote) {
            this.playTone(bNote, 'square', 0.1, 0.05);
            this.playTone(bNote, 'sine', 0.8, 0.3);
        }

        this.canon.step = (this.canon.step + 1) % this.canon.melody.length;
        this.timeoutId = setTimeout(() => this.loopCanon(), 400);
    }
};

 

const UI = {
    toggleSettings: function() {
        const el = document.getElementById('audio-settings');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
    // [ì‹ ê·œ] ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë©”ë‰´ í† ê¸€
    toggleSaveMenu: function() {
        const el = document.getElementById('save-menu-popup');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
	// [UI] BGM ì„ íƒ ë° í•˜ì´ë¼ì´íŠ¸ ì²˜ë¦¬
    selectBGM: function(trackName, el) {
        // 1. ëª¨ë“  ì˜µì…˜ì—ì„œ active ì œê±°
        document.querySelectorAll('.bgm-opt').forEach(opt => opt.classList.remove('active'));
        
        // 2. í´ë¦­í•œ ì˜µì…˜ì— active ì¶”ê°€
        if(el) el.classList.add('active');
        
        // 3. ìŒì•… ì¬ìƒ
        MusicEngine.play(trackName);
        
        // 4. í† ê¸€ ë²„íŠ¼ì´ êº¼ì ¸ìˆë‹¤ë©´ ì¼œê¸°
        const tog = document.getElementById('tog-bgm');
        if (tog && !tog.classList.contains('on')) {
            AudioSys.toggleChannel('bgm');
        }
    },

    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() {
        document.getElementById('modal-overlay').style.display = 'none';
    },

    // [UI ê°œì„ ] ì˜¨ë¼ì¸ ì½”ë“œ ì…ë ¥ ëª¨ë‹¬
    openOnlineModal: function() {
        if (!socket || !socket.connected) {
            alert("âš ï¸ ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n(ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” AIì™€ ëŒ€ê²°í•˜ì„¸ìš”)");
            return;
        }
        if (Game.selected.length !== 3) {
            alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        const content = `
            <div style="text-align:center;">
                <p style="color:#555; margin-bottom:15px;">ì¹œêµ¬ì™€ ê³µìœ í•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple)</p>
                <input type="text" id="modal-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥" 
                    style="font-size:20px; padding:15px; width:80%; text-align:center; border-radius:15px; border:2px solid #ddd; outline:none; font-weight:bold; color:#7e57c2;">
                <button id="modal-submit-btn" onclick="Game.submitOnline()" 
                    style="width:100%; margin-top:20px; padding:15px; background:#7e57c2; color:white; border:none; border-radius:15px; font-weight:bold; cursor:pointer; font-size:18px;">
                    ì…ì¥í•˜ê¸° ğŸš€
                </button>
            </div>
        `;
        this.showModal("ğŸŒ ì˜¨ë¼ì¸ ë§¤ì¹­", content);
        setTimeout(() => document.getElementById('modal-room-code').focus(), 100);
    },

    showGuide: function() {
        let heroList = '';
        const guideOrder = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark'];
        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if (k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if (parts.length === 2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';
            // [íŒ¨ì‹œë¸Œ í‘œì‹œ ì¶”ê°€]
            heroList += `<div class="guide-item"> 
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> 
                <div class="guide-info"> 
                    <div class="guide-name">${name}</div> 
                    <div class="guide-desc">${s.desc}</div> 
                    <div style="font-size:10px; color:#555; margin-top:2px;"> 
                        <div>S1: ${s.s1} (${s.s1d})</div> 
                        <div>S2: ${s.s2} (${s.s2d})</div> 
                        ${s.passive ? `<div style="color:#00695c; font-weight:bold; margin-top:2px; border-top:1px dashed #ddd; padding-top:2px;">PASSIVE: ${s.passive}</div>` : ''}
                    </div> 
                </div> 
            </div>`;
        });

        // [ìˆ˜ì •ë¨] íƒ­ 2 (ì‹œìŠ¤í…œ ê·œì¹™) ì¶”ê°€ëœ ì»¨í…ì¸  HTML
        const content = `
        <div class="tab-header">
            <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button>
            <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button>
            <button class="tab-btn" onclick="UI.switchTab(2)">âš™ï¸ ì‹œìŠ¤í…œ</button>
        </div>
        
        <div id="tab-0" class="tab-content active">
            <table class="chart-table">
                <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
                <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr>
            </table>
            
            <div class="dual-chart">
                <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div>
            </div>

            <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; margin-top: 10px; border: 1px solid #90caf9;">
                <h4 style="margin: 0 0 5px 0; color: #1565c0;">ğŸ›¡ï¸ í›„ê³µ(2P) ì „ìˆ  ë³´ë„ˆìŠ¤</h4>
                <p style="font-size: 0.9em; margin: 0; color: #424242;">
                    1. <b>ëª¨ë“  ìœ ë‹›:</b> ì‹œì‘ ì‹œ í–‰ë™ ë¶ˆê°€ <span style="color:#2980b9;">ë©´ì—­</span><br>
                    2. <b>ì„ ë´‰ì¥(1ë²ˆ ìœ ë‹›):</b> 1í„´ê°„ <b style="color:red;">ìµœì¢… ë°ë¯¸ì§€ 10% ì¦ê°€</b>
                </p>
            </div>
        </div>
        
        <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;">
            ${heroList}
        </div>

        <div id="tab-2" class="tab-content" style="max-height: 50vh; overflow-y:auto; font-size:13px; color:#555;">
            <div style="margin-bottom:15px;">
                <h4 style="color:#ff7043; border-bottom:2px solid #ffcc80; padding-bottom:3px;">â˜ ï¸ ìƒíƒœì´ìƒ ë°ë¯¸ì§€ (ê³ ì •)</h4>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>ğŸ”¥ í™”ìƒ:</b> í„´ ì‹œì‘ ì‹œ <b style="color:#ff5722;">20</b> í”¼í•´ (Fireë¡œë¶€í„° ë°›ëŠ” í”¼í•´ 25% ì¦ê°€)</li>
                    <li><b>â˜ ï¸ ë§¹ë…:</b> í„´ ì‹œì‘ ì‹œ <b style="color:#9c27b0;">35</b> í”¼í•´</li>
                    <li><b>â³ ì†ë°•(ëª¨ë˜ì§€ì˜¥):</b> í„´ ì‹œì‘ ì‹œ <b style="color:#f57f17;">60</b> í”¼í•´</li>
                </ul>
            </div>

            <div style="margin-bottom:15px;">
                <h4 style="color:#ffd700; border-bottom:2px solid #fff176; padding-bottom:3px;">âš¡ ê°ì„±(Super Hero) ì¡°ê±´</h4>
                <p style="margin:5px 0; font-size:12px;">ì¡°ê±´ ë‹¬ì„± ì‹œ í…Œë‘ë¦¬ê°€ ë¹›ë‚˜ë©° ìŠ¤íƒ¯ ê¸°ë¡ë¨.</p>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>âš”ï¸ ë”œëŸ¬:</b> 2í‚¬ ì´ìƒ OR ëˆ„ì  ë°ë¯¸ì§€ <b style="color:#f44336;">1500</b></li>
                    <li><b>ğŸ›¡ï¸ íƒ±ì»¤:</b> ëˆ„ì  ë°›ì€ í”¼í•´ <b style="color:#2196f3;">1000</b></li>
                    <li><b>ğŸ§© ì§€ì›:</b> ëˆ„ì  í+ì‰´ë“œ ì œê³µëŸ‰ <b style="color:#4caf50;">1000</b></li>
                </ul>
            </div>

            <div style="margin-bottom:15px;">
                <h4 style="color:#ef5350; border-bottom:2px solid #e57373; padding-bottom:3px;">ğŸ’€ ì„œë“  ë°ìŠ¤ (ë°ìŠ¤ë§¤ì¹˜)</h4>
                <p style="margin:5px 0;">
                    <b>15ë¼ìš´ë“œ</b>(ì•½ 90í„´)ê°€ ì§€ë‚˜ë©´, ëª¨ë“  ì˜ì›…ì˜ ê³µê²©ë ¥ì´ ë§¤ í„´ <b style="color:red;">+10</b>ì”© ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.
                </p>
            </div>

            <div>
                <h4 style="color:#78909c; border-bottom:2px solid #b0bec5; padding-bottom:3px;">â„¹ï¸ ê¸°íƒ€ ìƒì„¸ ê·œì¹™</h4>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>â›°ï¸ í™(Earth) S1:</b> 25% ê¸°ì ˆ / 15% ì¹¨ë¬µ / 60% íš¨ê³¼ì—†ìŒ</li>
                    <li><b>ğŸ›¡ï¸ ì‡ (Metal) íŒ¨ì‹œë¸Œ:</b> ì‰´ë“œê°€ ìˆì„ ë•Œë§Œ ë°œë™ (ìµœëŒ€ì²´ë ¥ 20% ì´ˆê³¼ë¶„ ì‚­ì œ)</li>
                    <li><b>ğŸ§  ì •ì‹  ì§€ë°°(ì„¸ë‡Œ):</b> <b style="color:red;">ì •í™” ë¶ˆê°€</b>. ì‹œì „ìë¥¼ ê¸°ì ˆ/ë¹™ê²°ì‹œí‚¤ê±°ë‚˜ ì²˜ì¹˜í•´ì•¼ë§Œ í’€ë¦½ë‹ˆë‹¤. (ë¹„ìš©: HP 12%)</li>
                </ul>
            </div>
        </div>`;
        
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if (i === idx) b.classList.add('active');
            else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if (i === idx) c.classList.add('active');
            else c.classList.remove('active');
        });
    },

    // [ë°ë¯¸ì§€ í°íŠ¸] ì„¸ë¶„í™” ì ìš©
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id);
        if (!unitEl) return;
        const el = document.createElement('div');
        el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        const randomX = (Math.random() - 0.5) * 40;
        const randomY = (Math.random() - 0.5) * 20;
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px';
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    },

    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        if (!banner) return; // ë°°ë„ˆ ì—†ìœ¼ë©´ ì¡°ìš©íˆ ì¢…ë£Œ

        // (ê¸°ì¡´ ë°°ë„ˆ ë¡œì§ ìœ ì§€)
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´";
        }
        banner.style.animation = 'none';
        void banner.offsetWidth;
        banner.style.animation = 'banner-swipe 1.2s forwards';
    },
    // [ìˆ˜ì •] ì´í™íŠ¸ë¥¼ í™”ë©´ ì „ì²´ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ìƒì„± (ê°€ë ¤ì§ ë°©ì§€)
    playVFX: function(unit, type) {
    const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
    const el = document.getElementById(id);
    if (!el) return;

    // [ì‹ ê·œ] ì„¸ë‡Œ ì¹´ë“œ ë’¤ì§‘ê¸° íš¨ê³¼
    if (type === 'mc-flip') {
        el.classList.add('mc-flip');
        setTimeout(() => el.classList.remove('mc-flip'), 1000);
        return;
    }

    // [ì‹ ê·œ] CSS ê¸°ë°˜ íŠ¹ìˆ˜ ì´í™íŠ¸ (ì¹´ë“œ ë‚´ë¶€ì— ì§ì ‘ ë¶€ì°©)
    if (type === 'lightning' || type === 'mc-wave') {
        const vfx = document.createElement('div');
        vfx.className = (type === 'lightning') ? 'lightning-bolt' : 'mind-control-wave';
        el.appendChild(vfx);
        setTimeout(() => vfx.remove(), 1000);
        return; // íŠ¹ìˆ˜ ì´í™íŠ¸ëŠ” ì—¬ê¸°ì„œ ì¢…ë£Œ
    }

    // [ê¸°ì¡´] ì´ëª¨ì§€ ê¸°ë°˜ ì´í™íŠ¸ (í™”ë©´ ì¢Œí‘œ ê¸°ì¤€ bodyì— ë¶€ì°©)
        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const vfx = document.createElement('div');
        vfx.className = 'vfx-layer';
        // ì¢Œí‘œë¥¼ ì§ì ‘ ì§€ì • (í™”ë©´ ê¸°ì¤€ ì ˆëŒ€ ì¢Œí‘œ)
        vfx.style.left = `${centerX}px`;
        vfx.style.top = `${centerY}px`;
        vfx.style.transform = "translate(-50%, -50%)"; // ì¤‘ì•™ ì •ë ¬ ë³´ì •
        
        switch(type) {
            case 'hit': vfx.innerText = 'ğŸ’¥'; vfx.style.animation = 'vfx-boom 0.4s ease-out forwards'; break;
        case 'slash': vfx.innerText = 'âš”ï¸'; vfx.style.animation = 'vfx-slash 0.3s ease-out forwards'; break;
        case 'fire': vfx.innerText = 'ğŸ”¥'; vfx.style.animation = 'vfx-boom 0.6s ease-out forwards'; vfx.style.color = 'orange'; break;
        // [Fix] ì–¼ìŒ: ìƒ‰ìƒ ë° Glow ì¶”ê°€
        case 'ice': vfx.innerText = 'â„ï¸'; vfx.style.animation = 'vfx-boom 0.5s ease-out forwards'; vfx.style.color = '#00bcd4'; vfx.style.textShadow = '0 0 10px #00bcd4'; break;
        case 'heal': vfx.innerText = 'âœ¨'; vfx.style.animation = 'vfx-heal 0.8s ease-out forwards'; break;
        // [Fix] í™: ìƒ‰ìƒ ì¶”ê°€ (ê°ˆìƒ‰)
        case 'rock': vfx.innerText = 'ğŸŒ‘'; vfx.style.animation = 'vfx-boom 0.4s cubic-bezier(0.1, 0.7, 1.0, 0.1) forwards'; vfx.style.color = '#795548'; break;
        case 'magic': vfx.innerText = 'ğŸŒ€'; vfx.style.animation = 'vfx-magic 0.7s ease-out forwards'; break;

        // [Fix] ì–´ë‘ : ë¸”ë™í™€ (ê²€ì •)
        case 'vortex': vfx.innerText = 'âš«'; vfx.style.animation = 'vfx-magic 1.0s ease-out forwards'; vfx.style.color = '#000'; vfx.style.fontSize = '120px'; vfx.style.filter = 'blur(2px)'; break;

        // [New] ë…: ë…ê°€ìŠ¤ (ë…¹ìƒ‰ ì•ˆê°œ) - í™•ì‚°(boom) ì ìš©
        case 'poison': vfx.innerText = 'â˜£ï¸'; vfx.style.animation = 'vfx-boom 0.8s ease-out forwards'; vfx.style.color = '#76ff03'; vfx.style.filter = 'opacity(0.8) blur(2px)'; vfx.style.transform = 'scale(1.5)'; break;

        // [New] ë‚˜ë¬´: ë‚˜ë­‡ì (ì´ˆë¡)
        case 'leaf': vfx.innerText = 'ğŸƒ'; vfx.style.animation = 'vfx-slash 0.5s ease-out forwards'; vfx.style.color = '#4caf50'; break;
        default: vfx.innerText = 'ğŸ’¥'; vfx.style.animation = 'vfx-boom 0.4s ease-out forwards'; break;
        }
        
        // ì¹´ë“œê°€ ì•„ë‹Œ 'body'ì— ì§ì ‘ ë¶™ì—¬ì„œ ê°€ì¥ ìœ„ì— í‘œì‹œ
        document.body.appendChild(vfx);
        setTimeout(() => vfx.remove(), 1000);
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);
        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        const mvp = allUnits.sort((a, b) => (b.stats.dmg + b.stats.heal + b.stats.shieldGiven) - (a.stats.dmg + a.stats.heal + a.stats.shieldGiven))[0];
        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`;
        };
        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },

    // [íˆ´íŒ] ì •ë³´ í‘œì‹œ
    showTooltip: function(u, el) {
        const info = SKILL_DB[u.getKey()];
        const statusText = u.status.map(s => {
            let info = `â€¢ ${s.type} (${s.turn}í„´)`;
            // [UI] í™•ë¥  ë° ìƒì„¸ ì •ë³´ í‘œì‹œ
            if (s.type.startsWith('KARMA_VICTIM')) info += ' <span style="color:#ffcc80; font-size:10px;">(ë°˜ì‚¬ 50%)</span>';
            if (s.type === 'MC_WAIT') info += ' <span style="color:#ff80ab; font-size:10px;">(ì„¸ë‡Œ ëŒ€ê¸°)</span>';
            return info;
        }).join('<br>') || 'ì—†ìŒ';
        const html = `
            <div class="tooltip-title">${u.name} (HP: ${u.hp})</div>
            <div style="margin-bottom:5px;">${info.desc}</div>
            <div style="color:#aaa; border-top:1px solid #555; padding-top:3px; margin-top:3px;">
                <b>ìƒíƒœì´ìƒ:</b><br>${statusText}
            </div>
        `;
        const tooltip = document.getElementById('tooltip-view');
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';

        const rect = el.getBoundingClientRect();
        let top = rect.top - 100;
        let left = rect.left + rect.width / 2 - 100;
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;

        // [Patch] í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ê°€ë¡œ ìœ„ì¹˜ ë³´ì •
    const tipWidth = 220; // íˆ´íŒ ëŒ€ëµì  ë„ˆë¹„
    const screenW = window.innerWidth;

    // ì˜¤ë¥¸ìª½ ë ì²˜ë¦¬
    if (left + tipWidth > screenW) {
        left = screenW - tipWidth - 10;
    }
    // ì™¼ìª½ ë ì²˜ë¦¬
    if (left < 10) left = 10;

    tooltip.style.top = top + 'px';
    tooltip.style.left = left + 'px';
    },
    hideTooltip: function() {
        document.getElementById('tooltip-view').style.display = 'none';
    },

    // [ì»·ì‹ ] ì—°ì¶œ
    showCutIn: function(unit) {
        const ov = document.getElementById('cut-in-overlay');
        const em = document.getElementById('cut-in-emoji');
        const msg = document.getElementById('cut-in-msg');

        const key = unit.getKey();
        em.innerText = SKILL_DB[key].icon || ATTR[unit.base].i;
        msg.innerText = "HEROIC FINISH!";

        ov.style.display = 'flex';
        AudioSys.play('CUTIN');

        // 1.2ì´ˆ í›„ ì¢…ë£Œ
        setTimeout(() => {
            ov.style.display = 'none';
        }, 1200);
    }, 

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ë©”ë‰´ ì—´ê¸°
    showEmoteMenu: function(u, el) {
        const existing = document.querySelector('.emote-menu');
        if (existing) existing.remove();

        const menu = document.createElement('div');
        menu.className = 'emote-menu';
        const emojis = ['ğŸ‘', 'ğŸ˜¡', 'ğŸ˜±', 'ğŸ˜œ', 'ğŸ³ï¸'];
        emojis.forEach(e => {
            const btn = document.createElement('span');
            btn.className = 'emote-btn';
            btn.innerText = e;
            btn.onclick = (ev) => {
                ev.stopPropagation();
                UI.triggerEmote(u, e);
                menu.remove();
            };
            menu.appendChild(btn);
        });
        
        const rect = el.getBoundingClientRect();
        // ìœ ë‹› ë¨¸ë¦¬ ìœ„ì— í‘œì‹œ
        menu.style.top = (rect.top - 60 + window.scrollY) + 'px';
        menu.style.left = (rect.left + rect.width/2 - 100 + window.scrollX) + 'px';
        
        document.body.appendChild(menu);
        
        // ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
        setTimeout(() => {
            document.addEventListener('click', function close() {
                if(menu.parentNode) menu.remove();
                document.removeEventListener('click', close);
            }, {once:true});
        }, 0);
    },

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ì‹¤í–‰
    triggerEmote: function(u, emoji) {
        // ìœ ë‹› ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (!el) return;
        
        const rect = el.getBoundingClientRect();
        
        // ë§í’ì„  ìƒì„± (bodyì— ì§ì ‘ ì¶”ê°€í•˜ì—¬ ìµœìƒìœ„ ë ˆì´ì–´ ë³´ì¥)
        const bubble = document.createElement('div');
        bubble.className = 'emote-bubble';
        bubble.innerText = emoji;
        
        // ìœ„ì¹˜ ì ˆëŒ€ê°’ ê³„ì‚° (ìŠ¤í¬ë¡¤ í¬í•¨)
        bubble.style.left = (rect.left + rect.width / 2) + 'px'; 
        bubble.style.top = (rect.top - 50 + window.scrollY) + 'px';
        // z-indexë¥¼ ì•„ì£¼ ë†’ê²Œ ì„¤ì •
        bubble.style.zIndex = "9999"; 
        
        document.body.appendChild(bubble);
        
        setTimeout(() => bubble.remove(), 2000);
    }, 

// [New] Emotion Codex UI
    showCollection: function() {
        const list = Object.keys(EMOTION_DB);
        let html = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">`;
        let unlockedCount = 0;

        list.forEach(key => {
            const isUnlocked = TitleManager.unlocked.includes(key);
            if (isUnlocked) unlockedCount++;
            
            const data = EMOTION_DB[key];
            const base = key.split('-')[0] === 'Normal' ? 'Normal' : key.split('-')[0];
            let bgClass = `bg-${base}`;
            if (key.includes('-') && key.split('-')[0] === key.split('-')[1]) bgClass += '-Enhanced';
            if (key === 'Normal') bgClass = 'bg-Normal';

            // Style: Unlocked vs Locked
            const style = isUnlocked 
                ? `border:2px solid #ff80ab; background:#fff; color:#333;` 
                : `background:#eee; color:#aaa; border:2px dashed #ccc; opacity:0.7;`;
            
            const icon = isUnlocked ? (SKILL_DB[key].icon || ATTR[base].i) : 'ğŸ”’';
            const title = isUnlocked ? data.t : '???';
            const desc = isUnlocked ? data.d : 'Unlock by Awakening';

            html += `
                <div style="padding:10px; border-radius:15px; display:flex; flex-direction:column; align-items:center; text-align:center; ${style}">
                    <div class="attr-icon ${isUnlocked ? bgClass : ''}" style="width:36px; height:36px; font-size:20px; margin-bottom:5px; ${!isUnlocked?'background:#ccc;':''}">${icon}</div>
                    <div style="font-weight:bold; font-size:14px; margin-bottom:3px;">${title}</div>
                    <div style="font-size:10px; line-height:1.2;">${desc}</div>
                </div>
            `;
        });
        html += `</div>`;
        
        const pct = Math.floor((unlockedCount / list.length) * 100);
        const header = `
            <div style="text-align:center; margin-bottom:15px; padding-bottom:10px; border-bottom:2px dashed #ffcdd2;">
                <h3 style="margin:0 0 5px 0; color:#ff80ab;">ğŸ’ Emotion Codex</h3>
                <div style="font-size:14px; color:#888;">
                    Collection: <b style="color:${pct===100?'#ffca28':'#5d4037'}">${unlockedCount} / ${list.length}</b> (${pct}%)
                </div>
            </div>
        `;

        this.showModal("Codex", header + html);
    },
    // [Phase 1] íˆ¬ì‚¬ì²´ ë°œì‚¬ ì• ë‹ˆë©”ì´ì…˜ (ì†ì„±ë³„ ê¶¤ì  ì ìš©)
    // [ê°œì„ ] íˆ¬ì‚¬ì²´ ë°œì‚¬ - ìŠ¤í‚¬ ë“±ê¸‰ë³„ í¬ê¸°/ì†ë„ ì°¨ë³„í™”
    fireProjectile: function(atk, def, icon, skillIdx = 0) {
    return new Promise(resolve => {
        const startId = atk.team === 0 ? `p-card-${atk.id}` : `e-card-${atk.id}`;
        const endId = def.team === 0 ? `p-card-${def.id}` : `e-card-${def.id}`;
        const sEl = document.getElementById(startId);
        const eEl = document.getElementById(endId);

        if (!sEl || !eEl) { resolve(); return; }

        const sRect = sEl.getBoundingClientRect();
        const eRect = eEl.getBoundingClientRect();

        // [ê°œì„ ] ì†ì„±ë³„ ë¹„í–‰ ì†ë„ ì°¨ë³„í™” (ms) + ë°°ì† ì ìš©
        let flightDuration = 250; 
        const base = atk.base;
        
        if (base === 'Metal' || base === 'Light') flightDuration = 180;
        else if (base === 'Fire' || base === 'Water' || base === 'Dark') flightDuration = 220;
        else flightDuration = 300;

        if (typeof Game !== 'undefined') flightDuration *= Game.speedMultiplier;
        
        // [ê°œì„ ] ìŠ¤í‚¬ ë“±ê¸‰ë³„ í¬ê¸° ë° ì´í™íŠ¸
        let projectileSize = 24; // ê¸°ë³¸ (í‰íƒ€)
        let glowEffect = '';
        
        if (skillIdx === 1) {
            projectileSize = 32; // S1: 1.33ë°°
            glowEffect = 'filter: drop-shadow(0 0 8px rgba(255, 223, 0, 0.6));';
        } else if (skillIdx === 2) {
            projectileSize = 40; // S2: 1.67ë°°  
            glowEffect = 'filter: drop-shadow(0 0 12px rgba(255, 152, 0, 0.8));';
        }

        // [Phase 1] ì†ì„±ë³„ ê¶¤ì  íƒ€ì… ê²°ì •
        let trajectoryClass = 'trajectory-straight';
        
        if (base === 'Fire') trajectoryClass = 'trajectory-arc'; // ë¶ˆ: í¬ë¬¼ì„ 
        else if (base === 'Water') trajectoryClass = 'trajectory-wave'; // ë¬¼: ë¬¼ê²°
        else if (base === 'Tree') trajectoryClass = 'trajectory-spin'; // ë‚˜ë¬´: íšŒì „
        // [Fix] í™(Earth)ì„ ì§ì„  ê¶¤ì (Lightì™€ ë™ì¼)ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬
        else if (base === 'Metal' || base === 'Normal' || base === 'Earth' || base === 'Light' || base === 'Dark') trajectoryClass = 'trajectory-straight';

        const p = document.createElement('div');
        p.className = `projectile ${trajectoryClass}`;
        p.innerText = icon;
        p.style.fontSize = `${projectileSize}px`;
        p.style.cssText += glowEffect;
        
        // [Patch v19.14] ë°°ì† ì ìš©: CSS íŠ¸ëœì§€ì…˜ ì†ë„ ë™ê¸°í™”
        if (typeof Game !== 'undefined') {
            const dur = (flightDuration / 1000) + 's';
            p.style.transitionDuration = dur;
            p.style.animationDuration = dur;
        }

        p.style.left = (sRect.left + sRect.width/2) + 'px';
        p.style.top = (sRect.top + sRect.height/2) + 'px';

        document.body.appendChild(p);

        // [Patch] ê°•ì œ ë¦¬í”Œë¡œìš°(Reflow): ë¸Œë¼ìš°ì €ê°€ ì‹œì‘ ìœ„ì¹˜ë¥¼ ì¸ì‹í•˜ë„ë¡ ê°•ì œí•¨ (ìˆœê°„ì´ë™ ë°©ì§€)
        void p.offsetWidth; 

        requestAnimationFrame(() => {
            p.style.left = (eRect.left + eRect.width/2) + 'px';
            p.style.top = (eRect.top + eRect.height/2) + 'px';
        });

        setTimeout(() => {
            p.remove();
            
            // [ê°œì„ ] ìŠ¤í‚¬ ë“±ê¸‰ë³„ ì„íŒ©íŠ¸ ì§€ì† ì‹œê°„
            let impactDuration = 300; // ê¸°ë³¸ (í‰íƒ€)
            if (skillIdx === 1) impactDuration = 400; // S1
            else if (skillIdx === 2) impactDuration = 500; // S2
            
            // [Phase 1] ì†ì„±ë³„ ì„íŒ©íŠ¸ ì´í™íŠ¸
            const boom = document.createElement('div');
            boom.className = 'impact-effect';
            
            // ì†ì„±ë³„ ì„íŒ©íŠ¸ ì•„ì´ì½˜ ê²°ì •
            let impactIcon = 'ğŸ’¥';
            let impactClass = '';

            // [Fix] íŠ¹ìˆ˜ ì†ì„± íƒ€ê²© ì´í™íŠ¸ (ì–¼ìŒ, ë¹›, ì „ê¸°)
            if (atk.base === 'Water' && atk.extra === 'Dark') {
                if (skillIdx === 1) impactIcon = 'ğŸ’¥'; 
                else if (skillIdx === 2) { impactIcon = 'â„ï¸'; impactClass = 'impact-water'; }
            } 
            else if (atk.base === 'Light') {
                // Light S1 íƒ€ê²© ì‹œ 'ë¹›ì˜ í­ë°œ' (ë…¸ë€ìƒ‰ ë³´ì •)
                if (skillIdx === 1) { impactIcon = 'ğŸ’¥'; impactClass = 'impact-light-hit'; }
            }
            else if (atk.base === 'Metal' && atk.extra === 'Dark') { impactIcon = 'âš¡'; } // ì „ê¸° íƒ€ê²©

            // [Fix] ê¸°ë³¸ ì†ì„± íƒ€ê²© ì•„ì´ì½˜ ì¼ì¹˜í™”
            else if (base === 'Tree') impactIcon = 'ğŸƒ';
            else if (base === 'Earth') impactIcon = 'ğŸŒ‘';
            else if (base === 'Water' && !atk.extra) { impactIcon = 'ğŸ’§'; impactClass = 'impact-water'; }
            else if (base === 'Metal' && !atk.extra) impactIcon = 'âš”ï¸';

            else if (base === 'Fire') {
                impactIcon = 'ğŸ”¥';
                impactClass = 'impact-fire';
            } else if (base === 'Water') {
                impactIcon = 'ğŸ’¦';
                impactClass = 'impact-water';
            } else if (base === 'Tree') {
                impactIcon = 'ğŸƒ';
                impactClass = 'impact-tree';
            } else if (base === 'Metal') {
                impactIcon = 'âœ¨';
                impactClass = 'impact-metal';
            } else if (base === 'Earth') {
                impactIcon = 'ğŸ’¥';
            } else if (base === 'Light') {
                impactIcon = 'âœ¨';
            } else if (base === 'Dark') {
                impactIcon = 'ğŸ’€';
            }
            
            if (impactClass) {
                boom.classList.add(impactClass);
            }
            boom.innerText = impactIcon;
            boom.style.left = (eRect.left + eRect.width/2) + 'px';
            boom.style.top = (eRect.top + eRect.height/2) + 'px';
            document.body.appendChild(boom);
            
            // [ê°œì„ ] ì†ì„±ë³„ ì§€ë©´/ë°°ê²½ íš¨ê³¼ í˜¸ì¶œ
            UI.createElementalEffect(def, base);
            
            setTimeout(() => boom.remove(), impactDuration);
            resolve();
        }, flightDuration);
    });
},

    // [Phase 1] ì§€ë©´ ê· ì—´ ì´í™íŠ¸ ìƒì„±
    createGroundCrack: function(target) {
        const cardId = target.team === 0 ? `p-card-${target.id}` : `e-card-${target.id}`;
        const card = document.getElementById(cardId);
        if (!card) return;
        
        const layer = card.querySelector('.ground-effect-layer');
        if (!layer) return;
        
        // ê°„ë‹¨í•œ ê· ì—´ì„  3ê°œ ìƒì„±
        for (let i = 0; i < 3; i++) {
            const crack = document.createElement('div');
            crack.className = 'ground-crack';
            crack.style.animationDelay = `${i * 0.05}s`;
            crack.style.transform = `translateX(-50%) rotate(${(i - 1) * 15}deg)`;
            layer.appendChild(crack);
            
            setTimeout(() => crack.remove(), 500);
        }
    },
    
    // [ì‹ ê·œ] ì†ì„±ë³„ ì§€ë©´/ë°°ê²½ íš¨ê³¼ ìƒì„±
    createElementalEffect: function(target, element) {
        const cardId = target.team === 0 ? `p-card-${target.id}` : `e-card-${target.id}`;
        const card = document.getElementById(cardId);
        if (!card) return;
        
        const layer = card.querySelector('.ground-effect-layer');
        if (!layer) return;
        
        switch(element) {
            case 'Fire':
                // í™”ì—¼ íŒŒí‹°í´ 5-8ê°œ
                const fireCount = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < fireCount; i++) {
                    const flame = document.createElement('div');
                    flame.className = 'fire-particle';
                    flame.innerText = 'ğŸ”¥';
                    flame.style.left = `${20 + Math.random() * 60}%`;
                    flame.style.bottom = '0';
                    flame.style.animationDelay = `${i * 0.05}s`;
                    layer.appendChild(flame);
                    setTimeout(() => flame.remove(), 450);
                }
                break;
                
            case 'Water':
                // ë¬¼ë³´ë¼ 3-5ê°œ ì‚¬ë°©ìœ¼ë¡œ
                const splashCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < splashCount; i++) {
                    const splash = document.createElement('div');
                    splash.className = 'water-splash';
                    splash.innerText = 'ğŸ’¦';
                    splash.style.left = '50%';
                    splash.style.bottom = '10px';
                    const angle = (Math.random() * 360) * Math.PI / 180;
                    const distance = 30 + Math.random() * 20;
                    splash.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    splash.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                    layer.appendChild(splash);
                    setTimeout(() => splash.remove(), 400);
                }
                break;
                
            case 'Water-Dark':
                // ì–¼ìŒ í”„ë ˆì„ + ì„œë¦¬ íŒŒí‹°í´
                const iceFrame = document.createElement('div');
                iceFrame.className = 'ice-frame';
                card.appendChild(iceFrame);
                setTimeout(() => iceFrame.remove(), 450);
                
                // ì„œë¦¬ íŒŒí‹°í´ 4-6ê°œ
                const frostCount = 4 + Math.floor(Math.random() * 3);
                for (let i = 0; i < frostCount; i++) {
                    const frost = document.createElement('div');
                    frost.className = 'frost-particle';
                    frost.innerText = 'â„';
                    frost.style.left = `${Math.random() * 100}%`;
                    frost.style.top = `${Math.random() * 100}%`;
                    const tx = (Math.random() - 0.5) * 40;
                    const ty = -20 - Math.random() * 20;
                    frost.style.setProperty('--tx', `${tx}px`);
                    frost.style.setProperty('--ty', `${ty}px`);
                    card.appendChild(frost);
                    setTimeout(() => frost.remove(), 550);
                }
                break;
                
            case 'Metal-Dark':
                // ì „ê¸° ìŠ¤íŒŒí¬ 5-7ê°œ
                const sparkCount = 5 + Math.floor(Math.random() * 3);
                for (let i = 0; i < sparkCount; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'electric-spark';
                    spark.style.left = `${20 + Math.random() * 60}%`;
                    spark.style.bottom = '0';
                    spark.style.transform = `rotate(${Math.random() * 40 - 20}deg)`;
                    layer.appendChild(spark);
                    setTimeout(() => spark.remove(), 300);
                }
                break;
                
            case 'Earth':
                // ì§€ë©´ ê· ì—´ (ê¸°ì¡´)
                this.createGroundCrack(target);
                // ëŒ íŒŒí¸ 2-4ê°œ
                const debrisCount = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < debrisCount; i++) {
                    const debris = document.createElement('div');
                    debris.className = 'rock-debris';
                    debris.innerText = 'ğŸŒ‘ğŸª¨';
                    debris.style.left = '50%';
                    debris.style.bottom = '10px';
                    const tx = (Math.random() - 0.5) * 60;
                    const ty = -40 - Math.random() * 30;
                    debris.style.setProperty('--tx', `${tx}px`);
                    debris.style.setProperty('--ty', `${ty}px`);
                    layer.appendChild(debris);
                    setTimeout(() => debris.remove(), 450);
                }
                break;
                
            // [Fix] Metalì€ ì§€ë©´ ê· ì—´ ì œê±° (ê¹”ë”í•œ ë² ê¸° ì—°ì¶œ ìœ ì§€)
            case 'Normal':
                 // ì§€ë©´ ê· ì—´ë§Œ (ê¸°ì¡´ íš¨ê³¼ ìœ ì§€)
                this.createGroundCrack(target);
                break;
                
            case 'Dark':
                // ì–´ë‘ ì˜ ì†Œìš©ëŒì´
                const vortex = document.createElement('div');
                vortex.className = 'dark-vortex';
                card.appendChild(vortex);
                setTimeout(() => vortex.remove(), 550);
                break;
                
            case 'Light':
                // ì„¬ê´‘ í­ë°œ
                const flash = document.createElement('div');
                flash.className = 'light-flash';
                flash.style.left = '50%';
                flash.style.top = '50%';
                flash.style.transform = 'translate(-50%, -50%)';
                card.appendChild(flash);
                
                // ì‹­ì ë°˜ì§ì„
                const shine1 = document.createElement('div');
                shine1.className = 'cross-shine';
                card.appendChild(shine1);
                
                const shine2 = document.createElement('div');
                shine2.className = 'cross-shine';
                shine2.style.width = '100%';
                shine2.style.height = '4px';
                shine2.style.top = '50%';
                shine2.style.left = '0';
                shine2.style.transform = 'translateY(-50%)';
                card.appendChild(shine2);
                
                setTimeout(() => {
                    flash.remove();
                    shine1.remove();
                    shine2.remove();
                }, 350);
                break;
        }
    },

    // [Phase 1] ë°ë¯¸ì§€ ë¹„ë¡€ íˆíŠ¸ìŠ¤í†± (ê¸°ì¡´ í•¨ìˆ˜ ê°œì„ )
    // [ê°œì„ ] íˆíŠ¸ìŠ¤í†± - ì¡°ê±´ë¶€ ì ìš©ìœ¼ë¡œ í…œí¬ ìµœì í™”
    hitStop: function(damage = 0, isAOE = false, isFirstHit = true, isKill = false) {
        // ì•½í•œ ê³µê²©ì€ ìŠ¤í‚µ (50 ì´í•˜)
        if (damage < 50) return;
        
        // ê´‘ì—­ ê³µê²©ì˜ 2íƒ€ ì´í›„ëŠ” ìŠ¤í‚µ (í‚¬ ì œì™¸)
        if (isAOE && !isFirstHit && !isKill) return;
        
        // ë°ë¯¸ì§€ì— ë¹„ë¡€í•œ íˆíŠ¸ìŠ¤í†± ì‹œê°„ ê³„ì‚°
        let duration = 100; // ê¸°ë³¸ê°’
        
        if (isKill) {
            duration = 250; // í‚¬ í™•ì •ì€ ìµœëŒ€
        } else if (damage >= 500) {
            duration = 250; // ì¹˜ëª…íƒ€ê¸‰
        } else if (damage >= 300) {
            duration = 200; // ê°•í•œ ê³µê²©
        } else if (damage >= 100) {
            duration = 150; // ì¤‘ê°„ ê³µê²©
        } else {
            duration = 100; // ì•½í•œ ê³µê²©
        }
        
        document.body.classList.add('hit-stopped');
        setTimeout(() => {
            document.body.classList.remove('hit-stopped');
        }, duration);
    },
    
    // [ì‹ ê·œ] ì¹´ë“œ í”ë“¤ë¦¼ íš¨ê³¼ - íƒ€ê²©ê° ê°•í™”
    shakeCard: function(target, damage) {
        const cardId = target.team === 0 ? `p-card-${target.id}` : `e-card-${target.id}`;
        const card = document.getElementById(cardId);
        if (!card) return;
        
        // ê¸°ì¡´ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì œê±°
        card.classList.remove('shake-light', 'shake-medium', 'shake-heavy');
        
        // ë°ë¯¸ì§€ë³„ í”ë“¤ë¦¼ ê°•ë„ ê²°ì •
        let shakeClass = 'shake-light';
        if (damage >= 300) {
            shakeClass = 'shake-heavy';
        } else if (damage >= 100) {
            shakeClass = 'shake-medium';
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ì ìš©
        card.classList.add(shakeClass);
        
        // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ í´ë˜ìŠ¤ ì œê±°
        setTimeout(() => {
            card.classList.remove(shakeClass);
        }, 250);
    },

    // [ë©”ë‰´ ì—´ê¸°/ë‹«ê¸° ê¸°ëŠ¥]
    toggleDock: function() {
        const el = document.getElementById('dock-folder');
        if (!el) return; 

        if (el.classList.contains('show')) {
            el.classList.remove('show');
            el.style.display = 'none'; 
            
            const s1 = document.getElementById('audio-settings');
            const s2 = document.getElementById('save-menu-popup');
            if(s1) s1.style.display = 'none';
            if(s2) s2.style.display = 'none';
        } else {
            el.style.display = 'flex'; 
            void el.offsetWidth; 
            el.classList.add('show');
            el.style.zIndex = '9999';
        }
    }
}; // UI ê°ì²´ ì—¬ê¸°ì„œ ë! (ì¤‘ê´„í˜¸, ì„¸ë¯¸ì½œë¡  í•„ìˆ˜)


const Game = {
    // [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
    DEBUG_MODE: true, // ê°œë°œ ì¤‘ì—” true, ë°°í¬ ì‹œ falseë¡œ ë³€ê²½

    debugLog: function(msg, data) {
        if (this.DEBUG_MODE) {
            // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê°ì²´ë¡œ, ì—†ìœ¼ë©´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
            if (data) console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;', data);
            else console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;');
        }
    },
    pool: [],
    selected: [],
    pTeam: [],
    eTeam: [],
    queue: [],
    curr: 0,
    selectedSkillIdx: -1,
    timer: null,
    turnCount: 1,
    difficulty: 'normal',
    watchdog: null,
    isOver: false,
    mode: 'pve',
    isProcessing: false,
    challengeStage: 0,
    isMindControlling: null, 
    currentMCCasterId: null,
    
    // [Patch v19.14] í¸ì˜ì„± ë³€ìˆ˜ ë° í•¨ìˆ˜
    speedMultiplier: 1,
    isAutoBattle: false,
    
    toggleSpeed: function() {
        this.speedMultiplier = this.speedMultiplier === 1 ? 0.5 : 1; // 0.5 = 2ë°°ì†
        const btn = document.getElementById('btn-speed');
        if(this.speedMultiplier === 0.5) {
            btn.innerHTML = "â©";
            btn.classList.add('active-speed');
        } else {
            btn.innerHTML = "â–¶";
            btn.classList.remove('active-speed');
        }
    },
    
    toggleAuto: function() {
        this.isAutoBattle = !this.isAutoBattle;
        const btn = document.getElementById('btn-auto');
        if(this.isAutoBattle) {
            btn.classList.add('active-auto');
            // ë‚´ í„´ì´ê³  ì…ë ¥ ëŒ€ê¸° ì¤‘ì´ë©´ ì¦‰ì‹œ AI ì‹¤í–‰
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
            if(u && u.team === 0 && !u.isDead && !this.isProcessing && !this.isMindControlling) {
                this.noInput();
                if(this.timer) clearTimeout(this.timer);
                if (this.timer) clearTimeout(this.timer);

                this.timer = setTimeout(() => this.ai(u), 500 * this.speedMultiplier);
            }
        } else {
            btn.classList.remove('active-auto');
        }
    },
    cleanup: function() {
        console.log("ğŸ§¹ Game cleanup started");
        
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.watchdog) {
            clearTimeout(this.watchdog);
            this.watchdog = null;
        }
        
        this.isOver = true;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        MusicEngine.stop();
        
        console.log("âœ… Game cleanup completed");
    },
	
    netRandom: function() {
        return getNetRandom();
    },

    init: function() {
        // íƒ€ì´ë¨¸ ì •ë¦¬
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // ìƒíƒœ ì´ˆê¸°í™”
        this.isOver = false;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        // BGM ì •ì§€
        MusicEngine.stop();
        
        // ë°ì´í„° ì´ˆê¸°í™”
        this.pool = [];
        this.selected = [];
        const allCombos = [{
            b: 'Metal',
            e: null
        }, {
            b: 'Tree',
            e: null
        }, {
            b: 'Fire',
            e: 'Light'
        }, {
            b: 'Water',
            e: 'Light'
        }, {
            b: 'Fire',
            e: null
        }, {
            b: 'Normal',
            e: null
        }, {
            b: 'Fire',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: null
        }, {
            b: 'Water',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Light'
        }, {
            b: 'Earth',
            e: 'Light'
        }, {
            b: 'Tree',
            e: 'Dark'
        }, {
            b: 'Water',
            e: null
        }, {
            b: 'Tree',
            e: 'Light'
        }, {
            b: 'Light',
            e: null
        }, {
            b: 'Light',
            e: 'Light'
        }, {
            b: 'Dark',
            e: null
        }, {
            b: 'Dark',
            e: 'Dark'
        }];
        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // [UI ê°œì„ ] ì˜¨ë¼ì¸ ë²„íŠ¼ì€ í•­ìƒ í™œì„±í™”, í´ë¦­ ì‹œ ëª¨ë‹¬ ì²˜ë¦¬
        const btnOnline = document.getElementById('btn-online');
        if (btnOnline) {
            btnOnline.style.backgroundColor = '#7e57c2';
        }

        this.checkMode();
    },

    // [UI ê°œì„ ] ëª¨ë‹¬ì—ì„œ ì½”ë“œ ì…ë ¥ í›„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    submitOnline: function() {
        const codeInput = document.getElementById('modal-room-code');
        const code = codeInput.value.trim();
        if (!code) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            codeInput.focus();
            return;
        }

        const btn = document.getElementById('modal-submit-btn');
        if (btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
        btn.disabled = true;
        btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";

        startOnlineGame(code);
    },

    renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block';
        grid.style.overflowY = 'auto';

        const categories = [
            { name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)", range: [0, 3], color: "#e3f2fd", border: "#90caf9" },
            { name: "âš”ï¸ ë”œëŸ¬ (Dealer)", range: [4, 13], color: "#ffebee", border: "#ef9a9a" },
            { name: "ğŸ§© ì§€ì› (Support)", range: [14, 19], color: "#f1f8e9", border: "#a5d6a7" }
        ];

        categories.forEach(cat => {
            // ì¹´í…Œê³ ë¦¬ í—¤ë”
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px 15px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:15px; border-radius:8px; color:#455a64; text-align:left; box-sizing:border-box; font-size:15px;`;
            header.innerText = cat.name;
            grid.appendChild(header);

            // ì¹´ë“œ ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ
            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(auto-fill, minmax(100px, 1fr)); gap:10px; padding:10px 0;";

            for (let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const key = u.getKey();
                const info = SKILL_DB[key];
                
                // [Patch v19.08] ì•„ì´ì½˜ ê°œì„ : ì˜¤ë²„ë ˆì´(ìš°ì¸¡í•˜ë‹¨) + ë…¸ë§(ë¹›/ì–´ë‘ ) ì»¤ìŠ¤í…€
                let iconsHtml = '';
                // 1. ê¸°ë³¸/ë³´ì¡° ì†ì„± ì•„ì´ì½˜ ê²°ì •
                let baseI = ATTR[u.base] ? ATTR[u.base].i : (info.icon || '?');
                let extraI = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : null;
                
                // 2. [Patch v19.10] Normal í‚¤ê°’ ë° ëŒ€ì†Œë¬¸ì ì˜¤ë¥˜ ìˆ˜ì •
                if (key === 'Normal') {
                    baseI = ATTR['Light'].i;
                    extraI = ATTR['Dark'].i;
                }

                // 3. ë Œë”ë§ (ë³´ì¡° ì†ì„±ì€ ìš°ì¸¡ í•˜ë‹¨ì— ì‘ì€ ì›í˜• ë±ƒì§€ë¡œ í‘œì‹œ)
                if (extraI) {
                    iconsHtml = `
                        <div style="position:relative; display:inline-block;">
                            <div class="tiny-icon">${baseI}</div>
                            <div class="tiny-icon" style="position:absolute; bottom:-5px; right:-5px; width:16px; height:16px; font-size:10px; z-index:5; border:1px solid #fff; background:rgba(255,255,255,0.9); border-radius:50%; display:flex; justify-content:center; align-items:center; box-shadow:0 1px 2px rgba(0,0,0,0.3);">${extraI}</div>
                        </div>`;
                } else {
                    iconsHtml = `<div class="tiny-icon">${baseI}</div>`;
                }

                // [2] ì´ë¦„ ë° ì„¤ëª… ê°„ì†Œí™”
                // ì´ë¦„ì—ì„œ ë¶ˆí•„ìš”í•œ ê´„í˜¸ ì œê±° (ì˜ˆ: "í‘¸ë¥¸ë¶ˆ (ë¶ˆ+ë¹›)" -> "í‘¸ë¥¸ë¶ˆ")
                const cleanName = u.name.split(' ')[0]; 
                // ì„¤ëª…ì€ ìŠ¤í‚¬DBì˜ ì§§ì€ ì„¤ëª… ì‚¬ìš© (ì˜ˆ: "ê´‘ì—­ ë”œëŸ¬")
                // HTML íƒœê·¸(<br>)ê°€ ìˆë‹¤ë©´ ì²« ì¤„ë§Œ ê°€ì ¸ì˜´
                let shortDesc = info.desc.split('<br>')[0];

                const imgUrl = IMAGE_DB[key] || IMAGE_DB['Default'];
                
                // ë°°ê²½ í‹´íŠ¸
                let tintColor = 'transparent';
                if(u.base === 'Fire') tintColor = 'rgba(255, 0, 0, 0.1)';
                else if(u.base === 'Water') tintColor = 'rgba(0, 0, 255, 0.1)';
                else if(u.base === 'Tree') tintColor = 'rgba(0, 255, 0, 0.1)';

                const el = document.createElement('div');
                // .unit í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì—¬ ì „íˆ¬ ì¹´ë“œ ìŠ¤íƒ€ì¼ì„ ê°€ì ¸ì˜¤ê³ , .hero-cardë¡œ ì„ íƒ í™”ë©´ ì „ìš© ìŠ¤íƒ€ì¼ ë®ì–´ì“°ê¸°
                el.className = 'unit hero-card'; 
                el.id = `card-${i}`;
                
                // [3] HTML ì¡°ë¦½
                el.innerHTML = `
                    <div class="unit-img-bg" style="background-image: url('${imgUrl}');">
                        <div style="position:absolute; inset:0; background:${tintColor};"></div>
                    </div>
                    
                    <div class="card-badge" style="top:5px; left:5px;">${iconsHtml}</div>

                    <div class="unit-info-overlay" style="padding-bottom:8px;">
                        <div class="card-name" style="font-size:15px; margin-bottom:2px;">${cleanName}</div>
                        <div style="font-size:10px; color:#ddd; font-weight:normal;">${shortDesc}</div>
                    </div>
                `;

                el.onclick = () => { this.toggle(i, el); };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },
    renderCard: function(u) {
    if (!u) return '';

    let bgClass = 'bg-' + u.base;
    if (u.isEnhanced) {
        bgClass = 'bg-' + u.base + '-Enhanced';
    } else if (u.isNormal) {
        bgClass = 'bg-Normal';
    }

    const key = u.getKey();
    const info = SKILL_DB[key];
    
    if (!info) {
        console.error('SKILL_DB missing for key:', key);
        return '<div class="attr-icon bg-Normal">?</div><div style="font-weight:bold;">ERROR</div>';
    }

    const mainIcon = info.icon || (ATTR[u.base] ? ATTR[u.base].i : '?');
    const baseIcon = ATTR[u.base] ? ATTR[u.base].i : '?';
    const extraIcon = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : '';
    const displayName = u.name ? u.name.split(' ')[0] : 'Unknown';
    const fullName = u.name || 'Unknown';
    const description = info.desc || 'ì •ë³´ ì—†ìŒ';

    let html = '<div class="attr-icon ' + bgClass + '">';
    html += mainIcon;
    html += '<div class="mini-attr-box">';
    html += '<div class="mini-icon">' + baseIcon + '</div>';
    if (extraIcon) {
        html += '<div class="mini-icon">' + extraIcon + '</div>';
    }
    html += '</div></div>';
    html += '<div style="font-weight:bold; margin-bottom:2px; font-size:15px;">' + displayName + '</div>';
    html += '<div style="font-size:11px; color:#999;">' + fullName + '</div>';
    html += '<div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">';
    html += description + '</div>';
    
    return html;
},
    toggle: function(i, el) {
        if (!el) el = document.getElementById(`card-${i}`);
        
        // [ì˜¤í”„ë¼ì¸ PVP ëª¨ë“œ ë¡œì§]
        const diff = document.getElementById('diff-select').value;
        if (diff === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;
            if (!this.p1Selection) this.p1Selection = [];
            if (!this.p2Selection) this.p2Selection = [];

            const isP1 = (this.pickTurn === 0);
            const list = isP1 ? this.p1Selection : this.p2Selection;
            
            // ì„ íƒ í† ê¸€ ë¡œì§
            if (list.includes(i)) {
                // ì´ë¯¸ ì„ íƒí–ˆë‹¤ë©´ í•´ì œ
                if (isP1) {
                    this.p1Selection = this.p1Selection.filter(x => x !== i);
                    el.classList.remove('selected');
                } else {
                    this.p2Selection = this.p2Selection.filter(x => x !== i);
                    el.classList.remove('p2-selected');
                }
            } else {
                // ì„ íƒ ì¶”ê°€ (ìµœëŒ€ 3ëª…)
                if (list.length >= 3) {
                    el.classList.add('shake');
                    setTimeout(() => el.classList.remove('shake'), 500);
                    return;
                }
                list.push(i);
                if (isP1) el.classList.add('selected');
                else el.classList.add('p2-selected');
            }
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ê°±ì‹ 
            const count = (isP1 ? this.p1Selection : this.p2Selection).length;
            const btn = document.getElementById('btn-start');
            btn.innerText = isP1 ? `ğŸ”´ 1P ì„ íƒ (${count}/3)` : `ğŸ”µ 2P ì„ íƒ (${count}/3)`;
            btn.disabled = count !== 3; // 3ëª…ì„ ë‹¤ ê³¨ë¼ì•¼ ë²„íŠ¼ í™œì„±í™”
            return;
        }

        // [ê¸°ì¡´ PVE/ì˜¨ë¼ì¸ ë¡œì§ ìœ ì§€]
        if (this.selected.includes(i)) {
            this.selected = this.selected.filter(x => x !== i);
            el.classList.remove('selected');
        } else {
            if (this.selected.length >= 3) {
                el.classList.add('shake');
                setTimeout(() => el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },
    randomPick: function() {
        const diff = document.getElementById('diff-select').value;

        // [A] ì˜¤í”„ë¼ì¸ 1:1 (Local) ëª¨ë“œ ì „ìš© ë¡œì§
        if (diff === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;
            const isP1 = (this.pickTurn === 0);
            const cssClass = isP1 ? 'selected' : 'p2-selected';

            // 1. ê¸°ì¡´ ì„ íƒ ì´ˆê¸°í™” (ì‹œê°ì  + ë°ì´í„°)
            const currentList = isP1 ? (this.p1Selection || []) : (this.p2Selection || []);
            currentList.forEach(idx => {
                const el = document.getElementById(`card-${idx}`);
                if (el) el.classList.remove(cssClass);
            });

            // 2. ë°ì´í„° ë°°ì—´ ì´ˆê¸°í™”
            if (isP1) this.p1Selection = [];
            else this.p2Selection = [];
            const targetList = isP1 ? this.p1Selection : this.p2Selection;

            // 3. ëœë¤ 3ëª… ë½‘ê¸° (ì¤‘ë³µ ì—†ì´)
            while (targetList.length < 3) {
                const r = Math.floor(Math.random() * 20);
                if (!targetList.includes(r)) {
                    targetList.push(r);
                    const el = document.getElementById(`card-${r}`);
                    if (el) el.classList.add(cssClass);
                }
            }

            // 4. ë²„íŠ¼ í…ìŠ¤íŠ¸ ê°±ì‹ 
            const btn = document.getElementById('btn-start');
            btn.innerText = isP1 ? `ğŸ”´ 1P ì„ íƒ (3/3)` : `ğŸ”µ 2P ì„ íƒ (3/3)`;
            btn.disabled = false;
            return;
        }

        // [B] ê¸°ì¡´ PvE / ì˜¨ë¼ì¸ ëª¨ë“œ ë¡œì§
        Game.selected.forEach(i => {
            const el = document.getElementById(`card-${i}`);
            if (el) el.classList.remove('selected');
        });
        Game.selected = [];
        while (Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if (!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.getElementById(`card-${r}`);
                if (el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        
        // [ê¸°ì¡´ ë¡œì§ ìœ ì§€] ì±Œë¦°ì§€ ëª¨ë“œ UI ì²˜ë¦¬
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            if (this.challengeStage > maxStage) this.challengeStage = maxStage;
            
            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }

        // ============================================================
        // [New Feature] ì˜¤í”„ë¼ì¸ PVP ëª¨ë“œ ì§„ì…/ì´íƒˆ ì‹œ 'ì„ íƒ ì´ˆê¸°í™”'
        // ============================================================
        const isLocal = (diff === 'local');
        
        // 1. ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ë³€ê²½í–ˆê±°ë‚˜
        // 2. ì´ë¯¸ ì„ íƒëœ ë°ì´í„°ê°€ ìˆëŠ”ë° ëª¨ë“œë¥¼ ë°”ê¿¨ë‹¤ë©´ -> ì´ˆê¸°í™”
        if (isLocal || (this.p1Selection && this.p1Selection.length > 0) || (this.p2Selection && this.p2Selection.length > 0)) {
            
            // ë°ì´í„° ì´ˆê¸°í™”
            this.selected = [];
            this.p1Selection = [];
            this.p2Selection = [];
            this.pickTurn = 0;
            
            // ì‹œê°ì  ì„ íƒ í•´ì œ (íšŒìƒ‰/íŒŒë€ìƒ‰/í”ë“¤ë¦¼ ì œê±°)
            const cards = document.querySelectorAll('.hero-card');
            cards.forEach(el => {
                el.classList.remove('selected');
                el.classList.remove('p2-selected');
                el.classList.remove('shake');
            });
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            const btn = document.getElementById('btn-start');
            if (isLocal) {
                btn.innerText = "ğŸ”´ 1P ì„ íƒ (0/3)";
            } else {
                btn.innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
            }
            btn.disabled = true;
        }
    },
    
    // [ìœ ì§€] ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ ì„ íƒ (ì‚­ì œ ê¸ˆì§€!)
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    
    // [ìœ ì§€] ìŠ¤í…Œì´ì§€ ì •ë³´ ê°±ì‹  (ì‚­ì œ ê¸ˆì§€!)
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },
    start: function() {
        AudioSys.init();
        AudioSys.resume();
        // [ìˆ˜ì •] ê²Œì„ ì‹œì‘ ì‹œ 'Start.mp3' ì¬ìƒ (íŒŒì¼ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ì „ììŒ ì „í™˜ë¨)
        MusicEngine.play('Start'); 
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        // =========================================
        // [1] ì˜¤í”„ë¼ì¸ PVP (1:1) ëª¨ë“œ ë¡œì§
        // =========================================
        if (diffVal === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;

            // [ë‹¨ê³„ A] 1P ì„ íƒ ì™„ë£Œ ì‹œì  -> 2P í„´ìœ¼ë¡œ ë„˜ê¸°ê¸°
            if (this.pickTurn === 0) {
                this.pickTurn = 1; // í„´ ë„˜ê¹€
                alert("ğŸ”´ 1P ì„ íƒ ì™„ë£Œ!\nğŸ”µ 2P(íŒŒë€íŒ€)ê°€ ì„ íƒí•  ì°¨ë¡€ì…ë‹ˆë‹¤.\n(ì¤‘ë³µ ì„ íƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤)");
                
                // 1Pê°€ ê³ ë¥¸ ì¹´ë“œë“¤ì˜ 'ì„ íƒë¨(íšŒìƒ‰)' í‘œì‹œ ì œê±° -> 2Pê°€ ë‹¤ì‹œ ê³ ë¥¼ ìˆ˜ ìˆê²Œ í•¨
                const cards = document.querySelectorAll('.hero-card');
                cards.forEach(c => c.classList.remove('selected'));
                
                // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
                const btn = document.getElementById('btn-start');
                btn.innerText = "ğŸ”µ 2P ì„ íƒ (0/3)";
                btn.disabled = true;
                
                // ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ (ê²Œì„ì„ ì‹œì‘í•˜ì§€ ì•Šê³  2P ì…ë ¥ì„ ê¸°ë‹¤ë¦¼)
                return;
            }
            
            // [ë‹¨ê³„ B] 2P ì„ íƒ ì™„ë£Œ ì‹œì  -> ì‹¤ì œ ê²Œì„ ë°ì´í„° ìƒì„±
            // 1P íŒ€ ìƒì„±
            this.pTeam = (this.p1Selection || []).map((idx, i) => {
                const u = this.pool[idx];
                return new Unit(i, 0, u.base, u.extra);
            });
            // 2P íŒ€ ìƒì„± (ì¤‘ë³µ í”½ í—ˆìš©ë¨, íŒ€ ID 1)
            this.eTeam = (this.p2Selection || []).map((idx, i) => {
                const u = this.pool[idx];
                return new Unit(i + 3, 1, u.base, u.extra);
            });
            
            // ë‹¤ìŒ íŒì„ ìœ„í•´ í”½ ë³€ìˆ˜ ì´ˆê¸°í™”
            this.pickTurn = 0; 
            this.p1Selection = [];
            this.p2Selection = [];

        } else {
            // =========================================
            // [2] PVE (ì‹±ê¸€/íŠœí† ë¦¬ì–¼) í†µí•© ë¡œì§
            // =========================================
            
            // ğŸŸ¢ [A] íŠœí† ë¦¬ì–¼ ëª¨ë“œ: ê°•ì œ ì„¸íŒ…
            if (this.difficulty === 'tutorial') {
                if (!this.tStage) this.tStage = 1; 
                
                let pDeck = [], eDeck = [];
                let guideMsg = "";

                // ë‹¨ê³„ë³„ ë°ì´í„° ì •ì˜
                if (this.tStage === 1) {
                    // [ìˆ˜ì •] 1ë‹¨ê³„: ë¶ˆ vs ë‚˜ë¬´/ë¬¼/ì‡ 
                    pDeck = ['Fire', 'Normal', 'Normal'];
                    eDeck = ['Tree', 'Water', 'Metal'];
                    guideMsg = "Lesson 1: <b>ì†ì„± ìƒì„± ê¸°ì´ˆ</b><br>ë¶ˆ(ğŸ”¥)ë¡œ ì ë“¤ì„ ê³µê²©í•˜ë©° ë°ë¯¸ì§€(ì•½ì /ì €í•­) ì°¨ì´ë¥¼ í™•ì¸í•˜ì„¸ìš”!<br>(ì ì€ í›ˆë ¨ìš© ìƒŒë“œë°± ìƒíƒœì…ë‹ˆë‹¤)";
                } else if (this.tStage === 2) {
                    // 2ë‹¨ê³„: íƒ±ì»¤/ë”œëŸ¬
                    pDeck = ['Metal', 'Water', 'Normal'];
                    eDeck = ['Earth', 'Earth'];
                    guideMsg = "Lesson 2: ì‡ (âš”ï¸)ì˜ <b>[ë„ë°œ]</b>ë¡œ ì•„êµ°ì„ ë³´í˜¸í•˜ê³ , ğŸ’§ ë¬¼ë¡œ ê³µê²©í•˜ì„¸ìš”!";
                } else if (this.tStage === 3) {
                    // 3ë‹¨ê³„: í/CC (ì—¬ê¸°ê°€ ë¬¸ì œì˜€ìŒ)
                    pDeck = ['Tree', 'Metal-Dark', 'Normal'];
                    eDeck = ['Metal-Light', 'Metal'];
                    guideMsg = "Lesson 3: ë‚˜ë¬´(ğŸŒ¿)ì˜ <b>[ì¹˜ìœ ]</b>ì™€ âš¡ ì „ê¸°ì˜ <b>[ì„±ì¥]</b>ì„ í™œìš©í•˜ì„¸ìš”!";
                } else {
                    alert("ğŸ‰ íŠœí† ë¦¬ì–¼ ì™„ë£Œ! ì´ì œ ì‹¤ì „ì…ë‹ˆë‹¤.");
                    this.tStage = 1; location.reload(); return;
                }

                // [ì¤‘ìš”] í”Œë ˆì´ì–´ íŒ€ ìƒì„± (ë³µí•© ì†ì„± íŒŒì‹± ë¡œì§ í¬í•¨ - í•˜ë‚˜ë§Œ ìˆì–´ì•¼ í•¨!)
                this.pTeam = pDeck.map((key, i) => {
                    let base = key, extra = null;
                    // '-'ê°€ ìˆìœ¼ë©´ ë¶„ë¦¬, ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ
                    if (key !== 'Normal' && key.includes('-')) {
                        [base, extra] = key.split('-');
                    } else {
                        base = key;
                    }
                    
                    const u = new Unit(i, 0, base, extra);
                    if(key === 'Normal') { u.hp = 0; u.isDead = true; } 
                    return u;
                });
                
                // [ì¤‘ìš”] ì  íŒ€ ìƒì„± (ë³µí•© ì†ì„± íŒŒì‹± + ë„ˆí”„ ë¡œì§)
                this.eTeam = eDeck.map((key, i) => {
                    let base = key, extra = null;
                    if (key !== 'Normal' && key.includes('-')) {
                        [base, extra] = key.split('-');
                    } else {
                        base = key;
                    }

                    const u = new Unit(i+3, 1, base, extra);
                    
                    if (this.tStage === 1) {
                        // 1ë‹¨ê³„: ìƒŒë“œë°±
                        u.maxHp = 100; u.hp = 100;
                        u.addStatus('SILENCE', 999, 0, null, true);
                        u.name = `[í›ˆë ¨] ${u.name}`;
                    } else if (this.tStage === 2) {
                        // 2ë‹¨ê³„: ì²´ë ¥ 40%
                        u.maxHp = Math.floor(u.maxHp * 0.4); u.hp = u.maxHp;
                        u.name = `[ì‹¤ìŠµ] ${u.name}`;
                    } else {
                        // 3ë‹¨ê³„: ì²´ë ¥ 50%
                        u.maxHp = Math.floor(u.maxHp * 0.5); u.hp = u.maxHp;
                        u.name = `[ì‹¤ìŠµ] ${u.name}`;
                    }
                    return u;
                });

                // ì‹œì‘ ì‹œ ê°€ì´ë“œ ë©”ì‹œì§€ ì˜ˆì•½
                setTimeout(() => UI.showModal(`Lesson ${this.tStage}`, guideMsg), 500);

            } else {
                // ğŸ”µ [B] ì¼ë°˜ PVE ëª¨ë“œ: í”Œë ˆì´ì–´ ì„ íƒ ê¸°ë°˜ ìƒì„±
                if (!this.selected || this.selected.length < 3) {
                    alert("ì˜ì›… 3ëª…ì„ ì„ íƒí•˜ê±°ë‚˜ 'ëœë¤'ì„ ëˆ„ë¥´ì„¸ìš”!"); return; 
                }

                this.pTeam = this.selected.map((idx, i) => {
                    const u = this.pool[idx];
                    u.id = i; u.team = 0;
                    return u;
                });
                
                this.eTeam = [];
                const makeEnemy = (idx, b, e) => new Unit(idx + 3, 1, b, e);

                if (this.difficulty === 'hell') {
                    if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
                    const stageData = ChallengeDB[this.challengeStage];
                    let currentTeamList = [...stageData.team];
                    if (!stageData.fixedOrder) currentTeamList.sort(() => Math.random() - 0.5);
                    this.eTeam = currentTeamList.map((key, i) => {
                        let b, e;
                        if (key === 'Normal') { b = 'Normal'; e = null; } 
                        else if (key.includes('-')) { [b, e] = key.split('-'); } 
                        else { b = key; e = null; }
                        return makeEnemy(i, b, e);
                    });
                } else if (this.difficulty === 'mirror') {
                    this.eTeam = this.pTeam.map((pu, i) => {
                        const u = new Unit(i + 3, 1, pu.base, pu.extra);
                        u.maxHp = Math.floor(u.maxHp * 1.15); u.hp = u.maxHp; u.atk = Math.floor(u.atk * 1.15);
                        return u;
                    });
                } else if (this.difficulty === 'easy') {
                    const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
                    while (this.eTeam.length < 3) {
                        const b = basics[Math.floor(Math.random() * basics.length)];
                        if (!this.eTeam.some(u => u.base === b)) this.eTeam.push(makeEnemy(this.eTeam.length, b, null));
                    }
                } else if (this.difficulty === 'hard') {
                    const used = new Set();
                    while (this.eTeam.length < 3) {
                        const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                        const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                        let key = `${b}-${e}`;
                        if (!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
                    }
                } else {
                    const used = new Set();
                    while (this.eTeam.length < 3) {
                        const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                        const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                        if (b === 'Dark' && e === 'Light') continue;
                        let key = `${b}-${e}`;
                        if (b === 'Light' && e === 'Dark') key = 'Normal';
                        if (!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
                    }
                }
            }
        }

        // =========================================
        // [3] ê³µí†µ ì´ˆê¸°í™” (í™”ë©´ ì „í™˜, ë¡œê·¸, í„´ ì„¤ì •)
        // =========================================
        this.isOver = false;
        this.queue = [0, 1, 2, 3, 4, 5];
        
        // [Fix] ì˜¨ë¼ì¸ ëª¨ë“œ ë™ê¸°í™”: ì´ˆê¸° í„´ ìˆœì„œë„ ì‹œë“œ ê¸°ë°˜ RNG ì‚¬ìš©
        if (typeof isOnlineMode !== 'undefined' && isOnlineMode && typeof globalRNG !== 'undefined' && globalRNG) {
            this.curr = Math.floor(globalRNG.next() * 6);
        } else {
            this.curr = Math.floor(Math.random() * 6);
        }
        
        this.turnCount = 1;
        this.globalRound = 1; // [ì‹ ê·œ] ë¼ìš´ë“œ ì¹´ìš´í„° ì´ˆê¸°í™”
        this.isProcessing = false;
        
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('battle-screen').style.display = 'flex';
        document.getElementById('logs').innerHTML = '';
        
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        if (this.difficulty === 'local') diffText = 'ğŸ“´ ì˜¤í”„ë¼ì¸ 1:1';
        
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);

        // [ì¤‘ìš”] ì„ /í›„ê³µ ë³´ì • ë¡œì§ (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„)
        const firstTurnUnitId = (this.queue[this.curr] % 2 === 0 ? this.queue[this.curr] / 2 : (this.queue[this.curr] - 1) / 2 + 3);
        const firstTurnTeam = this.queue[this.curr] % 2; // 0 (PíŒ€) or 1 (EíŒ€)
        const secondTeam = firstTurnTeam === 0 ? this.eTeam : this.pTeam;

        // [ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜] í›„ê³µ íŒ€ ë³´ì •: ë©´ì—­ ë¶€ì—¬ (ìƒì¡´ë ¥)
        secondTeam.forEach(u => {
            u.addStatus('START_IMMUNITY', 99, 0, null, true);
            // ì‰´ë“œ +100 ì‚­ì œë¨
        });

        // [ì‹ ê·œ] í›„ê³µ ì²« ë²ˆì§¸ ìºë¦­í„°(ì„ ë´‰)ì—ê²Œë§Œ '1í„´ê°„ ë°ë¯¸ì§€ 10% ì¦ê°€' ë¶€ì—¬ (ë°˜ê²© ëŠ¥ë ¥)
        if (secondTeam.length > 0) {
            secondTeam[0].addStatus('DMG_UP_10', 1, 0, null, true);
        }
        
        const teamName = firstTurnTeam === 0 ? 'ì êµ°(í›„ê³µ)' : 'ì•„êµ°(í›„ê³µ)';
        this.log(`<span class='log-sys' style='color:#7986cb;'>ğŸ›¡ï¸ [í›„ê³µ ë³´ì •] ${teamName}ì—ê²Œ ë©´ì—­ ë° <b>ì„ ë´‰ ë”œëŸ¬ ê°•í™”(+10%)</b> ì ìš©!</span>`);

        // [ì¤‘ìš”] ê²Œì„ ë£¨í”„ ì‹œì‘ (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„)
        this.render();
        if (this.timer) clearTimeout(this.timer);

        this.timer = setTimeout(() => this.turn(), 1000);
    },

turn: function() {
        const battleScreen = document.getElementById('battle-screen');
        if (this.isOver || !battleScreen || battleScreen.style.display === 'none') {
            console.warn("âš ï¸ Turn called but game is over or not visible");
            this.cleanup();
            return;
        }
        
        this.isProcessing = false;
        if (this.isOver) return;

        // [Fix] ì„¸ë‡Œ ëŒ€ìƒ ì‚¬ë§ ì‹œ ì•ˆì „í•˜ê²Œ í•´ì œ
        if (this.isMindControlling && this.isMindControlling.isDead) {
            this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ëŒ€ìƒì´ ì‚¬ë§í•˜ì—¬ ì œì–´ê¶Œì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.</span>");
            this.isMindControlling = null;
            this.currentMCCasterId = null;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }

        const round = this.globalRound;
        const tVal = this.queue[this.curr];
        
        // [Fix] ìœ ë‹› ì •ì˜ ë° null/undefined ì²´í¬ ê°•í™”
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        
        // [Fix] ìœ ë‹›ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì´ë¯¸ ì£½ì—ˆìœ¼ë©´ ì¦‰ì‹œ í„´ ì¢…ë£Œ
        if (!u || u.isDead) {
            console.error('âŒ Turn error: Unit not found or dead', { tVal, u });
            this.endTurn(true);
            return;
        }

// [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ì¸ê²Œì„ íŒ (í„´ ì‹œì‘ ì‹œ)
        if (this.difficulty === 'tutorial' && u && u.team === 0 && !u.isDead) {
            let tip = "";
            if (this.tStage === 1) tip = "Tip: ë¶ˆ(Fire) ìŠ¤í‚¬ë¡œ ë‚˜ë¬´ë¥¼ ê³µê²©í•˜ì„¸ìš”! (1.2ë°°)";
            if (this.tStage === 2) {
                 if(u.base === 'Metal') tip = "Tip: 2ë²ˆ ìŠ¤í‚¬ [ê²°íˆ¬ ì‹ ì²­]ì„ ì¨ì„œ ì–´ê·¸ë¡œë¥¼ ë„ì„¸ìš”!";
                 else if(u.base === 'Water') tip = "Tip: ì‡ ê°€ ë§ëŠ” ë™ì•ˆ ë¬¼ ì†ì„±ìœ¼ë¡œ ë”œì„ ë„£ìœ¼ì„¸ìš”!";
            }
            if (this.tStage === 3) {
                 if(u.base === 'Tree') tip = "Tip: ì•„êµ°ì´ ìœ„í—˜í•˜ë©´ 2ë²ˆ ìŠ¤í‚¬ [ì¹˜ìœ ]ë¥¼ ì“°ì„¸ìš”.";
                 else if(u.base.includes('Metal')) tip = "Tip: ì „ê¸°ì˜ ê³µê²©ì€ ë°˜ë³µí• ìˆ˜ë¡ ê°•í•´ì§‘ë‹ˆë‹¤.";
            }
            if (tip) this.log(`<span style="color:#2ecc71; font-weight:bold;">${tip}</span>`);
        }

        // 2. [ë¡œì§ ì‚­ì œë¨] ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ì–´, ì‚¬ì „ ì¤€ë¹„(MC_READY) ë‹¨ê³„ê°€ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
        // (ì´ê³³ì— ìˆë˜ ë¬¸ë²• ì˜¤ë¥˜ ë° êµ¬ë²„ì „ ë¡œì§ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.)


        // 3. [ê¶Œí•œ íŒì •] ì¡°ì‘ ê¶Œí•œ ì„¤ì • (ëª¨ë“  ìœ ë‹› ê³µí†µ ë¡œì§)
        // ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ íŒ€(0)ì´ë©´ ë‚´ í„´.
        let isMyTurn = (u.team === 0);
        let isPuppetTurn = false;

        // ì„¸ë‡Œ ìƒíƒœ ì²´í¬: í˜„ì¬ í„´ ìœ ë‹›ì´ ì„¸ë‡Œëœ ëŒ€ìƒì´ê³ , ì„¸ë‡Œì˜ ì£¼ì²´ê°€ 'ë‚˜'ì¸ê°€?
        if (this.isMindControlling && this.isMindControlling.id === u.id) {
            // ê°„ë‹¨ í•´ê²°: ë‚´ íŒ€ì´ ì•„ë‹Œë°(ì êµ°ì¸ë°) ì„¸ë‡Œ ë³€ìˆ˜ê°€ ì¼œì ¸ìˆë‹¤ë©´, ë‚´ê°€ ì¡°ì¢…í•˜ëŠ” ê²ƒì„.
            if (u.team !== 0) { 
                isMyTurn = true; 
                isPuppetTurn = true; 
            } else {
                // ë°˜ëŒ€ë¡œ ë‚´ ìœ ë‹›ì´ ì ì—ê²Œ ì„¸ë‡Œë‹¹í–ˆë‹¤ë©´? -> ì¡°ì‘ ê¶Œí•œ ë°•íƒˆ
                isMyTurn = false;
            }
        }

        // 4. AI ê°ì‹œì (Watchdog) ë° ì¢…ë£Œ ì²´í¬
        if (this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            // ì˜¤í”„ë¼ì¸ AIì „ì¼ ë•Œë§Œ ê°•ì œ í„´ ë„˜ê¹€ ê°€ë™
            this.watchdog = setTimeout(() => {
                console.log("AI Stuck. Forcing next.");
                this.endTurn();
            }, 4000); // 3ì´ˆ -> 4ì´ˆë¡œ ì—¬ìœ  í™•ë³´
        } else if (isOnlineMode) {
            // [Fix] ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ì„ì˜ë¡œ í„´ì„ ë„˜ê¸°ì§€ ì•Šë„ë¡ í™•ì‹¤íˆ í•´ì œ
            if (this.watchdog) clearTimeout(this.watchdog);
        }
        if (this.endCheck()) return;

        // 5. [Patch] ë„íŠ¸ ë°ë¯¸ì§€ ë° í„´ ì‹œì‘ ë¡œì§ ìµœì í™” (ë ‰ ë°©ì§€)
        if (!u.isDead) {
            u.resetTurn();
            
            // (1) ë„íŠ¸ ë°ë¯¸ì§€ ê³„ì‚° (ë Œë”ë§ ë¶„ë¦¬)
            const dotLogs = u.tickStatus();
            
            // (2) ë¡œê·¸ ì¶œë ¥ ë° ë Œë”ë§ (ë³€ê²½ì‚¬í•­ì´ ìˆì„ ë•Œë§Œ 1íšŒ ìˆ˜í–‰)
            if (dotLogs.length > 0) {
                dotLogs.forEach(log => this.log(log));
                this.render(); // ì—¬ê¸°ì„œ 1íšŒë§Œ ë Œë”ë§
            }
            
            // (3) ë„íŠ¸ ë°ë¯¸ì§€ë¡œ ì¸í•œ ì‚¬ë§ ì²´í¬ (ì¦‰ì‹œ ì¢…ë£Œ)
            if (u.isDead) {
                this.log(`<span class='log-crit'>â˜ ï¸ [${u.name}] ìƒíƒœì´ìƒ í”¼í•´ë¡œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤!</span>`);
                // ì•½ê°„ì˜ ë”œë ˆì´ë¥¼ ì£¼ì–´ ì‚¬ë§ ì—°ì¶œì„ ë³¼ ì‹œê°„ì„ ì¤Œ
                setTimeout(() => this.endTurn(true), 500); 
                return;
            }

            // (4) [í›„ê³µ ë³´ì •] í•´ì œ ë¡œì§
            if (u.hasStatus('START_IMMUNITY')) {
                const myTeam = u.team === 0 ? this.pTeam : this.eTeam;
                let removed = false;
                myTeam.forEach(member => {
                    if(member.hasStatus('START_IMMUNITY')) {
                        member.status = member.status.filter(s => s.type !== 'START_IMMUNITY');
                        removed = true;
                    }
                });
                if (removed) {
                    this.log(`<span class='log-sys'>ğŸ”“ [${u.team===0?'ì•„êµ°':'ì êµ°'}] ì „ìˆ  ë³´í˜¸ë§‰ í•´ì œ</span>`);
                    // ë Œë”ë§ì€ ìœ„ì—ì„œ ë„íŠ¸ë€ìœ¼ë¡œ ì´ë¯¸ í–ˆìœ¼ë©´ ìƒëµí•˜ê±°ë‚˜, í•„ìš”ì‹œì—ë§Œ ìˆ˜í–‰
                    if (dotLogs.length === 0) this.render(); 
                }
            }
        }

        // 5-2. í–‰ë™ ë¶ˆê°€(CC) ì²´í¬ (ìš°ì„ ìˆœìœ„: ì‚¬ë§ > ê¸°ì ˆ/ë¹™ê²° > ì„¸ë‡Œ)
        const hasCC = u.hasStatus('STUN') || u.hasStatus('FREEZE') || u.hasStatus('SLEEP');
        
        if (hasCC) {
            UI.floatText(u, "í–‰ë™ë¶ˆê°€", "ft-miss");
            this.log(`<span class='log-crit'>ğŸš« [${u.name}] ìƒíƒœì´ìƒìœ¼ë¡œ í–‰ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
            
            // [Fix] ì„¸ë‡Œ ì˜ˆì•½(MC_WAIT) ì¤‘ ê¸°ì ˆ ì‹œ ì˜ˆì•½ ì·¨ì†Œ
            if (u.hasStatus('MC_WAIT')) {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸŒ€ [${u.name}] ê¸°ì ˆí•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ ë¶ˆë°œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
            
            // [Fix] ì´ë¯¸ ì¡°ì¢… ì¤‘(ì„¸ë‡Œ ìƒíƒœ)ì¼ ë•Œ ê¸°ì ˆí•˜ë©´, í„´ ê¼¬ì„ ë°©ì§€ë¥¼ ìœ„í•´ ì¤‘ë³µ ì‹¤í–‰ ì°¨ë‹¨ í›„ í„´ ì¢…ë£Œ
            this.isProcessing = true; 
            setTimeout(() => {
                this.isProcessing = false; // íƒ€ì„ì•„ì›ƒ í›„ í•´ì œ
                this.endTurn();
            }, 1000);
            return;
        }
        
        // (ì—¬ê¸° ìˆë˜ ì¤‘ë³µ ì½”ë“œë“¤ì„ ê¹¨ë—ì´ ì§€ì› ìŠµë‹ˆë‹¤)

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        // 6. [ì„¸ë‡Œ ë°œë™] í„´ í•˜ì´ì¬í‚¹ (ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨)
        const mcWaitStatus = u.status.find(s => s.type === 'MC_WAIT');
        if (mcWaitStatus) {
            // ì‹œì „ì(ì£¼ì¸) í™•ì¸
            let caster = null;
            if (mcWaitStatus.sourceId !== undefined && mcWaitStatus.sourceId !== -1) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                caster = allUnits.find(unit => unit.id === mcWaitStatus.sourceId);
            }

                    // ì‹œì „ìê°€ ë‚´ íŒ€ì´ë©´ -> ë‚´ í„´ìœ¼ë¡œ ê°•ì œ ì „í™˜ (ëª¨ë“  ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥)
        if (caster && !caster.isDead && caster.team === 0) {
            // [ìˆ˜ì •] ì„¸ë‡Œ ì„±ê³µ ì‹œ, ì´ë¯¸ ëŒì•„ê°€ê³  ìˆëŠ” AI ê°ì‹œì(Watchdog)ë¥¼ ë°˜ë“œì‹œ êº¼ì•¼ í•¨
            if (this.watchdog) clearTimeout(this.watchdog);

            isMyTurn = true;
            isPuppetTurn = true;
            this.isMindControlling = u; // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
            this.currentMCCasterId = caster.id; // [ì¶”ê°€] ì‹œì „ì ID ì €ì¥ (ì‚¬ë§ íŒì •ìš©)

            this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°° ì„±ê³µ! ì œì–´ê¶Œì„ íƒˆì·¨í–ˆìŠµë‹ˆë‹¤.</span>`);

                UI.floatText(u, "ì œì–´ê¶Œ íšë“", "ft-crit");
                UI.playVFX(u, 'mc-flip'); // [ì‹ ê·œ] ì¹´ë“œ ë’¤ì§‘ê¸° ì—°ì¶œ
                
                // ìƒíƒœ ì œê±° (ì´ë²ˆ í„´ì— ë°”ë¡œ í–‰ë™í•˜ë¯€ë¡œ ìƒíƒœ ì•„ì´ì½˜ ì‚­ì œ)
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            } 
            // ì‹œì „ìê°€ ì  íŒ€ì´ë©´ -> ì ì´ ì¡°ì¢… (ë‚´ ì…ë ¥ ì°¨ë‹¨)
            else if (caster && !caster.isDead && caster.team === 1) {
                isMyTurn = false;
                this.isMindControlling = u;
                
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì ì—ê²Œ ì¡°ì¢…ë‹¹í•©ë‹ˆë‹¤!</span>`);
                UI.playVFX(u, 'mc-flip'); // [ì‹ ê·œ] ì¹´ë“œ ë’¤ì§‘ê¸° ì—°ì¶œ
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            }
            // ì‹œì „ìê°€ ì£½ì—ˆìœ¼ë©´ í•´ì œ
            else {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ìê°€ ì‚¬ë§í•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤.</span>`);
            }
            
            // ì£¼ì˜: ê¸°ì¡´ì˜ 'return'ì„ ì‚­ì œí•˜ì—¬ ì•„ë˜ì˜ input() ë¡œì§ìœ¼ë¡œ íë¥´ê²Œ í•¨
        }

        // 7. [UI ì—…ë°ì´íŠ¸] ë°°ë„ˆ ë° ë©”ì‹œì§€
        let turnName = u.name.split(' ')[0];
        let indicatorText = `Round ${round} : ${turnName}`;
        
        if (isPuppetTurn) {
            UI.showTurnBanner(true);
            indicatorText = `ğŸ§  ì •ì‹  ì§€ë°° ì¤‘! [${turnName}] ì¡°ì¢…í•˜ì„¸ìš”!`;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #d500f9";
        } else if (isMyTurn) {
            UI.showTurnBanner(true);
            if (this.mode === 'pvp') indicatorText += " (ë‚˜)";
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ff80ab";
        } else {
            UI.showTurnBanner(false);
            if (this.mode === 'pvp') indicatorText = "ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
            if (this.isMindControlling && u.id === this.isMindControlling.id && u.team === 0) {
                 indicatorText = "ğŸ§  ë‚´ ìœ ë‹›ì´ ì¡°ì¢…ë‹¹í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
            }
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }
        
        document.getElementById('turn-indicator').innerText = indicatorText;
        // [ì‚­ì œ] ìƒˆ ì—”ì§„ì€ ê³¡ ë³€ê²½ ë°©ì‹ì´ë¯€ë¡œ í…œí¬ ì¡°ì ˆ ë¶ˆí•„ìš”
        // const danger = ... 
        // MusicEngine.play('Crisis_Track'); // í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì„œ ìœ„ê¸° ì „ìš© ê³¡ ì¬ìƒ ê°€ëŠ¥
        this.turnCount++;

        // 8. [ì…ë ¥ í™œì„±í™” ì—¬ë¶€ ê²°ì •]
        if (isMyTurn || this.difficulty === 'local') {
            // [Patch v19.14] ì˜¤í†  ë°°í‹€ ì²´í¬ (PVP/ë¡œì»¬ ì œì™¸)
            if (this.isAutoBattle && isMyTurn && !this.difficulty.includes('pvp') && this.difficulty !== 'local') {
                this.noInput();
                if (this.timer) clearTimeout(this.timer);
                if (this.timer) clearTimeout(this.timer);

                this.timer = setTimeout(() => this.ai(u), 800 * this.speedMultiplier);
            } else {
                this.input(u);
                if (isPuppetTurn) {
                    setTimeout(() => {
                        const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                        const el = document.getElementById(cardId);
                        if(el) UI.showTooltip(u, el);
                    }, 100);
                }
            }
        } else {
            this.noInput();
            if (this.mode !== 'pvp') {
                if (this.timer) clearTimeout(this.timer);
                // [Patch v19.14] AI ëŒ€ê¸° ì‹œê°„ ë°°ì† ì ìš©
                if (this.timer) clearTimeout(this.timer);

                this.timer = setTimeout(() => this.ai(u), 800 * this.speedMultiplier);
            }
        }
    },

    render: function() {
        // [ìˆ˜ì • ì™„ë£Œ] íƒ€ì„ë¼ì¸ ì½”ë“œ ì™„ì „ ì œê±°ë¨
        
        // 1. ìœ ë‹› ê·¸ë¦¬ê¸°
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            if (!row) return;

            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if (!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });
            
            team.forEach((u) => {
                const cardId = tid === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }
                
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isSuper ? 'super-hero' : ''} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;

				// ğŸŸ¢ [ì¶”ê°€] ì„¸ë‡Œ(Mind Control) ì‹œê° íš¨ê³¼ (ë³´ë¼ìƒ‰ ì˜¤ë¼ + ì•„ì´ì½˜)
                // MC_READY ìƒíƒœê±°ë‚˜, í˜„ì¬ ì„¸ë‡Œ ì¡°ì¢… ì¤‘ì¸ ìœ ë‹›ì¼ ê²½ìš°
                const isPuppet = u.hasStatus('MC_READY') || (this.isMindControlling && this.isMindControlling.id === u.id);
                if (isPuppet) {
                    d.style.filter = 'hue-rotate(270deg) sepia(1) saturate(3)'; // ë³´ë¼ìƒ‰ìœ¼ë¡œ ë³€ì¡°
                    d.style.boxShadow = '0 0 15px #b026ff'; // ë³´ë¼ìƒ‰ ê´‘ì±„

                    // (ì„ íƒì‚¬í•­) ë¨¸ë¦¬ ìœ„ì— ì•„ì´ì½˜ í‘œì‹œ
                    if (!d.querySelector('.mc-icon')) {
                        const icon = document.createElement('div');
                        icon.className = 'mc-icon';
                        icon.innerText = 'ğŸ§ ';
                        icon.style.cssText = 'position:absolute; top:-15px; left:50%; transform:translateX(-50%); font-size:20px; z-index:10; animation: bounce 1s infinite;';
                        d.appendChild(icon);
                }
            } else {
                d.style.filter = ''; // íš¨ê³¼ ì œê±°
                d.style.boxShadow = '';
                const icon = d.querySelector('.mc-icon');
                if (icon) icon.remove();
            }
				
                // ì´ë²¤íŠ¸ ì—°ê²°
                d.onclick = (e) => {
                    // í„°ì¹˜ ë“œë˜ê·¸ë‚˜ ë¡±í”„ë ˆìŠ¤ í›„ ì†ì„ ë—ì„ ë•Œ í´ë¦­ìœ¼ë¡œ ì¸ì‹ë˜ëŠ” ê²ƒ ë°©ì§€
                    if (isTouching) return; 
        
                    if (Game.selectedSkillIdx !== -1) return;
                    if (u.team === 0) { UI.showEmoteMenu(u, d); e.stopPropagation(); }
                };

                // [Patch v19.11] íˆ´íŒ UX ê°œì„  (ë°˜ì‘ì†ë„ 0.5ì´ˆ + ì† ë–¼ë©´ ë‹«ê¸°)
            let longPressTimer = null;
            let isTouching = false;

            d.ontouchstart = (e) => {
                // ìŠ¤í¬ë¡¤ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì‘ë™í•˜ë„ë¡ ê¸°ë³¸ ë™ì‘ ìœ ì§€
                isTouching = true;
                longPressTimer = setTimeout(() => {
                    UI.showTooltip(u, d); // 0.5ì´ˆë©´ ì¶©ë¶„í•¨
                    // í„°ì¹˜ ì‹œ ì§„ë™ í”¼ë“œë°± (ì§€ì› ê¸°ê¸°ë§Œ)
                    if (navigator.vibrate) navigator.vibrate(20); 
                }, 500); 
            };

            d.ontouchend = () => {
                if (longPressTimer) clearTimeout(longPressTimer);
                UI.hideTooltip(); // [Fix] ì†ì„ ë–¼ë©´ íˆ´íŒë„ ë‹«í˜€ì•¼ í•¨
                setTimeout(() => isTouching = false, 300);
            };

            d.ontouchcancel = () => { // í„°ì¹˜ê°€ ìº”ìŠ¬ëì„ ë•Œ(ì „í™” ë“±)ë„ ì²˜ë¦¬
                if (longPressTimer) clearTimeout(longPressTimer);
                UI.hideTooltip();
                isTouching = false;
            };

                d.ontouchend = () => {
                    if (longPressTimer) clearTimeout(longPressTimer); // ì† ë–¼ë©´ íƒ€ì´ë¨¸ ì·¨ì†Œ
                    setTimeout(() => isTouching = false, 500); // í”Œë˜ê·¸ í•´ì œ ì§€ì—° (ë§ˆìš°ìŠ¤ì—”í„° ë°©ì§€)
                };

                d.ontouchmove = () => {
                    if (longPressTimer) clearTimeout(longPressTimer); // ìŠ¤í¬ë¡¤ ì‹œ íƒ€ì´ë¨¸ ì·¨ì†Œ
                };

                d.onmouseenter = () => {
                     // [ìˆ˜ì •] í„°ì¹˜(íƒ­) ë™ì‘ ì¤‘ì¼ ë•ŒëŠ” ì¦‰ì‹œ íˆ´íŒ í‘œì‹œë¥¼ ë§‰ìŒ
                     if (isTouching) return;

                     if (Game.selectedSkillIdx !== -1 && tid !== 0 && !Game.isProcessing) {
                         const pred = Game.predictDmg(u);
                         if (pred > 0) {
                            const bar = d.querySelector('.status-bar');
                            if (bar) {
                                const preview = document.createElement('div');
                                preview.className = 'hp-preview';
                                const currentHpPct = (u.hp / u.maxHp) * 100;
                                const dmgPct = Math.min(currentHpPct, (pred / u.maxHp) * 100);
                                preview.style.left = Math.max(0, currentHpPct - dmgPct) + '%';
                                preview.style.width = dmgPct + '%';
                                bar.appendChild(preview);
                            }
                        }
                     }
                     UI.showTooltip(u, d);
                };

                d.onmouseleave = () => { 
                    UI.hideTooltip(); 
                    const p = d.querySelector('.hp-preview'); 
                    if(p) p.remove(); 
                    if(longPressTimer) clearTimeout(longPressTimer); 
                };

                // ìƒíƒœì´ìƒ íƒœê·¸ ìƒì„±
                let tags = u.status.map(s => {
                    let c = 'tag';
                    const map = {'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn','BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown','BLIND':'blind','IMMUNITY':'immunity','HEAL_DOWN':'healdown','LIGHT_MIGHT':'atkup','LIFESTEAL_BUFF':'lifesteal','ATK_BUFF_SMALL':'atkup_s','START_IMMUNITY':'start-immunity','ROOT_GUARD':'bind','MC_WAIT':'mc-wait','MC_READY':'mc-ready','EARTH_RECOIL':'atkdown'};
                    if (s.type.includes('PROVOKED')) c += ' taunt';
                    else if (s.type.startsWith('KARMA_VICTIM')) c += ' karma';
                    else if (map[s.type]) c += ` ${map[s.type]}`;

                // [ìˆ˜ì •] ì¹˜ìœ  ê°ì†Œ ìˆ˜ì¹˜ë³„ í´ë˜ìŠ¤ ë° í…ìŠ¤íŠ¸ ì ìš©
                if (s.type === 'HEAL_DOWN') {
                    if (s.val <= 20) c += ' heal-20';       // ë…ê°€ìŠ¤(ë³´ë¼)
                    else if (s.val <= 50) c += ' heal-50';  // ëª¨ë˜ì§€ì˜¥(ì£¼í™©)
                    else c += ' heal-critical';             // ì¤‘ì²©ë¨(ë¹¨ê°•)
                }

                let txt = s.type;
                const tMap = {'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ','TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…','IMMUNITY':'ë©´ì—­','HEAL_DOWN':`ğŸ’”-${s.val}%`,'LIGHT_MIGHT':'ê³µê²©â†‘','LIFESTEAL_BUFF':'ğŸ©¸í¡í˜ˆ','ATK_BUFF_SMALL':'ğŸ”¥ê³µê²©â†‘','START_IMMUNITY':'ğŸ›¡ï¸ì„ ê³µë°©ì–´','ROOT_GUARD':'ğŸªµìˆ˜í˜¸','MC_WAIT':'ğŸŒ€ì„¸ë‡Œì¤‘','MC_READY':'ğŸ§ ì¡°ì¢…','EARTH_RECOIL':'ğŸ’”ë°˜ë™'};

                if (s.type.includes('PROVOKED')) txt = 'ë„ë°œ';
                else if (s.type.startsWith('KARMA_VICTIM')) txt = 'ğŸ‘ï¸ì—…ë³´';
                else if (tMap[s.type]) txt = tMap[s.type];

                    if (s.turn < 90) txt += ` <b style="font-family:sans-serif; margin-left:1px;">${s.turn}</b>`;
                    return `<span class="${c}">${txt}</span>`;
                }).join('');

                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60;">ğŸ”—Link</span>`;

                const key = u.getKey();
                const imgUrl = IMAGE_DB[key] || IMAGE_DB['Default'];
                
                const hpPct = (u.hp / u.maxHp) * 100;
                let hpColor = '#66bb6a';
                if (hpPct <= 25) hpColor = '#ef5350';
                else if (hpPct <= 50) hpColor = '#ffb74d';

                let displayName = u.name.split(' ')[0];
                if (u.isSuper) {
                    const emo = EMOTION_DB[u.getKey()];
                    if (emo) displayName = `[${emo.t}] ${displayName}`;
                }

                // [Patch v19.08] ì „íˆ¬ ì•„ì´ì½˜ ê°œì„ : ì˜¤ë²„ë ˆì´(ìš°ì¸¡í•˜ë‹¨) + ë…¸ë§(ë¹›/ì–´ë‘ ) ì»¤ìŠ¤í…€
                let iconsHtml = '';
                let baseI = ATTR[u.base] ? ATTR[u.base].i : (SKILL_DB[key] ? SKILL_DB[key].icon : '?');
                let extraI = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : null;

                // [Patch v19.10] Normal ëŒ€ì†Œë¬¸ì ì˜¤ë¥˜ ìˆ˜ì • (Crash Fix)
                if (key === 'Normal') {
                    baseI = ATTR['Light'].i;
                    extraI = ATTR['Dark'].i;
                }

                if (extraI) {
                    iconsHtml = `
                        <div style="position:relative; display:inline-block;">
                            <div class="tiny-icon">${baseI}</div>
                            <div class="tiny-icon" style="position:absolute; bottom:-5px; right:-5px; width:16px; height:16px; font-size:10px; z-index:5; border:1px solid #fff; background:rgba(255,255,255,0.9); border-radius:50%; display:flex; justify-content:center; align-items:center; box-shadow:0 1px 2px rgba(0,0,0,0.3);">${extraI}</div>
                        </div>`;
                } else {
                    iconsHtml = `<div class="tiny-icon">${baseI}</div>`;
                }

                // [ì‹ ê·œ] ìƒì„± í‘œì‹œê¸° ë¡œì§
                // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì)ì´ ëˆ„êµ¬ì¸ì§€ í™•ì¸
                const tVal = this.queue[this.curr];
                const activeUnit = (tVal !== undefined) ? (tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)]) : null;
                
                let matchupBadge = '';
                // [Fix] ì˜¨ë¼ì¸ ëª¨ë“œ ëŒ€ì‘: team ë¹„êµ ëŒ€ì‹  ë°°ì—´ í¬í•¨ ì—¬ë¶€ë¡œ í™•ì¸
                const isMyTurn = activeUnit && this.pTeam.includes(activeUnit);
                const isEnemyUnit = this.eTeam.includes(u);
                
                // ì¡°ê±´: í˜„ì¬ ë‚´ í„´ì´ê³ , ê·¸ë¦¬ëŠ” ëŒ€ìƒì´ ì ì¼ ë•Œ
                if (isMyTurn && isEnemyUnit && !u.isDead) {
                    const sim = this.calc(activeUnit, u);
                    if (sim.v > 1.0) { // ìœ ë¦¬í•¨ (1.2ë°° ì´ìƒ)
                        // [ì¬ìˆ˜ì •] ìš°ì¸¡ì€ ë²ˆê°œìŠ¤íƒ(âš¡)ê³¼ ê²¹ì¹  ìœ„í—˜ì´ ìˆì–´, ì¢Œì¸¡ ì†ì„± ì•„ì´ì½˜ ì•„ë˜(top:34px)ë¡œ ì´ë™
                        matchupBadge = `<div class="matchup-badge" style="position:absolute; top:34px; left:4px; background:#00e676; color:#004d40; font-size:10px; padding:2px 6px; border-radius:10px; font-weight:900; z-index:20; box-shadow:0 2px 4px rgba(0,0,0,0.3); border:2px solid #fff; animation: jelly-bounce 1s infinite;">âš¡ì•½ì </div>`;
                    } else if (sim.v < 1.0) { // ë¶ˆë¦¬í•¨ (0.8ë°° ì´í•˜)
                        // [ì¬ìˆ˜ì •] ìš°ì¸¡ì€ ë²ˆê°œìŠ¤íƒ(âš¡)ê³¼ ê²¹ì¹  ìœ„í—˜ì´ ìˆì–´, ì¢Œì¸¡ ì†ì„± ì•„ì´ì½˜ ì•„ë˜(top:34px)ë¡œ ì´ë™
                        matchupBadge = `<div class="matchup-badge" style="position:absolute; top:34px; left:4px; background:#ff5252; color:#fff; font-size:10px; padding:2px 6px; border-radius:10px; font-weight:900; z-index:20; box-shadow:0 2px 4px rgba(0,0,0,0.3); border:2px solid #fff;">ğŸ›¡ï¸ì €í•­</div>`;
                    }
                }

                // [ì²´ë ¥ë°” UI ë³€ê²½ í•µì‹¬ ë¶€ë¶„] + ìƒì„± ë±ƒì§€(${matchupBadge}) ì¶”ê°€ë¨
                // [Phase 1] ì§€ë©´ ì´í™íŠ¸ ë ˆì´ì–´ ì¶”ê°€
                const innerHTML = `
                    <div class="unit-img-bg" style="background-image: url('${imgUrl}');">
                        <div style="position:absolute; inset:0; background:${'transparent'};"></div>
                    </div>
                    ${matchupBadge} 
                    <div class="card-badge">${iconsHtml}</div>
                    <div class="card-atk">âš”ï¸ ${u.getAtk()}</div>
                ${u.elecStacks > 0 ? `<div class="elec-badge" style="top:30px;">âš¡${u.elecStacks}</div>` : ''}
                ${u.treeStack > 0 ? `<div class="tree-badge" style="top:30px;">ğŸŒ³${u.treeStack}</div>` : ''}
                ${u.s2Count > 0 ? `<div class="fire-badge" style="top:30px;">ğŸ”¥${u.s2Count}</div>` : ''}
                <div class="tag-container">${tags}</div>
                    <div class="unit-info-overlay">
                        <div class="card-name" style="${u.isSuper ? 'color:#ffd700;' : ''}">${displayName}</div>
                        <div class="status-bar">
                            <div class="hp-fill" style="width:${hpPct}%; background:${hpColor};"></div>
                            <div class="shield-fill" style="width:${Math.min(100, (u.shield/u.maxHp)*100)}%"></div>
                        </div>
                        <div style="font-size:11px; font-weight:bold; text-align:right; color:#fff; text-shadow:1px 1px 1px rgba(0,0,0,0.8); margin-top:2px; letter-spacing:0.5px;">
                            ${u.hp} / ${u.maxHp} ${u.shield > 0 ? `<span style="color:#e1bee7;">(+${u.shield})</span>` : ''}
                        </div>
                    </div>
                    <div class="ground-effect-layer"></div>
                `;

                // [Patch v19.10] DOM Patching: HTML ì „ì²´ êµì²´ ëŒ€ì‹  ë³€ê²½ëœ ê°’ë§Œ ì—…ë°ì´íŠ¸ (ì• ë‹ˆë©”ì´ì…˜ ë³´ì¡´)
                // 1. ì¹´ë“œê°€ ì²˜ìŒ ìƒì„±ë˜ì—ˆê±°ë‚˜ êµ¬ì¡°ê°€ ì™„ì „íˆ ë°”ë€ ê²½ìš°ì—ë§Œ innerHTML êµì²´
                if (!d.querySelector('.hp-fill') || d.dataset.key !== key) {
                    d.innerHTML = innerHTML;
                    d.dataset.key = key; 
                } else {
                    // 2. ê·¸ ì™¸ì—ëŠ” ìŠ¤íƒ€ì¼ê³¼ í…ìŠ¤íŠ¸ë§Œ ë¶€ë“œëŸ½ê²Œ ê°±ì‹  (Virtual DOM í‰ë‚´)
                    
                    // (1) ì²´ë ¥ë°” & ì‰´ë“œë°” (CSS transition ì‘ë™ ë³´ì¥)
                    const hpBar = d.querySelector('.hp-fill');
                    const shieldBar = d.querySelector('.shield-fill');
                    
                    if (hpBar) {
                        hpBar.style.width = `${hpPct}%`;
                        hpBar.style.background = hpColor;
                    }
                    if (shieldBar) {
                        shieldBar.style.width = `${Math.min(100, (u.shield/u.maxHp)*100)}%`;
                    }

                    // (2) í…ìŠ¤íŠ¸ ì •ë³´ (HP ìˆ˜ì¹˜ ë“±)
                    const infoOverlay = d.querySelector('.unit-info-overlay');
                    if (infoOverlay) {
                        // ì˜¤ë²„ë ˆì´ ë‚´ë¶€ HTML ìƒì„±
                        const newText = `
                        <div class="card-name" style="${u.isSuper ? 'color:#ffd700;' : ''}">${displayName}</div>
                        <div class="status-bar">
                            <div class="hp-fill" style="width:${hpPct}%; background:${hpColor};"></div>
                            <div class="shield-fill" style="width:${Math.min(100, (u.shield/u.maxHp)*100)}%"></div>
                        </div>
                        <div style="font-size:11px; font-weight:bold; text-align:right; color:#fff; text-shadow:1px 1px 1px rgba(0,0,0,0.8); margin-top:2px; letter-spacing:0.5px;">
                            ${u.hp} / ${u.maxHp} ${u.shield > 0 ? `<span style="color:#e1bee7;">(+${u.shield})</span>` : ''}
                        </div>`;
                        
                        // í…ìŠ¤íŠ¸ê°€ ë‹¤ë¥¼ ë•Œë§Œ ê°±ì‹ 
                        if (infoOverlay.innerHTML !== newText) infoOverlay.innerHTML = newText;
                    }
                    
                    // (3) ìƒíƒœì´ìƒ íƒœê·¸ ì—…ë°ì´íŠ¸
                    const tagCont = d.querySelector('.tag-container');
                    if (tagCont && tagCont.innerHTML !== tags) tagCont.innerHTML = tags;
                    
                    // (4) íŠ¹ìˆ˜ ë±ƒì§€ (ì „ê¸° ë“±) ì—…ë°ì´íŠ¸
                    const existingElec = d.querySelector('.elec-badge');
                    if (u.elecStacks > 0) {
                        if (!existingElec) d.insertAdjacentHTML('beforeend', `<div class="elec-badge" style="top:30px;">âš¡${u.elecStacks}</div>`);
                        else existingElec.innerText = `âš¡${u.elecStacks}`;
                    } else if (existingElec) {
                        existingElec.remove();
                    }
                    
                    // (5) ê³µê²©ë ¥ ì—…ë°ì´íŠ¸ (Fire-Light í­ì£¼ ë“± ì˜êµ¬ ìŠ¤íƒ¯ ë³€ê²½ ë°˜ì˜)
                    const atkDisplay = d.querySelector('.card-atk');
                    const currentAtk = u.getAtk();
                    if (atkDisplay && atkDisplay.innerText !== `âš”ï¸ ${currentAtk}`) {
                        atkDisplay.innerText = `âš”ï¸ ${currentAtk}`;
                    }
                    
                    // (6) Fire ìŠ¤íƒ ë±ƒì§€ ì—…ë°ì´íŠ¸
                    const existingFire = d.querySelector('.fire-badge');
                    if (u.s2Count > 0) {
                        if (!existingFire) d.insertAdjacentHTML('beforeend', `<div class="fire-badge" style="top:30px;">ğŸ”¥${u.s2Count}</div>`);
                        else existingFire.innerText = `ğŸ”¥${u.s2Count}`;
                    } else if (existingFire) {
                        existingFire.remove();
                    }
                    
                    // (7) Tree ìŠ¤íƒ ë±ƒì§€ ì—…ë°ì´íŠ¸
                    const existingTree = d.querySelector('.tree-badge');
                    if (u.treeStack > 0) {
                        if (!existingTree) d.insertAdjacentHTML('beforeend', `<div class="tree-badge" style="top:30px;">ğŸŒ³${u.treeStack}</div>`);
                        else existingTree.innerText = `ğŸŒ³${u.treeStack}`;
                    } else if (existingTree) {
                        existingTree.remove();
                    }
                    
                    // (8) ìƒì„± í‘œì‹œê¸° ì—…ë°ì´íŠ¸ [ì‹ ê·œ ì¶”ê°€]
                    const existingMatchup = d.querySelector('.matchup-badge');
                    if (matchupBadge) {
                        if (!existingMatchup) {
                            // ìƒì„± í‘œì‹œê¸°ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ì¶”ê°€
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = matchupBadge;
                            tempDiv.firstChild.classList.add('matchup-badge');
                            d.insertAdjacentElement('afterbegin', tempDiv.firstChild);
                        } else {
                            // ì´ë¯¸ ìˆìœ¼ë©´ ë‚´ìš© ì—…ë°ì´íŠ¸ (ì•½ì â†”ì €í•­ ë³€ê²½ ê°€ëŠ¥)
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = matchupBadge;
                            tempDiv.firstChild.classList.add('matchup-badge');
                            existingMatchup.replaceWith(tempDiv.firstChild);
                        }
                    } else if (existingMatchup) {
                        // ìƒì„± í‘œì‹œê°€ í•„ìš” ì—†ìœ¼ë©´ ì œê±°
                        existingMatchup.remove();
                    }
                }
            });
        };

        draw('player-row', this.pTeam, 0);
        draw('enemy-row', this.eTeam, 1);
    },

endTurn: function(isFast = false) {
        if (this.isOver) return;
        
        // [Fix] íƒ€ì´ë¨¸ ëˆ„ì  ë°©ì§€ - ëª¨ë“  íƒ€ì´ë¨¸ ëª…ì‹œì ìœ¼ë¡œ ì •ë¦¬
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.watchdog) {
            clearTimeout(this.watchdog);
            this.watchdog = null;
        }
        
        // í˜„ì¬ í„´ ì£¼ì¸ ìœ ë‹› ì°¾ê¸°
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // [ë°¸ëŸ°ìŠ¤ ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§
        // "í˜„ì¬ í„´ì„ ë§ˆì¹œ ìœ ë‹›(u)"ì´ "ì¡°ì¢… ì¤‘ì¸ ìœ ë‹›(isMindControlling)"ì¼ ë•Œë§Œ í•´ì œ
        if (this.isMindControlling && u && u.id === this.isMindControlling.id) {
             const puppet = this.isMindControlling;
             
             this.log(`<span class='log-sys'>ğŸ•Šï¸ [${puppet.name}] ì¡°ì¢… ì™„ë£Œ. ì •ì‹  ì§€ë°°ê°€ í•´ì œë©ë‹ˆë‹¤.</span>`); // ë©”ì‹œì§€ ë³€ê²½
             UI.floatText(puppet, "ì§€ë°° ì¢…ë£Œ", "ft-miss"); // í…ìŠ¤íŠ¸ ë³€ê²½
             
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             this.isMindControlling = null;
             
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab";
        }

        if (u && !u.isDead) u.decayStatus();
        
        [...this.pTeam, ...this.eTeam].forEach(u => {
            if (u.hp <= 0) this.die(u)
        });
        
        this.curr = (this.curr + 1) % 6;
        
        // [ìˆ˜ì •] íê°€ í•œ ë°”í€´ ëŒì•„ 0ë²ˆ(ì²« ìˆœì„œ)ì´ ë˜ë©´ ë¼ìš´ë“œ ì¦ê°€
        if (this.curr === 0) {
            this.globalRound++;

            // [ìˆ˜ì •] ë°ìŠ¤ë§¤ì¹˜ ë¡œì§ (globalRound ê¸°ì¤€)
            if (this.globalRound > 15) {
                [...this.pTeam, ...this.eTeam].forEach(u => {
                    if (!u.isDead) u.atk += 10;
                });
                this.log(`<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! (Round ${this.globalRound}) ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>`);
            }
        }
        
        this.render();
        
        // [Patch v19.14] í„´ ì¢…ë£Œ ëŒ€ê¸° ì‹œê°„ ë°°ì† ì ìš©
        let delay = isFast ? 100 : 1500;
        if (!isFast) delay *= this.speedMultiplier;

        if (this.isOver) return;

        this.timer = setTimeout(() => {
            if (this.isOver) return;
            this.turn();
        }, delay);
    }, 

    // [ìˆ˜ì •] async í‚¤ì›Œë“œ ì¶”ê°€ (íˆ¬ì‚¬ì²´ ëŒ€ê¸°ìš©)
    execute: async function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el => el.onclick = null);
        AudioSys.speak(atk);

        if (isOnlineMode && !isRemote) {
            const isMindControlAction = this.isMindControlling && atk.id === this.isMindControlling.id;
            if (atk.team !== 0 && !isMindControlAction) {
                alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!");
                return;
            }
            netRndBuffer = [];
        }

        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];
        if (!logic) {
            this.endTurn(); 
            return;
        }

        if (sIdx > 0 && !def) {
             const needsTarget = !['SELF', 'SELF_BUFF', 'ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(SKILL_DB[key].type);
             if (needsTarget) {
                 this.log(`<span class='log-sys'>âš ï¸ [${atk.name}] ëŒ€ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
                 this.endTurn();
                 return;
             }
        }

        // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ (íƒ€ê²Ÿì´ ìˆê³ , ìì‹ ì´ ì•„ë‹ ë•Œ)
        if (def && atk.id !== def.id) {
            const skillType = (sIdx === 0) ? 'ATTACK' : SKILL_DB[key].type;
            // ìŠ¤í‚¬ íƒ€ì…ì´ ë²„í”„/íì´ ì•„ë‹ˆê±°ë‚˜, íì´ë¼ë„ ì ì—ê²Œ ì“¸ ë•Œ(ì„¸ë‡Œ)ëŠ” ê³µê²© ì´í™íŠ¸
            // ê°„ë‹¨í•˜ê²Œ ì•„ì´ì½˜ ë§¤í•‘
            let pIcon = 'âœ¨';
            // [Fix] ê¸°ë³¸ ì†ì„± íˆ¬ì‚¬ì²´ ì•„ì´ì½˜ ì •ë¦¬
            if (atk.base === 'Fire') pIcon = 'ğŸ”¥';
            else if (atk.base === 'Water') pIcon = 'ğŸ’§';
            else if (atk.base === 'Tree') pIcon = 'ğŸƒ';
            else if (atk.base === 'Metal') pIcon = 'âš”ï¸';
            else if (atk.base === 'Earth') pIcon = 'ğŸŒ‘'; // PC í˜¸í™˜ìš© ê²€ì€ ë°”ìœ„
            else if (atk.base === 'Dark') pIcon = 'ğŸ’€';
            else if (atk.base === 'Normal') pIcon = 'ğŸ‘Š';
    
            // [Fix] íŠ¹ìˆ˜ ìŠ¤í‚¬ íˆ¬ì‚¬ì²´ ì˜¤ë²„ë¼ì´ë“œ (ì „ê¸°, ë§¹ë…, ì–¼ìŒ)
            if (atk.base === 'Metal' && atk.extra === 'Dark') pIcon = 'âš¡'; // ì „ê¸°
            if (atk.base === 'Metal' && atk.extra === 'Light' && sIdx >= 1) pIcon = 'â˜£ï¸'; // ë…ê°€ìŠ¤/ë§¹ë…
            if (atk.base === 'Tree' && atk.extra === 'Dark' && sIdx === 1) pIcon = 'â˜£ï¸'; // ë¶€ì‹ì„± ê°€ì‹œ
    
            if (atk.base === 'Water' && atk.extra === 'Dark') {
                if (sIdx === 1) pIcon = 'â„ï¸'; // ì–¼ìŒ
                if (sIdx === 2) pIcon = 'ğŸ’§'; // ë¬¼
            }

            // [ê°œì„ ] ìŠ¤í‚¬ ì¸ë±ìŠ¤ ì „ë‹¬
            await UI.fireProjectile(atk, def, pIcon, sIdx);
        }
		// íˆ¬ì‚¬ì²´ ë¹„í–‰ ì¤‘ ê²Œì„ì´ ë¦¬ì…‹ë˜ì—ˆê±°ë‚˜ ì¢…ë£Œë˜ì—ˆë‹¤ë©´ ì¦‰ì‹œ ì¤‘ë‹¨
        if (this.isOver || !this.pTeam.length) return;
        
        // âœ… try-catchë¡œ ìŠ¤í‚¬ ì‹¤í–‰ ë³´í˜¸
        try {
            const playedSound = logic.useSkill(atk, def, sIdx, this);
            if (!playedSound) AudioSys.play('SKILL');

            // [ê°ì„± ì²´í¬] ìŠ¤í‚¬ ì‚¬ìš© í›„ í†µê³„ ê°±ì‹  ì‹œ ê°ì„± í™•ì¸
            atk.checkAwakening();

            // âœ… ì„±ê³µ ì‹œì—ë§Œ ë„¤íŠ¸ì›Œí¬ ì „ì†¡
            if (isOnlineMode && !isRemote) {
                socket.emit('action', {
                    room: myRoom,
                    attackerId: atk.id,
                    attackerTeam: atk.team,
                    targetId: def ? def.id : null,
                    targetTeam: def ? def.team : null,
                    skillIdx: sIdx,
                    mcState: { // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
                        isMindControlling: !!this.isMindControlling,
                        mcTargetId: this.isMindControlling ? this.isMindControlling.id : null,
                        mcCasterId: this.currentMCCasterId
                    }
                });
            }
        } catch(e) {
            console.error('âŒ Skill execution failed:', e);
            this.log(`<span class='log-sys' style='color:red;'>âš ï¸ [${atk.name}] ìŠ¤í‚¬ ì‹¤í–‰ ì˜¤ë¥˜ ë°œìƒ</span>`);
            netRndBuffer = []; // ì‹¤íŒ¨ ì‹œ ë²„í¼ ì´ˆê¸°í™”
        }
        
        // [ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ì€ endTurn()ìœ¼ë¡œ ì´ë™ë¨
        this.endTurn();
    },

    reset: function() {
        // [Fix] ê°•ì œ ì¢…ë£Œ í‚¬ ìŠ¤ìœ„ì¹˜ ê°€ë™
        this.isOver = true; // ì§„í–‰ ì¤‘ì¸ ë¡œì§ì´ ì¦‰ì‹œ ë©ˆì¶”ë„ë¡ í”Œë˜ê·¸ ì„¤ì •
        this.isProcessing = false;

        // [Fix] íƒ€ì´ë¨¸ ì™„ì „ ì •ë¦¬ - ëª¨ë“  íƒ€ì´ë¨¸ ëª…ì‹œì ìœ¼ë¡œ ì •ë¦¬
        if (this.timer) { 
            clearTimeout(this.timer); 
            this.timer = null; 
        }
        if (this.watchdog) { 
            clearTimeout(this.watchdog); 
            this.watchdog = null; 
        }

        // ì˜¤ë””ì˜¤ ì •ë¦¬
        MusicEngine.stop();

        // UI ì •ë¦¬
        UI.closeModal();
        
        // [Fix] ë‚ ì•„ê°€ëŠ” íˆ¬ì‚¬ì²´ ë° ì´í™íŠ¸ ì¦‰ì‹œ ì œê±°
        document.querySelectorAll('.projectile, .impact-effect, .vfx-layer, .float-text').forEach(el => el.remove());

        document.getElementById('battle-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));

        // [Fix] ë°ì´í„° ì´ˆê¸°í™” - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
        this.selected = [];
        this.pTeam = []; // íŒ€ ì •ë³´ë„ ë‚ ë ¤ì„œ ìœ ë ¹ ì°¸ì¡° ë°©ì§€
        this.eTeam = [];
        this.isMindControlling = null;
        this.currentMCCasterId = null;

        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        this.pool = []; 

        // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬ ì¶”ê°€
        if (isOnlineMode) {
            isOnlineMode = false;
            globalRNG = null;
            gameSeed = null;
        }
        
        // [Fix] ì™„ì „í•œ ì¬ì´ˆê¸°í™”ë¥¼ ìœ„í•´ window.onload ëŒ€ì‹  init ì§ì ‘ í˜¸ì¶œ
        this.init();
    },
    // [ê°ì„± ì²´í¬] ìŠ¤íƒ¯ ê¸°ë¡ ì‹œ ê°ì„± í™•ì¸
    recordStat: function(unit, type, amount) {
        if (!unit || amount <= 0) return;
        if (type === 'dmg') unit.stats.dmg += amount;
        if (type === 'shield') unit.stats.shieldGiven += amount;
        if (type === 'heal') unit.stats.heal += amount;
        unit.checkAwakening();
    },
    input: function(u) {
    // ì„¸ë‡Œ ìƒíƒœ UI í‘œì‹œ
    const cp = document.querySelector('.control-panel');
    if (cp) {
        cp.style.borderTop = this.isMindControlling ? "5px solid #d500f9" : "5px solid #ff80ab";
    }
    
    const k = u.getKey();
    const s = SKILL_DB[k];
    
    // ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ ë°©ì–´ ì½”ë“œ
    if (!s) {
        console.error("âŒ SKILL_DB missing for key:", k, "Unit:", u.name);
        document.getElementById('p-icon').innerText = 'â“';
        document.getElementById('p-desc').innerText = 'ERROR: ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ';
        document.getElementById('sk-0').innerHTML = '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br><span class="skill-desc">1.0ë°°</span>';
        document.getElementById('sk-1').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        document.getElementById('sk-2').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        [0, 1, 2].forEach(i => document.getElementById(`sk-${i}`).disabled = true);
        this.log(`<span class='log-sys'>âš ï¸ [${u.name}] ìŠ¤í‚¬ ì •ë³´ ì˜¤ë¥˜ ë°œìƒ</span>`);
        return;
    }
    
    const silenced = u.hasStatus('SILENCE');
    
    // íŒ¨ì‹œë¸Œ ì •ë³´
    document.getElementById('p-icon').innerText = s.icon || 'â“';
    document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
    
    // ìŠ¤í‚¬ ë²„íŠ¼ ì •ë³´
    document.getElementById('sk-0').innerHTML = 
        '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br>' +
        '<span class="skill-desc">1.0ë°° í”¼í•´</span>';
    
    document.getElementById('sk-1').innerHTML = 
        '<span class="skill-name">' + (s.s1 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s1d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    document.getElementById('sk-2').innerHTML = 
        '<span class="skill-name">' + (s.s2 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s2d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ
    document.getElementById('sk-0').disabled = false;
    document.getElementById('sk-1').disabled = silenced;
    
    // S2 ë¹„í™œì„±í™” ì¡°ê±´
    let sk2Disable = silenced;
    
    if (k === 'Fire-Light' && (u.s2Count || 0) >= 5) {
        sk2Disable = true;
    }
    
    if (k === 'Tree-Dark') {
        const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
        const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
        if (aliveAllies.length === 0 || u.linkedAllyId !== -1) {
            sk2Disable = true;
        }
    }
    
    document.getElementById('sk-2').disabled = sk2Disable;
    
    if (silenced) {
        this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
    }
    
    // ë„ë°œ í™•ì¸ (ì„¸ë‡Œ ìƒíƒœë¼ë©´ ë„ë°œ ë¬´ì‹œ)
    const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
    const isBrainwashed = this.isMindControlling && this.isMindControlling.id === u.id;

    if (provoked && !isBrainwashed) { // ğŸ§  ì„¸ë‡Œ ì•„ë‹ ë•Œë§Œ ë„ë°œ ì ìš©
        const targetId = parseInt(provoked.type.split('_')[2]);
        const enemies = u.team === 0 ? this.eTeam : this.pTeam;
        const allies = u.team === 0 ? this.pTeam : this.eTeam;
        const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
        
        if (!target || target.isDead) {
            u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
            this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
            UI.floatText(u, "ììœ !", "ft-heal");
            this.render();
        } else {
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput();
            setTimeout(() => this.execute(u, target, 0), 1000);
            return; // ê°•ì œ ê³µê²© ì‹œ í•¨ìˆ˜ ì¢…ë£Œ
        }
    } else if (provoked && isBrainwashed) {
        this.log(`<span class='log-sys'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°°ë¡œ ì¸í•´ ë„ë°œì„ ë¬´ì‹œí•©ë‹ˆë‹¤.</span>`);
    }
    
    this.selectedSkillIdx = -1;
},
    noInput: function() {
        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            b.disabled = true;
            b.classList.remove('selected');
        });
    },
    prepareSkill: function(idx) {
    this.debugLog('Skill Button Clicked', { skillIndex: idx });

    // âœ… ì´ì „ íƒ€ê²ŸíŒ… ì´ˆê¸°í™” (ì¤‘ë³µ ë°©ì§€)
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    [0, 1, 2].forEach(i => {
        const b = document.getElementById(`sk-${i}`);
        if (i === idx) b.classList.add('selected');
        else b.classList.remove('selected');
    });
    
    this.selectedSkillIdx = idx;
        
        // í˜„ì¬ í–‰ë™ ì£¼ì²´ ì°¾ê¸°
        let u;
        if (this.isMindControlling) {
            u = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }

        // [ë””ë²„ê·¸] í–‰ë™ ìœ ë‹› ì •ë³´ ì¶œë ¥
        if (u) this.debugLog('Acting Unit Identified', { name: u.name, id: u.id, isMindControlled: !!this.isMindControlling });

        const k = u.getKey();
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';

        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì¸ë±ìŠ¤ë³„ íƒ€ê²Ÿ íƒ€ì… ëª…í™•í™”
        if (idx === 0) {
            targetType = 'ENEMY'; // í‰íƒ€ëŠ” ë¬´ì¡°ê±´ ê³µê²©
        } else if (idx === 1) {
            // S1 ìŠ¤í‚¬ë“¤ì˜ íƒ€ê²Ÿ íƒ€ì… ì„¤ì •
            // [ìˆ˜ì •] Tree-Darkì˜ S1(ê°€ì‹œì°Œë¥´ê¸°)ì€ ê³µê²©ê¸°ì´ë¯€ë¡œ ENEMYì—¬ì•¼ í•¨
            if (['Tree'].includes(k)) targetType = 'SELF_BUFF';
            else if (['Fire-Light'].includes(k)) targetType = 'ALL_ALLY'; // í¡í˜ˆ ë¶€ì—¬ëŠ” ì „ì²´ ë²„í”„
            else if (['Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; // ë””ë²„í”„ ê³µê²©
            else targetType = 'ENEMY'; // ë‚˜ë¨¸ì§€ëŠ” ëŒ€ë¶€ë¶„ ê³µê²©
        } else if (idx === 2) {
            // [Fix] ë‚˜ë¬´(Tree) S2ëŠ” ì•„êµ° íšŒë³µ ìŠ¤í‚¬ì´ë¯€ë¡œ ê°•ì œ ë³€ê²½
            if (k === 'Tree') targetType = 'ALLY';
            else targetType = s.target || 'ENEMY';
        }

        // íƒ€ê²ŸíŒ… í•¨ìˆ˜ í˜¸ì¶œ
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
    // 1. í–‰ë™ ìœ ë‹› í™•ì •
    if (!actingUnit) {
        if (this.isMindControlling) {
            actingUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            actingUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }
    }

    // 2. ê¸°ì¡´ íƒ€ê²ŸíŒ… ì´ˆê¸°í™”
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    // 3. ìŠ¤í‚¬ íƒ€ì… ë¶„ë¥˜
    const SUPPORT_TYPES = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF', 'TARGET_BUFF', 'HEAL', 'BUFF'];
    const isSupportSkill = SUPPORT_TYPES.includes(targetType);
    const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
    const isSelfOnly = ['SELF', 'SELF_BUFF'].includes(targetType);

    // 4. íŒ€ ì •ì˜ (ì›ë˜ ì†Œì† ê¸°ì¤€)
    const originalAllies = actingUnit.team === 0 ? this.pTeam : this.eTeam;
    const originalEnemies = actingUnit.team === 0 ? this.eTeam : this.pTeam;

    let finalTargets = [];

    // 5. ì„¸ë‡Œ ì—¬ë¶€ì— ë”°ë¥¸ íƒ€ê²Ÿ ê²°ì •
    const isMindControlled = this.isMindControlling && actingUnit.id === this.isMindControlling.id;
    
    if (isSelfOnly) {
        // ìê°€ ë²„í”„ëŠ” ì–¸ì œë‚˜ ìì‹ ì—ê²Œë§Œ
        finalTargets = [actingUnit];
    } 
    else if (isMindControlled) {
        // [ì„¸ë‡Œ ìƒíƒœ] - í”¼ì•„ì‹ë³„ ì—­ì „
        if (isSupportSkill) {
            // í/ë²„í”„ -> ì êµ°(í˜„ì¬ ë‚˜ë¥¼ ì¡°ì¢…í•˜ëŠ” íŒ€)ì—ê²Œ ì‚¬ìš©
            finalTargets = originalEnemies.filter(u => !u.isDead);
        } else {
            // ê³µê²© -> ì•„êµ°(ë‚˜ì˜ ì›ë˜ ë™ë£Œ)ì„ ê³µê²©
            // [ê°œì„ ] ìí•´(Self Attack)ë„ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ì„ í¬í•¨
            finalTargets = originalAllies.filter(u => !u.isDead);
            // ìí•´ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ë„ í¬í•¨ (ì¤‘ë³µ ë°©ì§€ ì²´í¬)
            if (!finalTargets.some(t => t.id === actingUnit.id)) {
                finalTargets.push(actingUnit);
            }
        }
    } else {
        // [ì •ìƒ ìƒíƒœ]
        if (isSupportSkill) {
            finalTargets = originalAllies.filter(u => !u.isDead);
        } else {
            // ì êµ° + "ì„¸ë‡Œë‹¹í•´ì„œ ë°°ì‹ ìê°€ ëœ ì•„êµ°"ë„ ê³µê²© ê°€ëŠ¥í•´ì•¼ í•¨
            const realEnemies = originalEnemies.filter(u => !u.isDead);
            const traitors = originalAllies.filter(u => !u.isDead && (u.hasStatus('MC_WAIT') || u.hasStatus('MC_READY')));
            finalTargets = [...realEnemies, ...traitors];
        }
    }

    // 6. Tree-Dark ì˜ˆì™¸ ì²˜ë¦¬
    if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2) {
        // ì˜í˜¼ê²°ì†ì€ ìì‹  ì œì™¸ (ë‹¨, ì„¸ë‡Œ ìƒíƒœì—ì„œ í˜¼ì ë‚¨ì€ ê²½ìš°ëŠ” ìí•´ ê°€ëŠ¥)
        if (!isMindControlled || finalTargets.length > 1) {
            finalTargets = finalTargets.filter(t => t.id !== actingUnit.id);
        }
    }

    // 7. íƒ€ê²Ÿ ë Œë”ë§
    let targetClass = isSupportSkill ? 'target-ally' : 'target-enemy';
    if (isAOE && !isSupportSkill) targetClass = 'target-aoe';

    let targetCount = 0;

    finalTargets.forEach((t) => {
        const cardId = t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`;
        const el = document.getElementById(cardId);
        
        if (el) {
            el.classList.add(targetClass);
            el.onclick = () => {
                if (Game.isProcessing) return;
                Game.isProcessing = true;
                
                // ì…ë ¥ ì ê¸ˆ
                this.noInput();
                document.querySelectorAll('.unit').forEach(e => {
                    e.classList.remove('target-enemy', 'target-ally', 'target-aoe');
                });
                
                // ì‹¤í–‰
                this.execute(actingUnit, t, this.selectedSkillIdx);
            };
            targetCount++;
        }
    });

// 8. ë””ë²„ê¹… ë° ì˜ˆì™¸ ì²˜ë¦¬ (Option 2 ì ìš©)
    if (targetCount === 0) {
        console.warn('âš ï¸ No valid targets:', {
            skillIdx: this.selectedSkillIdx,
            targetType: targetType,
            actingUnit: actingUnit.name,
            isMindControlled: isMindControlled,
            finalTargets: finalTargets.map(t => t.name)
        });

        // íƒ€ê²Ÿì´ ì—†ëŠ” ê²½ìš° UI í”¼ë“œë°±
        if (isMindControlled && !isSupportSkill) {
            UI.floatText(actingUnit, "ëŒ€ìƒì—†ìŒ", "ft-miss");
            this.log(`<span class='log-sys'>âš ï¸ [${actingUnit.name}] ê³µê²©í•  ìˆ˜ ìˆëŠ” ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>`);
        } else if (!isMindControlled && finalTargets.length === 0) {
            console.error('ğŸš¨ Critical: No targets found in normal state!');
            UI.floatText(actingUnit, "íƒ€ê²Ÿì˜¤ë¥˜", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš¨ [${actingUnit.name}] íƒ€ê²ŸíŒ… ì˜¤ë¥˜ ë°œìƒ</span>`);
        }
        
        // âœ… ìŠ¤í‚¬ ì„ íƒ ì´ˆê¸°í™” ì¶”ê°€ (ë²„ê·¸ ìˆ˜ì •)
        this.selectedSkillIdx = -1;
        document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('selected'));
        return; // í•¨ìˆ˜ ì¢…ë£Œ
    }
}, // ì½¤ë§ˆ í•„ìˆ˜ (ë’¤ì— ai í•¨ìˆ˜ê°€ ìˆìŒ)


    // ========== 3997ë²ˆì§¸ ì¤„ë¶€í„° êµì²´ ==========
    
ai: function(u) {
        // [ê²€ì¦] ì˜¨ë¼ì¸, ë¡œì»¬ PVPë©´ AI ì‘ë™ ì¤‘ì§€
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;
        
        // 0. ê¸°ë³¸ ê²€ì¦
        if (!u || u.isDead) {
            this.endTurn(true);
            return;
        }

        try {
            this.log(`<span class='log-sys'>ğŸ¤– AI í–‰ë™ ì¤‘: ${u.name}</span>`);

            // 1. ì„¸ë‡Œ íŒì •
            const isBrainwashed = (this.isMindControlling && this.isMindControlling.id === u.id);
            if (isBrainwashed) {
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì„¸ë‡Œ ìƒíƒœë¡œ í–‰ë™!</span>`);
            }

            // 2. ì /ì•„êµ° ì‹ë³„
            let enemies, allies;
            if (isBrainwashed) {
                enemies = u.team === 0 ? this.pTeam : this.eTeam; // ì›ë˜ íŒ€ì´ ì 
                allies = u.team === 0 ? this.eTeam : this.pTeam;
            } else {
                enemies = u.team === 0 ? this.eTeam : this.pTeam; // ìƒëŒ€ íŒ€ì´ ì 
                allies = u.team === 0 ? this.pTeam : this.eTeam;
            }

            // 3. ìƒì¡´ì í•„í„°ë§
            let aliveEnemies = enemies.filter(e => !e.isDead && e.id !== u.id);
            const aliveAllies = allies.filter(a => !a.isDead);

            // [ì˜ˆì™¸] ì„¸ë‡Œ ìƒíƒœì¸ë° ê³µê²© ëŒ€ìƒ ì „ë©¸ ì‹œ ìí•´ í—ˆìš©
            if (aliveEnemies.length === 0 && isBrainwashed) {
                aliveEnemies = [u];
            }

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            // 4. ë„ë°œ(Taunt) ì²˜ë¦¬
            if (!isBrainwashed) {
                const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
                if (provoked) {
                    const targetId = parseInt(provoked.type.split('_')[2]);
                    const taunter = aliveEnemies.find(t => t.id === targetId);
                    if (taunter) {
                        this.execute(u, taunter, 0); // í‰íƒ€ ê°•ì œ
                        return;
                    }
                }
            }

            const silenced = u.hasStatus('SILENCE');
            const k = u.getKey();
            const sk = SKILL_DB[k];

            // ---------------------------------------------------------
            // ğŸ§  [NEW] ë‚œì´ë„ ì„¤ì •
            // ---------------------------------------------------------
            const difficultyMultiplier = {
                'easy': 0.7,
                'normal': 1.0,
                'hard': 1.3,
                'hell': 1.5
            }[this.difficulty] || 1.0;

            const randomnessFactor = {
                'easy': 30,      // ë†’ì€ ë¬´ì‘ìœ„ì„±
                'normal': 10,    // ì¤‘ê°„
                'hard': 5,       // ë‚®ì€ ë¬´ì‘ìœ„ì„±
                'hell': 2        // ê±°ì˜ ìµœì 
            }[this.difficulty] || 10;

            // ---------------------------------------------------------
            // ğŸ§  [NEW] ì¡°í•© ë¶„ì„ (ì–´ë ¤ì›€ ì´ìƒ)
            // ---------------------------------------------------------
            let enemyComposition = { healers: 0, tanks: 0, nukers: 0 };
            if (this.difficulty === 'hard' || this.difficulty === 'hell') {
                aliveEnemies.forEach(e => {
                    const eKey = e.getKey();
                    if (SKILL_DB[eKey]) {
                        const role = SKILL_DB[eKey].role;
                        if (role === 'supp') enemyComposition.healers++;
                        else if (role === 'tank') enemyComposition.tanks++;
                        else if (role === 'nuker') enemyComposition.nukers++;
                    }
                });
            }

            // ---------------------------------------------------------
            // ğŸ§  [AI Core] í—¬í¼ í•¨ìˆ˜ ì •ì˜
            // ---------------------------------------------------------

            const isAttackSkill = (desc, type) => {
                if (!desc) return false;
                
                const hasAttackKeyword = desc.includes('ë°°') || desc.includes('ë„ë°œ') || desc.includes('ì†ë°•');
                const hasHealKeyword = desc.includes('í') || desc.includes('íšŒë³µ') || desc.includes('HP+');
                
                if (hasHealKeyword) return false;
                if (desc.includes('ì‰´ë“œ') && hasAttackKeyword) return true;
                if (desc.includes('ì‰´ë“œ') && !hasAttackKeyword) return false;
                if (hasAttackKeyword) return true;
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER', 'ATK'].includes(type)) return true;
                
                return false;
            };

            const isSupportSkill = (desc, type) => {
                if (!desc) return false;
                if (desc.includes('ë°°') && !desc.includes('í') && !desc.includes('íšŒë³µ')) return false;
                if (desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return false;
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER'].includes(type)) return false;
                
                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼', 'ì„±ì¥', 'ê²°ì†', 'íšŒë³µ', 'HP+'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY', 'ALLY'];
                return supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type);
            };

            // âš”ï¸ [AI ì—…ë°ì´íŠ¸ V4] ê³µê²© ì ìˆ˜ ê³„ì‚° (ê°œì„ íŒ)
            const getAttackScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                
                // ğŸ›‘ ìì‚´ ë°©ì§€
                if (u.base === 'Normal' && skillIdx === 1 && u.hp <= 30) return -9999; 
                if (u.getKey() === 'Dark-Dark' && skillIdx === 2 && u.hp < u.maxHp * 0.15) return -5000;

                let score = 0;
                const skillDesc = skillIdx === 0 ? "ê¸°ë³¸ê³µê²©" : (skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || ""));
                
                let multiplier = 1.0;
                if (skillIdx > 0 && skillDesc) {
                    const match = skillDesc.match(/([\d.]+)ë°°/) || skillDesc.match(/([\d.]+)%/);
                    if (match) {
                        multiplier = parseFloat(match[1]);
                        if (skillDesc.includes('%')) multiplier /= 100;
                    }
                }

                const aff = Game.calc(u, target);
                const baseDmg = u.getAtk() * multiplier * aff.v;

                // A. í‚¬ ìºì¹˜ (Kill Catch) - ìµœìš°ì„ 
                if (baseDmg > 0 && target.hp <= baseDmg && !target.hasStatus('IMMORTAL')) {
                    score += 50000; 
                } else {
                    score += baseDmg;
                }
                
                // ğŸ§  [NEW] ê´‘ì—­ê¸° íš¨ìœ¨ ì¬ê³„ì‚° (ë‹¤ì¤‘ í‚¬ê° ê°€ì¤‘ì¹˜)
                if (['AOE', 'ALL_ENEMY', 'NUKE_PER'].includes(sk.type) && skillIdx > 0) {
                    let killCount = 0;
                    let aoeBonus = 0;
                    
                    aliveEnemies.forEach(en => {
                        if (en.id === target.id) return;
                        const subAff = Game.calc(u, en);
                        const subDmg = u.getAtk() * multiplier * subAff.v;
                        
                        if (subDmg >= en.hp && !en.hasStatus('IMMORTAL')) {
                            killCount++;
                            aoeBonus += 5000; // í‚¬ê°ì€ ê³ ì • ì ìˆ˜
                        } else {
                            aoeBonus += subDmg; // ì¼ë°˜ ë°ë¯¸ì§€
                        }
                    });
                    
                    // ë‹¤ì¤‘ í‚¬ ë³´ë„ˆìŠ¤
                    if (killCount >= 2) aoeBonus += 10000;
                    
                    // 1ëŒ€1 ê´‘ì—­ê¸° ë‚­ë¹„ ë°©ì§€ ê°•í™”
                    if (aliveEnemies.length === 1 && killCount === 0) {
                        aoeBonus -= 5000;
                    }
                    
                    score += aoeBonus;
                }

                // ğŸ§± ë²„í”„ íŒŒê´´ì (Earth)
                if (u.base === 'Earth' && skillIdx === 1) {
                    if (target.status.some(s => ['EVADE', 'shield', 'LIGHT_MIGHT', 'ATK_BUFF_SMALL'].includes(s.type) || target.shield > 0)) {
                        score += 2500; 
                    }
                }

                // B. ìƒì„± ìš°ìœ„
                if (aff.v > 1.0) score += 1500; // 300 -> 1500 ì¦ê°€

                // [ì‹¬í™”] íƒ€ê²ŸíŒ… ìš°ì„ ìˆœìœ„
                const hpPct = target.hp / target.maxHp;
                if (hpPct < 0.4) score += 1500;
                
                // ğŸ†• [NEW] íëŸ¬ ìš°ì„  íƒ€ê²ŸíŒ… ê°•í™”
                const tKey = target.getKey();
                if (SKILL_DB[tKey] && SKILL_DB[tKey].role === 'supp') {
                    score += 5000; // 1000 -> 5000 ëŒ€í­ ì¦ê°€
                }

                // ğŸ†• [NEW] ì¡°í•© ê¸°ë°˜ íƒ€ê²ŸíŒ… (ì–´ë ¤ì›€ ì´ìƒ)
                if (this.difficulty === 'hard' || this.difficulty === 'hell') {
                    // ì ì—ê²Œ íëŸ¬ê°€ ì—†ìœ¼ë©´ ì§€ì†ë”œ ìœ„ì£¼
                    if (enemyComposition.healers === 0) {
                        if (skillDesc.includes('í™”ìƒ') || skillDesc.includes('ë…')) {
                            score += 2000;
                        }
                    }
                    
                    // ì  íƒ±ì»¤ê°€ ë§ìœ¼ë©´ ë²„í”„ íŒŒê´´/ê´€í†µ ìš°ì„ 
                    if (enemyComposition.tanks >= 2) {
                        if (u.base === 'Earth' && skillIdx === 1) score += 3000; // ë²„í”„íŒŒê´´
                        if (u.getKey() === 'Earth-Light' && skillIdx === 1) score += 3000; // ê´€í†µ
                    }
                }

                // Metal ì‰´ë“œ ë‚­ë¹„ ë°©ì§€
                if (target.base === 'Metal' && !target.extra && target.shield > 0) {
                    const dmgCap = target.maxHp * 0.20;
                    if (baseDmg > dmgCap * 1.5) score -= 3000; 
                }

                // C. CC ì¤‘ë³µ ë°©ì§€
                const ccKeywords = ['ê¸°ì ˆ', 'ë¹™ê²°', 'ì¹¨ë¬µ', 'ì„¸ë‡Œ', 'ì†ë°•', 'ë„ë°œ', 'STUN', 'FREEZE', 'SILENCE'];
                if (ccKeywords.some(kw => skillDesc.includes(kw))) {
                    if (!target.hasStatus('IMMUNITY') && !target.isNormal) {
                        const hasHardCC = target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('MC_WAIT');
                        if (hasHardCC) score -= 3000;
                        else score += 500;
                    }
                }

                // ğŸ›¡ï¸ Metal(ì‡ ) ë„ë°œ ë¡œì§
                if (u.base === 'Metal' && !u.extra) {
                    const myProvokedTarget = aliveEnemies.find(e => e.status.some(s => s.type === `PROVOKED_BY_${u.id}`));
                    
                    if (myProvokedTarget) {
                        if (skillIdx === 2) {
                            score -= 5000; // ì¤‘ë³µ ë„ë°œ ê¸ˆì§€
                        } else if (skillIdx === 1 && target.id === myProvokedTarget.id) {
                            score += 3000; // ë„ë°œ ëŒ€ìƒ ê³µê²©
                        }
                    } else {
                        if (skillIdx === 2) {
                            score += 6000; // ë„ë°œ í•„ìš”
                            
                            // ğŸ†• [NEW] ì•„êµ° íëŸ¬ ë³´í˜¸ (ë„ë°œ ìš°ì„ ìˆœìœ„)
                            const allyHealer = aliveAllies.find(a => {
                                const aKey = a.getKey();
                                return SKILL_DB[aKey] && SKILL_DB[aKey].role === 'supp';
                            });
                            if (allyHealer && allyHealer.hp < allyHealer.maxHp * 0.4) {
                                score += 8000; // íëŸ¬ ìœ„í—˜ ì‹œ ë„ë°œ ìµœìš°ì„ 
                            }
                            
                            // ê³µê²©ë ¥ ë†’ì€ ì  ìš°ì„ 
                            if (target.atk) {
                                score += target.atk * 10; 
                            }
                        }
                    }
                }

                // Dark-Dark ì¹¨ë¬µ ì¤‘ë³µ ë°©ì§€
                if (u.getKey() === 'Dark-Dark' && skillIdx === 1) {
                    if (target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('SLEEP') || target.hasStatus('SILENCE')) {
                        score -= 3000;
                    }
                    else if (typeof target.isProvoked === 'function' && target.isProvoked()) {
                        score -= 3000;
                    }
                }
            
                // ğŸŸ¢ Dark-Dark(ì‹¬ì—°) ì„¸ë‡Œ ë¡œì§
                if (u.getKey() === 'Dark-Dark' && skillIdx === 2) {
                    // [Patch v19.06] ë™ì¡±ìƒì” ë°©ì§€: ì ì´ Dark-Darkë©´ ì„¸ë‡Œ ì‹œë„ ê¸ˆì§€ (ë©´ì—­/íš¨ìœ¨ ë¬¸ì œ)
                    if (target.getKey() === 'Dark-Dark') {
                        return -9999;
                    }

                    if (target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('SLEEP') || target.hasStatus('EARTH_RECOIL')) {
                        score -= 10000;
                    } 
                    else if (typeof target.isProvoked === 'function' && target.isProvoked()) {
                         score -= 5000;
                    }
                    else {
                        const mode = (typeof Game !== 'undefined' && Game.mode) ? Game.mode : 'normal';
                        const isChallengeBoss = (mode === 'challenge' && u.team === 1); 

                        if (isChallengeBoss) {
                            if (Math.random() < 0.7) {
                                score += 10000; 
                            }
                        } else {
                            const targetKey = target.getKey();
                            
                            if (typeof SKILL_DB !== 'undefined' && SKILL_DB[targetKey]) {
                                const role = SKILL_DB[targetKey].role;

                                if (role === 'nuker') {
                                    score += 300;
                                }
                                else if (role === 'supp') {
                                    score += 200;
                                }
                                else if (role === 'tank') {
                                    score += 50;
                                }
                            }

                            if (target.atk >= 80) score += 100;
                            if (u.hp < u.maxHp * 0.3) score -= 5000;
                        }
                    }
                }

                // Water-Dark ì¤‘ë³µ ë¹™ê²° ë°©ì§€
                if (u.getKey() === 'Water-Dark' && skillIdx === 2) {
                    if (target.hasStatus('FREEZE') || target.hasStatus('STUN') || target.hasStatus('SLEEP')) {
                        score -= 5000; 
                    }
                }
            
                // Earth-Dark S2 ê´€ë¦¬
                if (u.getKey() === 'Earth-Dark' && skillIdx === 2) {
                    // âœ… [FIX] 1ëŒ€1 ìƒí™©ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì¡°ê±´ ì œê±°
                    // ê¸°ì¡´: if (target.hp < u.getAtk()) { score -= 3000; }
                    // ë³€ê²½: í‰íƒ€ í‚¬ê°ì¼ ë•Œë§Œ ì–µì œ
                    if (target.hp < u.getAtk() && aliveEnemies.length > 1) {
                        score -= 3000; // ë‹¤ìˆ˜ì „ì—ì„œë§Œ í‰íƒ€ í‚¬ê° ì‹œ ì–µì œ
                    }
                    
                    if (u.hasStatus('IMMUNITY')) {
                        score += 2000;
                    }
                }

                // E. ê³ ë‚œì´ë„ í‰íƒ€ ì–µì œ
                if (this.difficulty !== 'easy' && skillIdx === 0) {
                     if (!u.hasStatus('SILENCE')) score -= 2000;
                }

                return score * difficultyMultiplier;
            };

            // ğŸ›¡ï¸ ì§€ì› ì ìˆ˜ ê³„ì‚°
            const getSupportScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;

                // âœ… [FIX] ë‚˜ë¬´(Tree) ìµœì í™”: í˜¼ì ë‚¨ì•˜ê±°ë‚˜ ì´ë¯¸ ì¼œì ¸ ìˆìœ¼ë©´ ì‚¬ìš© ê¸ˆì§€
                if (u.base === 'Tree' && !u.extra && skillIdx === 1) {
                    if (u.hasStatus('ROOT_GUARD')) return -9999; // ì´ë¯¸ ì¼œì ¸ ìˆìŒ
                    if (aliveAllies.length <= 1) return -9999; // í˜¼ì ë‚¨ìŒ
                }

                // âœ… [FIX] í‘¸ë¥¸ë¶ˆ(Fire-Light) S1 ìµœì í™”: í˜¼ì ë‚¨ì•˜ê±°ë‚˜ ì´ë¯¸ ì¼œì ¸ ìˆìœ¼ë©´ ì‚¬ìš© ê¸ˆì§€
                if (u.getKey() === 'Fire-Light' && skillIdx === 1) {
                    // ì´ë¯¸ í¡í˜ˆ ë²„í”„ê°€ ìˆëŠ”ì§€ ì²´í¬
                    if (aliveAllies.some(a => a.hasStatus('LIFESTEAL_BUFF'))) {
                        // íŒ€ì› ê°±ì‹ ì€ í—ˆìš© (ëŒ€ìƒì´ ë‚˜ ìì‹ ì´ ì•„ë‹ˆê³ , ë²„í”„ê°€ ì—†ëŠ” ì•„êµ°ì´ë©´ OK)
                        if (target.id === u.id || target.hasStatus('LIFESTEAL_BUFF')) {
                            return -9999; // ìì‹ ì—ê²Œ ì¤‘ë³µ or ì´ë¯¸ ë²„í”„ ìˆëŠ” ì•„êµ°
                        }
                    }
                    if (aliveAllies.length <= 1) return -9999; // í˜¼ì ë‚¨ìŒ
                }

                let score = 0;
                const skillDesc = skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || "");
                
                // A. í íš¨ìœ¨
                if (skillDesc.includes('í') || skillDesc.includes('HP') || sk.type === 'HEAL') {
                    const pct = target.hp / target.maxHp;
                    if (pct < 0.35) score += 5000; 
                    else if (pct > 0.9) score -= 2000; 
                    else score += (target.maxHp - target.hp) * 2.0;
                    
                    // ğŸ†• [NEW] íëŸ¬ ìì‹ ì´ ìœ„í—˜í•˜ë©´ ìê°€ í ìš°ì„ 
                    const isSelfHealer = SKILL_DB[k] && SKILL_DB[k].role === 'supp';
                    if (isSelfHealer && target.id === u.id && target.hp < target.maxHp * 0.4) {
                        score += 3000;
                    }
                }

                // B. ì •í™” ìš°ì„ ìˆœìœ„
                if (skillDesc.includes('ì •í™”')) {
                    if (target.status.length > 0) score += 500;
                    if (target.getKey() === 'Earth-Dark' && target.hasStatus('STUN')) score += 8000; 
                    if (target.hasStatus('STUN') || target.hasStatus('FREEZE')) score += 2000;
                    
                    // ğŸ†• [NEW] ì•„êµ° íëŸ¬ CC í•´ì œ ìš°ì„ 
                    const tKey = target.getKey();
                    if (SKILL_DB[tKey] && SKILL_DB[tKey].role === 'supp') {
                        if (target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('SILENCE')) {
                            score += 5000;
                        }
                    }
                }

                // C. ì‰´ë“œ ë‚­ë¹„ ë°©ì§€
                if (skillDesc.includes('ì‰´ë“œ')) {
                    if (target.shield >= 300) score -= 5000; 
                    else if (target.shield < 50) score += 500;
                    
                    // ğŸ†• [NEW] ì  ê´‘ì—­ë”œëŸ¬ ëŒ€ë¹„ ì„ ì œ ì‰´ë“œ
                    if (this.difficulty === 'hard' || this.difficulty === 'hell') {
                        const enemyHasAOE = aliveEnemies.some(e => {
                            const eKey = e.getKey();
                            return SKILL_DB[eKey] && ['AOE', 'ALL_ENEMY'].includes(SKILL_DB[eKey].type);
                        });
                        if (enemyHasAOE && target.shield < 100) {
                            score += 2000;
                        }
                    }
                }

                // D. ìê°€ ë²„í”„
                if (target.id === u.id && (skillDesc.includes('ì„±ì¥') || sk.type === 'SELF_BUFF')) score += 400;

                // E. í‘¸ë¥¸ë¶ˆ(Fire-Light) ìµœì í™”
                if (u.getKey() === 'Fire-Light') {
                    if (skillIdx === 1) { 
                        // ì¤‘ë³µ ì²´í¬ëŠ” ìœ„ì—ì„œ ì´ë¯¸ í–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ê°€ì¹˜ íŒë‹¨ë§Œ
                        const lowestHpAlly = aliveAllies.reduce((min, a) => Math.min(min, a.hp / a.maxHp), 1);
                        if (lowestHpAlly > 0.85) score -= 3000; 
                        else score += 3000; 
                    } else if (skillIdx === 2) { 
                        // 5ìŠ¤íƒ ë„ë‹¬ ì‹œ S2 ì°¨ë‹¨
                        if ((u.s2Count || 0) >= 5) return -9999;
                        score += 500; 
                    }
                }

                return score * difficultyMultiplier;
            };

            // ---------------------------------------------------------
            // ğŸš€ í–‰ë™ ëª©ë¡ ìƒì„± ë° ì„ íƒ
            // ---------------------------------------------------------
            let actions = [];

            // A. ê³µê²© í–‰ë™ ìˆ˜ì§‘
            aliveEnemies.forEach(e => {
                actions.push({ idx: 0, target: e, score: getAttackScore(e, 0), type: 'attack' });
                if (!silenced) {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isAttackSkill(desc, sk.type)) {
                            if (k === 'Tree-Dark' && i === 2) return; 
                            actions.push({ idx: i, target: e, score: getAttackScore(e, i), type: 'attack' });
                        }
                    });
                }
            });

            // B. ì§€ì› í–‰ë™ ìˆ˜ì§‘
            if (!silenced) {
                aliveAllies.forEach(a => {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isSupportSkill(desc, sk.type)) {
                            if ((sk.type === 'SELF_BUFF' || sk.type === 'SELF') && a.id !== u.id) return;
                            if (k === 'Tree-Dark' && i === 2 && a.id === u.id) return; 
                            actions.push({ idx: i, target: a, score: getSupportScore(a, i), type: 'support' });
                        }
                    });
                });
            }

            // ë””ë²„ê·¸ ë¡œê·¸
            if (typeof DEBUG !== 'undefined' && DEBUG.enabled) {
                console.groupCollapsed(`ğŸ¤– [${u.name}] í–‰ë™ ì„ íƒ (ë‚œì´ë„: ${this.difficulty})`);
                const debugActions = [...actions].sort((a, b) => b.score - a.score);
                debugActions.slice(0, 5).forEach(a => console.log(`${a.idx===0?'í‰íƒ€':(a.idx===1?'S1':'S2')} -> ${a.target.name} (${a.score.toFixed(0)})`));
                console.groupEnd();
            }

            // C. ìµœì  í–‰ë™ ì„ íƒ (ë‚œì´ë„ë³„ ë¬´ì‘ìœ„ì„± ì ìš©)
            actions.sort((a, b) => (b.score + Math.random()*randomnessFactor) - (a.score + Math.random()*randomnessFactor));
            let best = actions[0];

            if (!best || !best.target || best.score < -5000) {
                best = { 
                    idx: 0, 
                    target: aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)],
                    type: 'attack'
                };
            }

            if (!isBrainwashed && best.target && best.target.team === u.team) {
                const info = best.idx === 0 ? "í‰íƒ€" : (best.idx === 1 ? sk.s1d : sk.s2d);
                if (best.type === 'attack' || (info && info.includes('ë°°') && sk.type !== 'HEAL')) {
                    best.target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
                    best.idx = 0;
                }
            }

            this.execute(u, best.target, best.idx);

        } catch (e) {
            console.error("AI Logic Critical Error:", e);
            this.endTurn(); 
        }
    },

    die: function(u) {
        if (u.isDead) return;
        u.isDead = true;
        u.hp = 0;
        
        // [Fix] ì¦‰ê°ì ì¸ ì‹œê°ì  í”¼ë“œë°± (ì£½ì€ ëˆˆ)
        const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(cardId);
        if (el) el.classList.add('dead');

        // [Patch v19.06] ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™”: ì‹œì „ì ì‚¬ë§ ì‹œ ëª¨ë“  ì„¸ë‡Œ ê´€ë ¨ ìƒíƒœ ê°•ì œ ì •í™”
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        allUnits.forEach(target => {
            // 1. ëŒ€ê¸° ì¤‘ì¸ ì„¸ë‡Œ(MC_WAIT) í•´ì œ
            const wait = target.status.find(s => s.type === 'MC_WAIT');
            if (wait && wait.sourceId === u.id) {
                target.status = target.status.filter(s => s.type !== 'MC_WAIT');
                Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì([${u.name}]) ì‚¬ë§ìœ¼ë¡œ [${target.name}]ì˜ ì„¸ë‡Œ ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
                UI.floatText(target, "ì˜ˆì•½ ì·¨ì†Œ", "ft-miss");
            }
            
            // 2. ì¡°ì¢… ì¤€ë¹„ ì™„ë£Œ(MC_READY) í•´ì œ (í˜¹ì‹œ ë‚¨ì•„ìˆì„ ê²½ìš°)
            const ready = target.status.find(s => s.type === 'MC_READY');
            if (ready && ready.sourceId === u.id) {
                target.status = target.status.filter(s => s.type !== 'MC_READY');
            }
        });

        // 3. í˜„ì¬ ì‹¤ì‹œê°„ ì¡°ì¢… ì¤‘ì¸ ê²½ìš° ì œì–´ê¶Œ ë°˜í™˜
        if (this.isMindControlling && this.currentMCCasterId === u.id) {
             const puppet = this.isMindControlling;
             
             // ì„¸ë‡Œ ìƒíƒœ íƒœê·¸ ì •ë¦¬
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY' && s.type !== 'MC_WAIT');
             
             this.isMindControlling = null;
             this.currentMCCasterId = null;
             
             Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì ì‚¬ë§! [${puppet.name}]ì˜ ì •ì‹  ì§€ë°°ê°€ ì¦‰ì‹œ í’€ë¦½ë‹ˆë‹¤.</span>`);
             UI.floatText(puppet, "ì§€ë°° í•´ì œ", "ft-heal");
             
             // UI í…Œë‘ë¦¬ ìƒ‰ìƒ ë³µêµ¬
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab"; // ê¸°ë³¸ í•‘í¬ìƒ‰ ë³µêµ¬
        }
		
        u.status = [];
        Game.log(`${u.name} íƒˆë½`);
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => {
                if (!e.isDead) e.addStatus('POISON', 1, 0, u);
            });
        }
        const allies = u.team === 0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base === 'Tree' && a.extra === 'Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.revengeAtk += 20;
            thorn.thornStack += 0.3;
            thorn.linkedAllyId = -1;
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`);
            UI.floatText(thorn, "RAGE!", "ft-crit");
        });
    },
    endCheck: function() {
        const pd = this.pTeam.every(u => u.isDead);
        const ed = this.eTeam.every(u => u.isDead);

        if (pd || ed) {
            this.isOver = true;
            if (this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN');
            MusicEngine.play('ending'); // [New] ì—”ë”© BGM ì¬ìƒ (íŒŒì¼ ì—†ìœ¼ë©´ ê¸°ë³¸ê³¡ Fallback)

            // [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ìŠ¹ë¦¬/íŒ¨ë°° ì²˜ë¦¬ (start() ì¬í˜¸ì¶œë¡œ ì—°ê²°)
            if (this.difficulty === 'tutorial') {
                if (pd) { // íŒ¨ë°°
                    UI.showModal("Defeat... ğŸ˜¢", 
                        `<p>ê´œì°®ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!</p>
                         <button onclick="Game.start()" 
                         style="padding:10px 20px; background:#ff7043; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ì¬ë„ì „ ğŸ”„
                         </button>`
                    );
                } else { // ìŠ¹ë¦¬
                     UI.showModal("Victory! ğŸ“", 
                        `<p>í›Œë¥­í•©ë‹ˆë‹¤! í•µì‹¬ ì „ëµì„ ì´í•´í•˜ì…¨êµ°ìš”.</p>
                         <button onclick="Game.tStage++; Game.start();" 
                         style="padding:10px 20px; background:#4caf50; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ë‹¤ìŒ ë ˆìŠ¨ìœ¼ë¡œ â¡ï¸
                         </button>`
                    );
                }
                return true;
            }

// [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ìŠ¹ë¦¬/íŒ¨ë°° ì²˜ë¦¬ ì¸í„°ì…‰íŠ¸
            if (this.difficulty === 'tutorial') {
                if (pd) { // íŒ¨ë°° (Player Dead)
                    UI.showModal("Defeat... ğŸ˜¢", 
                        `<p>ê´œì°®ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!</p>
                         <button onclick="Game.runTutorialLevel()" 
                         style="padding:10px 20px; background:#ff7043; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ì¬ë„ì „ ğŸ”„
                         </button>`
                    );
                } else { // ìŠ¹ë¦¬
                     UI.showModal("Victory! ğŸ“", 
                        `<p>í›Œë¥­í•©ë‹ˆë‹¤! í•µì‹¬ ì „ëµì„ ì´í•´í•˜ì…¨êµ°ìš”.</p>
                         <button onclick="Game.tStage++; Game.runTutorialLevel();" 
                         style="padding:10px 20px; background:#4caf50; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ë‹¤ìŒ ë ˆìŠ¨ìœ¼ë¡œ â¡ï¸
                         </button>`
                    );
                }
                return true; // ì—¬ê¸°ì„œ ì¢…ë£Œ (ê¸°ë³¸ ê²°ê³¼ì°½ ì¶œë ¥ ë°©ì§€)
            }

            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) {
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if (this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)");
            }
            localStorage.removeItem('et_save_v6');
            return true;
        }
        return false;
    },
    log: function(m) {
        const b = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.innerHTML = m;
        b.appendChild(d);
        
        // ğŸŸ¢ [ìµœì í™”] ë¡œê·¸ê°€ 50ê°œë¥¼ ë„˜ìœ¼ë©´ ê°€ì¥ ì˜¤ë˜ëœ ê²ƒë¶€í„° ì‚­ì œ (DOM ëˆ„ì  ë°©ì§€)
        while (b.children.length > 50) {
            b.removeChild(b.firstChild);
        }
        
        b.scrollTop = b.scrollHeight;
    },
    shake: function(u) {
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('shake');
            void el.offsetWidth;
            el.classList.add('shake');
        }
    },
    saveGame: function() {
        if (this.isOver) {
            alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue,
            curr: this.curr,
            turnCount: this.turnCount,
            difficulty: this.difficulty,
            mode: this.mode,
            selected: this.selected,
            // [Fix] ì„¸ë‡Œ ë°ì´í„° ì €ì¥ ì¶”ê°€
            mcCasterId: this.currentMCCasterId || null,
            mcTargetId: this.isMindControlling ? this.isMindControlling.id : null
        };
        const saveDataWithVersion = {
            ...saveData,
            version: GAME_CONFIG.SAVE_VERSION,
            schemaVersion: GAME_CONFIG.SCHEMA_VERSION,
            timestamp: Date.now()
        };
        localStorage.setItem('et_save_' + GAME_CONFIG.SAVE_VERSION, JSON.stringify(saveDataWithVersion));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },
    loadGame: function() {
        const json = localStorage.getItem('et_save_' + GAME_CONFIG.SAVE_VERSION);
        const savedStage = localStorage.getItem('et_challenge_stage');
        if (savedStage) this.challengeStage = parseInt(savedStage);
        if (!json) {
            alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`);
            return;
        }
        try {
            const data = JSON.parse(json);
            
            // ğŸ”’ ë²„ì „ ë° ìŠ¤í‚¤ë§ˆ ê²€ì¦
            if (!data.version || data.version !== GAME_CONFIG.SAVE_VERSION) {
                throw new Error('ë²„ì „ì´ í˜¸í™˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì €ì¥: ' + (data.version || 'ì•Œ ìˆ˜ ì—†ìŒ') + ', í˜„ì¬: ' + GAME_CONFIG.SAVE_VERSION + ')');
            }
            if (!data.schemaVersion || data.schemaVersion < GAME_CONFIG.SCHEMA_VERSION) {
                console.warn('âš ï¸ êµ¬ë²„ì „ ì„¸ì´ë¸Œ íŒŒì¼ì…ë‹ˆë‹¤. ì¼ë¶€ ë°ì´í„°ê°€ ì†ì‹¤ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
            if (!data.pTeam || !data.eTeam) {
                throw new Error('ì„¸ì´ë¸Œ ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
            this.difficulty = data.difficulty;
            this.mode = data.mode;
            
            // [Fix] UI ì…€ë ‰íŠ¸ ë°•ìŠ¤ë„ ì €ì¥ëœ ë‚œì´ë„ë¡œ ë™ê¸°í™”
            const diffSelect = document.getElementById('diff-select');
            if(diffSelect) {
                diffSelect.value = this.difficulty;
                // ë§Œì•½ ì €ì¥ëœ ë‚œì´ë„ê°€ ì˜µì…˜ì— ì—†ë‹¤ë©´(êµ¬ë²„ì „ ë“±), ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
                if (diffSelect.value !== this.difficulty) diffSelect.value = 'easy';
            }
            this.checkMode(); // ì±Œë¦°ì§€ ëª¨ë“œì¼ ê²½ìš° ìŠ¤í…Œì´ì§€ ì •ë³´ ê°±ì‹ 

            this.turnCount = data.turnCount;
            this.curr = data.curr;
            this.queue = data.queue;
            this.selected = data.selected;
            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));
            
            // [ì¶”ê°€] ì„¸ë‡Œ ìƒíƒœ ë³µêµ¬
            this.isMindControlling = null;
            this.currentMCCasterId = data.mcCasterId || null;
            if (data.mcTargetId !== null && data.mcTargetId !== undefined) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                const puppet = allUnits.find(u => u.id === data.mcTargetId);
                if (puppet && !puppet.isDead) {
                    this.isMindControlling = puppet;
                    this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ìƒíƒœë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.</span>");
                }
            }

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
            if (!u) {
                alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
                return;
            }
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                if (this.timer) clearTimeout(this.timer);

                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) {
            console.error('Save Load Error:', e);
            alert(`âš ï¸ ì„¸ì´ë¸Œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në°ì´í„°ê°€ ì†ìƒë˜ì—ˆê±°ë‚˜ ë²„ì „ì´ ë‹¤ë¦…ë‹ˆë‹¤.\n(ì˜¤ë¥˜ ë‚´ìš©: ${e.message})`);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì´ˆê¸°í™”í•˜ì—¬ ê¼¬ì„ ë°©ì§€
            localStorage.removeItem('et_save_v6'); 
        }
    },
    serializeUnit: function(u) {
        return {
            id: u.id,
            team: u.team,
            base: u.base,
            extra: u.extra,
            hp: u.hp,
            maxHp: u.maxHp,
            shield: u.shield,
            atk: u.atk,
            status: u.status,
            isDead: u.isDead,
            thornStack: u.thornStack,
            linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count,
            elecStacks: u.elecStacks,
            growthStack: u.growthStack,
            stats: u.stats,
            passiveTriggered: u.passiveTriggered,
            revengeAtk: u.revengeAtk,
            isSuper: u.isSuper
        };
    },
    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp;
        u.maxHp = d.maxHp;
        u.shield = d.shield;
        u.atk = d.atk;
        u.status = d.status;
        u.isDead = d.isDead;
        if (d.thornStack) u.thornStack = d.thornStack;
        if (d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if (d.s2Count) u.s2Count = d.s2Count;
        if (d.elecStacks) u.elecStacks = d.elecStacks;
        if (d.growthStack) u.growthStack = d.growthStack;
        if (d.stats) u.stats = d.stats;
        if (d.passiveTriggered) u.passiveTriggered = d.passiveTriggered;
        if (d.revengeAtk) u.revengeAtk = d.revengeAtk;
        if (d.isSuper) u.isSuper = d.isSuper;
        return u;
    },
    // ë°ë¯¸ì§€ ì˜ˆì¸¡ ê³„ì‚°ê¸°
    predictDmg: function(target) {
        if (this.selectedSkillIdx === -1 || !target) return 0;
        
        // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì) ì°¾ê¸°
        let atkUnit;
        if (this.isMindControlling) {
            atkUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            if (tVal === undefined || tVal === null) return 0;
            atkUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal/2)] : this.eTeam[Math.floor((tVal-1)/2)];
        }
        if (!atkUnit || atkUnit.isDead) return 0;

        const k = atkUnit.getKey();
        const s = SKILL_DB[k];
        if (!s) return 0;
        
        let mult = 1.0;
        
        if (this.selectedSkillIdx === 0) {
            mult = 1.0;
        } else {
            const desc = this.selectedSkillIdx === 1 ? s.s1d : s.s2d;
            if (!desc) return 0;
            
            // ë¹„ê³µê²© ìŠ¤í‚¬ íƒ€ì… í•„í„°ë§
            const nonAtkTypes = ['HEAL', 'BUFF', 'ALLY', 'ALL_ALLY', 'SELF_BUFF', 'TARGET_BUFF'];
            if (s.type && nonAtkTypes.includes(s.type)) return 0;
            if (desc.includes('í') || desc.includes('ì‰´ë“œ') || desc.includes('ì •í™”')) return 0;
            
            const match = desc.match(/([\d.]+)ë°°/);
            if (match) mult = parseFloat(match[1]);
        }

        const baseAtk = atkUnit.getAtk();
        const aff = this.calc(atkUnit, target);
        return Math.floor(baseAtk * mult * aff.v);
    },
    calc: (a, d) => {
        let v = 1.0;
        let t = '';
        if (a.isNormal) {
            if (d.isNormal || d.isEnhanced) {
                v = 1.2;
                t = '(ê°•íƒ€)';
            }
        } else {
            const w = {
                'Fire': ['Metal', 'Tree'],
                'Water': ['Fire', 'Metal'],
                'Tree': ['Water', 'Earth'],
                'Metal': ['Tree', 'Earth'],
                'Earth': ['Fire', 'Water']
            };
            const ew = {
                'Light': ['Dark'],
                'Dark': ['Light']
            };
            // [Balance] ê¸°ì´ˆ 5ì†ì„± ì •ì˜
            const basicElements = ['Fire', 'Water', 'Tree', 'Metal', 'Earth'];

            if (d.isNormal) {
                // [ìˆ˜ì •] ìˆœìˆ˜ ê¸°ì´ˆ 5ì†ì„±(ë³´ì¡° ì†ì„±ì´ ì—†ëŠ” ê²½ìš°)ì—ê²Œë§Œ 1.2ë°° í”¼í•´
                // Light, Darkê°€ ì„ì¸ ë³µí•© ì†ì„±ì´ë‚˜, ìˆœìˆ˜ Light/Darkì—ê²ŒëŠ” 1.0ë°°
                if (basicElements.includes(a.base) && !a.extra) {
                    v = 1.2;
                    t = '(ì•½ì )';
                }
            } else {
                if (w[a.base]?.includes(d.base) || ew[a.base]?.includes(d.base)) {
                    v = 1.2;
                    t = '(ì•½ì )';
                } else if (w[d.base]?.includes(a.base)) {
                    v = 0.8;
                    t = '(ì €í•­)';
                }
            }
        }
        if (v === 1.2 && a.extra && d.extra && ((a.extra === 'Light' && d.extra === 'Dark') || (a.extra === 'Dark' && d.extra === 'Light'))) {
            v = 1.3;
            t = '(ì¹˜ëª…íƒ€!)';
        }
        return {
            v,
            t
        };
    }
};
// ==========================================
// ğŸ“± [Mobile/Web] ë°±ê·¸ë¼ìš´ë“œ ì§„ì… ì‹œ ì†Œë¦¬ ì°¨ë‹¨
// ==========================================
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // [ìˆ¨ê¹€] í™”ë©´ì—ì„œ ì‚¬ë¼ì§€ë©´ -> ì¼ì‹œ ì •ì§€
        console.log("â¸ï¸ Background detected: Pausing audio.");

        // 1. MP3 ì •ì§€ (í˜„ì¬ ì¬ìƒ ì¤‘ì´ë¼ë©´)
        if (MusicEngine.currentAudio && !MusicEngine.currentAudio.paused) {
            MusicEngine.currentAudio.pause();
            MusicEngine.wasPlayingBeforeHide = true; // "ì›ë˜ ì¼œì ¸ ìˆì—ˆìŒ" í‘œì‹œ
        } else {
            MusicEngine.wasPlayingBeforeHide = false;
        }

        // 2. íš¨ê³¼ìŒ(AudioContext) ì •ì§€
        if (AudioSys.ctx && AudioSys.ctx.state === 'running') {
            AudioSys.ctx.suspend();
        }

    } else {
        // [ë³µê·€] í™”ë©´ì— ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ë©´ -> ì¬ìƒ ì¬ê°œ
        console.log("â–¶ï¸ Foreground detected: Resuming audio.");

        // 1. MP3 ì¬ê°œ (ì›ë˜ ì¼œì ¸ ìˆì—ˆê³ , ìŒì†Œê±° ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ)
        if (MusicEngine.wasPlayingBeforeHide && !AudioSys.bgmMuted) {
            if (MusicEngine.currentAudio) {
                MusicEngine.currentAudio.play().catch(e => console.log("Auto-resume blocked", e));
            } else {
                // ë§Œì•½ ì˜¤ë””ì˜¤ ê°ì²´ê°€ ë‚ ì•„ê°”ë‹¤ë©´ ìƒˆë¡œ ì¬ìƒ (Start)
                MusicEngine.play('Start');
            }
        }

        // 2. íš¨ê³¼ìŒ ì¬ê°œ
        if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') {
            AudioSys.ctx.resume();
        }
    }
});
window.onload = function() {
    Game.init();
};
</script>
</body>
</html>
