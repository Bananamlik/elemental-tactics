<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics v18.0 Refactored & Debugged</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.8), inset 0 -3px 6px rgba(0, 0, 0, 0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body {
            margin: 0;
            background-color: var(--bg-main);
            background-image: var(--paw-pattern);
            background-size: 80px 80px;
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: 0.3s;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
        .screen-shake {
            animation: jelly-bounce 0.5s both;
        }

        @keyframes jelly-bounce {
            0% { transform: scale(1, 1); }
            30% { transform: scale(1.15, 0.85); }
            40% { transform: scale(0.9, 1.1); }
            50% { transform: scale(1.05, 0.95); }
            65% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); }
        }

        /* ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ */
        button {
            font-family: var(--font-main);
            border-radius: 25px;
            border: none;
            background: #fff;
            color: #777;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-radius: 20px;
            pointer-events: none;
        }

        button:active {
            transform: translateY(3px) scale(0.98);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .btn-restart {
            padding: 8px 12px;
            font-size: 14px;
            color: var(--accent);
        }

        .btn-restart:hover {
            background: #fff0f5;
        }

        .mute-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #eee;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: 0.2s;
        }

        .mute-btn:active {
            transform: scale(0.9);
        }

        .mute-btn.muted {
            background: #ffebee;
            color: #e57373;
            border-color: #ffcdd2;
        }

        /* ë ˆì´ì•„ì›ƒ */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden;
        }

        #selection-screen {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        #battle-screen {
            display: none;
            padding: 5px;
            height: 100%;
            justify-content: space-between;
        }

        /* ì˜ì›… ì¹´ë“œ (ì„ íƒ í™”ë©´) */
        .hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            overflow-y: auto;
            padding: 5px;
            flex: 1;
        }

        /* [ì„ íƒ í™”ë©´ìš© ì¹´ë“œ ìŠ¤íƒ€ì¼] ì „íˆ¬ ìœ ë‹›(.unit) ìŠ¤íƒ€ì¼ì„ ë² ì´ìŠ¤ë¡œ í•¨ */
        .hero-card {
            /* .unit í´ë˜ìŠ¤ì™€ í•¨ê»˜ ì‚¬ìš©ë  ê²ƒì´ë¯€ë¡œ, ë ˆì´ì•„ì›ƒ ê´€ë ¨ë§Œ ì¬ì •ì˜ */
            position: relative;
            cursor: pointer;
            transition: 0.2s;
            /* ê·¸ë¦¬ë“œ ì•ˆì—ì„œ ê½‰ ì°¨ê²Œ */
            width: 100% !important; 
            max-width: none !important;
            height: 200px !important; /* ë†’ì´ í†µì¼ */
            margin: 0;
            opacity: 0.9;
        }

        .hero-card:hover { transform: translateY(-3px); z-index: 10; opacity: 1; }
        .hero-card:active { transform: scale(0.98); }

        /* [ì„ íƒë¨ íš¨ê³¼] */
        .hero-card.selected {
            border: 3px solid #d500f9 !important; /* ë³´ë¼ìƒ‰ í…Œë‘ë¦¬ */
            box-shadow: 0 0 15px #d500f9, inset 0 0 10px rgba(213, 0, 249, 0.2) !important;
            transform: translateY(-5px);
            z-index: 20;
            opacity: 1;
        }

        /* ì„ íƒ ì²´í¬ í‘œì‹œ (ìš°ì¸¡ ìƒë‹¨) */
        .hero-card.selected::after {
            content: 'âœ…';
            position: absolute;
            top: -10px; right: -10px;
            font-size: 24px;
            background: #fff;
            border-radius: 50%;
            width: 30px; height: 30px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 30;
        }

        /* ì „íˆ¬ ìœ ë‹› (Battle Unit) */
        .field-row {
            flex: 2; /* 1ì—ì„œ 2ë¡œ ë³€ê²½í•˜ì—¬ ìƒ/í•˜ë‹¨ ì¹´ë“œ ì˜ì—­ì„ ë” ë„“ê²Œ í™•ë³´ */
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            perspective: 1000px;
            padding: 5px 0;
            min-height: 0;
        }

        /* === [ì‹ ê·œ] ìœ ë‹› ì¹´ë“œ ë””ìì¸ === */
    .unit {
        width: 30vw;          /* ëª¨ë°”ì¼: í™”ë©´ ë„ˆë¹„ì˜ 30% */
        max-width: 160px;     /* PC/íƒœë¸”ë¦¿: ìµœëŒ€ 160pxê¹Œì§€ í™•ëŒ€ (ê¸°ì¡´ 110px) */
        height: 220px;        /* ë†’ì´ ëŒ€í­ í™•ëŒ€ (ê¸°ì¡´ 150px) */
        background: #fff;
        border-radius: 12px;
        position: relative;
        transition: 0.2s;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        border: 2px solid #fff;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        user-select: none;
        cursor: pointer;
    }

    /* [í°íŠ¸/UI í¬ê¸° ë³´ì •] ì¹´ë“œê°€ ì»¤ì§„ ë§Œí¼ ê¸€ìì™€ ì•„ì´ì½˜ë„ í‚¤ì›€ */
    .unit .card-name { font-size: 14px; margin-bottom: 4px; }
    .unit .card-atk { font-size: 13px; padding: 3px 6px; }
    .unit .tiny-icon { width: 30px; height: 30px; font-size: 18px; }
    .unit .card-badge { top: 8px; left: 8px; gap: 4px; }
    .unit .status-bar { height: 8px; }

    /* ë°°ê²½ ì´ë¯¸ì§€ ì˜ì—­ */
    .unit-img-bg {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background-size: cover;
        background-position: center;
        z-index: 0;
        transition: 0.3s;
    }

    /* ì£½ì—ˆì„ ë•Œ í‘ë°± ì²˜ë¦¬ */
    .unit.dead .unit-img-bg {
        filter: grayscale(1) brightness(0.7);
    }

    /* ì •ë³´ ì˜¤ë²„ë ˆì´ (í•˜ë‹¨ ê²€ì€ ê·¸ë¼ë°ì´ì…˜) */
    .unit-info-overlay {
        position: relative;
        z-index: 2;
        background: linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.5) 70%, transparent 100%);
        padding: 6px 4px;
        width: 100%;
        box-sizing: border-box;
        color: #fff;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    /* ìƒë‹¨ ì†ì„± ì•„ì´ì½˜ */
    .card-badge {
        position: absolute;
        top: 4px; left: 4px;
        width: 24px; height: 24px;
        background: rgba(255,255,255,0.9);
        border-radius: 50%;
        display: flex; justify-content: center; align-items: center;
        font-size: 16px;
        z-index: 2;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        border: 1px solid #eee;
    }

    /* ìš°ì¸¡ ìƒë‹¨ ê³µê²©ë ¥ */
    .card-atk {
        position: absolute;
        top: 5px; right: 5px;
        background: rgba(0,0,0,0.6);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 10px;
        color: #fff;
        font-weight: bold;
        z-index: 2;
        border: 1px solid rgba(255,255,255,0.2);
    }

    /* ì´ë¦„ í…ìŠ¤íŠ¸ */
    .card-name {
        font-size: 11px;
        font-weight: bold;
        text-align: center;
        text-shadow: 0 1px 2px #000;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 2px;
    }

    /* ìƒíƒœ íƒœê·¸ ì»¨í…Œì´ë„ˆ (ìœ„ì¹˜ ì¡°ì •) */
    .tag-container {
        position: absolute;
        bottom: 40px;
        left: 0; right: 0;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 2px;
        z-index: 5;
        pointer-events: none;
    }

    /* ì„ íƒ/íƒ€ê²Ÿ ì´í™íŠ¸ */
    .unit.active-turn { border-color: var(--accent); transform: translateY(-5px); box-shadow: 0 0 15px var(--accent); }
    .unit.target-enemy { border-color: #ff5252; background: #ffebee; }
    /* contentì—ì„œ ì´ëª¨ì§€ ì‚­ì œ */
    .unit.target-enemy::after { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:40px; z-index:10; text-shadow:0 0 10px red; opacity:0.8; }

    /* ê¸°ì¡´ ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (ê°•ì œ ì ìš©) */

    /* ê¸°ì¡´ ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (ê°•ì œ ì ìš©) */
    .unit-info-overlay .status-bar { height: 6px; background: rgba(255,255,255,0.3); border: none; margin-top:2px; width: 100%; }

        /* ê°ì„± ìŠ¤íƒ€ì¼ (Super Hero) */
        .unit.super-hero {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.5) !important;
            animation: super-pulse 1.5s infinite alternate;
            z-index: 10;
        }

        @keyframes super-pulse {
            0% { box-shadow: 0 0 10px #ffb300; border-color: #ffb300; }
            100% { box-shadow: 0 0 25px #ff6f00; border-color: #ffca28; }
        }

        .unit.active-turn {
            border-color: var(--accent);
            transform: translateY(-12px) scale(1.05);
            z-index: 5;
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3);
        }

        .unit.target-enemy:hover {
            border-color: #ff7043;
            background: #ffebee;
            cursor: crosshair;
            transform: scale(1.05) rotate(2deg);
        }

        .unit.target-ally:hover {
            border-color: #66bb6a;
            background: #e8f5e9;
            cursor: pointer;
            transform: scale(1.05) rotate(-2deg);
        }

        .unit.target-aoe {
            border-color: #ff7043;
            background: #ffebee;
            animation: jelly-bounce 1s infinite;
            cursor: pointer;
        }

        .unit.dead {
            opacity: 0.6;
            filter: grayscale(1);
            pointer-events: none;
            border-color: #cfd8dc;
            transform: scale(0.9) rotate(5deg);
            box-shadow: none;
        }

        /* [ëª¨ì–‘ í†µì¼] ëª¨ë“  ì—­í• êµ° ë‘¥ê·¼ ì‚¬ê°í˜•ìœ¼ë¡œ ê³ ì • */
        .unit.role-tank, .unit.role-nuker, .unit.role-supp { border-radius: 12px !important; }

        /* [ì‹ ê·œ] ì™¼ìª½ ìƒë‹¨ ì†ì„± ì•„ì´ì½˜ ì»¨í…Œì´ë„ˆ */
        .card-badge {
            position: absolute;
            top: 5px; left: 5px;
            width: auto !important; height: auto !important;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            display: flex;
            flex-direction: row; /* ì˜†ìœ¼ë¡œ ë‚˜ë€íˆ */
            gap: 2px;
            z-index: 5;
        }
        /* ê°œë³„ ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ */
        .tiny-icon {
            width: 24px; height: 24px;
            background: rgba(255,255,255,0.95);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: 1px solid #ddd;
        }

        .attr-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-bottom: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            color: #fff;
            position: relative;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            border: 3px solid #fff;
            flex-shrink: 0;
        }

        .mini-attr-box {
            position: absolute;
            bottom: -2px;
            right: -2px;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 12px;
            border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mini-icon { font-size: 10px; line-height: 1; }

        .elec-badge {
            position: absolute;
            /* [ìˆ˜ì •] ì¹´ë“œ ì•ˆìª½ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°°ì¹˜í•˜ì—¬ ì˜ë¦¼ ë°©ì§€ */
            top: 30px;  
            right: 4px;
            background: #ffeb3b;
            color: #f57f17;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        /* [ì‹ ê·œ] ë‚˜ë¬´ ìŠ¤íƒ ë±ƒì§€ (Metal-Dark ì°¸ê³ ) */
        .tree-badge {
            position: absolute;
            /* [ìˆ˜ì •] ì¹´ë“œ ì•ˆìª½ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ë°°ì¹˜í•˜ì—¬ ì˜ë¦¼ ë°©ì§€ */
            top: 30px; 
            right: 4px;
            background: #66bb6a; /* ì´ˆë¡ìƒ‰ */
            color: #fff;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        .status-bar {
            width: 85%;
            height: 10px;
            background: #eceff1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .hp-fill {
            height: 100%;
            background: var(--hp-high);
            border-radius: 10px;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
        }

        .shield-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--shield);
            opacity: 0.8;
            border-radius: 10px;
            transition: width 0.3s;
        }

        .control-panel {
            flex: 0 0 auto;
            max-height: 45vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px 30px 0 0;
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            border-top: 5px solid #ff80ab;
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        /* [ë ˆì´ì•„ì›ƒ ì••ì¶•] í—¤ë”ì— íƒ€ì„ë¼ì¸ í†µí•© */
        .cp-header {
            padding: 5px 10px;
            background: #fff8e1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px dashed #ffe082;
            font-size: 13px;
            height: 40px; /* ë†’ì´ ê³ ì • */
            flex-shrink: 0;
        }
        
        /* ê¸°ì¡´ íƒ€ì„ë¼ì¸ ì»¨í…Œì´ë„ˆ ì‚­ì œ (í—¤ë”ë¡œ ì´ë™ë¨) */
        .timeline-container { display: none; } 

        /* [ì‹ ê·œ] ì™¼ìª½ ì‚¬ì´ë“œ í”Œë¡œíŒ… ì»¨íŠ¸ë¡¤ */
        /* [ì‚¬ì´ë“œ ë©”ë‰´ ìŠ¤íƒ€ì¼] */
.side-controls { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 9999; }
.side-btn { width: 44px; height: 44px; border-radius: 50%; background: #fff; border: 2px solid #ddd; font-size: 22px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.2); cursor: pointer; transition: all 0.2s; position: relative; z-index: 10; }
.side-btn:active { transform: scale(0.9); }
.side-btn:hover { border-color: #ff80ab; transform: scale(1.1); }
.main-menu-btn { background: #5d4037; color: #fff; border-color: #5d4037; }

/* ìˆ¨ê²¨ì§„ í´ë” */
.dock-folder { display: none; flex-direction: column; gap: 8px; padding-top: 5px; }
.dock-folder.show { display: flex; animation: slide-down 0.2s forwards; }
@keyframes slide-down { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

/* íŒì—… ìœ„ì¹˜ ê°•ì œ ê³ ì • */
.save-menu, .settings-modal { left: 55px !important; top: 0 !important; }
        .side-btn:active { transform: scale(0.9); }
        
        /* ì €ì¥/ë¡œë“œ íŒì—… ë©”ë‰´ */
        .save-menu {
            display: none;
            position: absolute; left: 50px; top: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px; padding: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 2px solid #ffcc80;
            flex-direction: column; gap: 5px;
            width: 120px;
            backdrop-filter: blur(5px);
        }
        .save-opt {
            padding: 8px; border: 1px solid #ddd; border-radius: 10px;
            background: #fff; font-size: 12px; cursor: pointer; text-align: center; color: #555; font-weight: bold;
        }
        .save-opt:hover { background: #fff3e0; color: #f57c00; }

        .timeline-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
            margin-right: 5px;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); }
        }

        .tl-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            border: 2px solid #eee;
            position: relative;
            flex-shrink: 0;
            transition: 0.3s;
            background: #fff;
            box-shadow: 0 2px 0 #ddd;
        }

        .tl-node.curr {
            border-color: var(--accent);
            transform: scale(1.3);
            z-index: 2;
            border-width: 3px;
            animation: active-pulse 1.5s infinite;
        }

        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container {
            flex: 1;
            padding: 5px 10px; /* íŒ¨ë”© ì¶•ì†Œ */
            overflow-y: auto;
            font-size: 12px;
            border-bottom: 2px solid #f0f0f0;
            background: #fff;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            min-height: 30px;  /* ìµœì†Œ ë†’ì´ ì¶•ì†Œ */
            max-height: 60px;  /* ìµœëŒ€ ë†’ì´ ëŒ€í­ ì¶•ì†Œ (120 -> 60) */
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            background: #fafafa;
            border-radius: 10px;
            word-break: keep-all;
            border-left: 3px solid #eee;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .log-ally { color: #29b6f6; font-weight: bold; }
        .log-enemy { color: #ff7043; font-weight: bold; }
        .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }

        /* [UI ê°œì„ ] ë†’ì´ ìœ ë™ì  ë³€ê²½ (ì˜ë¦¼ ë°©ì§€) */
        .btn-group {
            display: flex;
            min-height: 60px; /* 80px -> 60pxë¡œ ì¶•ì†Œ */
            height: auto;
            flex-shrink: 0;
            padding: 4px;     /* íŒ¨ë”© ì•½ê°„ ì¶•ì†Œ */
            gap: 4px;
            background: #fff5f8;
        }

        .skill-btn {
            flex: 1;
            border: none;
            background: #fff;
            border-radius: 15px;
            cursor: pointer;
            transition: 0.2s;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 4px;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
        }

        .skill-btn::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            border-radius: 15px;
            pointer-events: none;
        }

        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }

        .passive-panel {
            background: #e0f2f1;
            padding: 2px 8px;  /* íŒ¨ë”© ì¶•ì†Œ */
            font-size: 11px;
            color: #00695c;
            display: flex;
            align-items: center;
            border-radius: 8px;
            margin: 2px 5px;   /* ì—¬ë°± ëŒ€í­ ì¶•ì†Œ */
            border: 1px solid #b2dfdb;
            flex-shrink: 0;
            height: 24px;      /* ë†’ì´ ê°•ì œ ê³ ì • */
        }

        .passive-icon { margin-right: 5px; font-size: 14px; }

        .btn-start {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 20px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 5px 0 #c2185b, 0 10px 15px rgba(0, 0, 0, 0.15);
            transition: 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(5px); box-shadow: 0 0 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-rnd {
            background: #b39ddb;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            box-shadow: 0 4px 0 #7e57c2;
        }

        .btn-rnd:active { transform: translateY(4px); box-shadow: none; }

        .tag-container {
            position: absolute;
            top: auto;          /* ìƒë‹¨ ê³ ì • í•´ì œ */
            bottom: 55px;       /* í•˜ë‹¨ ì´ë¦„í‘œ ë°”ë¡œ ìœ„ë¡œ ìœ„ì¹˜ ë³€ê²½ */
            left: 5px;
            right: 5px;
            display: flex;
            justify-content: center;
            gap: 3px;
            flex-wrap: wrap-reverse; /* íƒœê·¸ê°€ ìŒ“ì¼ ë•Œ ìœ„ìª½ìœ¼ë¡œ ìŒ“ì´ë„ë¡ ì„¤ì • */
            z-index: 10;
            pointer-events: none;
            /* max-height ì œí•œì„ í’€ì–´ ì—¬ëŸ¬ ê°œê°€ ê±¸ë ¤ë„ ë³´ì´ê²Œ í•¨ */
        }

        .tag {
            padding: 2px 4px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 1px;
            white-space: nowrap;
            height: 14px;
            display: flex;
            align-items: center;
        }

        .tag.poison { background: #ab47bc; }
        .tag.stun { background: #ffd54f; color: #5d4037; }
        .tag.freeze { background: #29b6f6; }
        .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; }
        .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; }
        .tag.bind { background: #66bb6a; }
        .tag.trap { background: #d4e157; color: #5d4037; }
        .tag.atkdown { background: #5c6bc0; }
        .tag.growth { background: #9ccc65; color: #33691e; }
        .tag.blind { background: #bdbdbd; color: #5d4037; }
        .tag.immunity { background: #fff; color: #5d4037; border: 1px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color: #fff; }
        /* [ì‹ ê·œ] ì¹˜ìœ  ê°ì†Œ ìˆ˜ì¹˜ë³„ ìƒ‰ìƒ êµ¬ë¶„ */
        .tag.heal-20 { background: #ab47bc; color: #fff; } /* ë³´ë¼ìƒ‰ (ë…) */
        .tag.heal-50 { background: #fb8c00; color: #fff; } /* ì£¼í™©ìƒ‰ (ëª¨ë˜) */
        .tag.heal-critical { background: #c62828; color: #fff; font-weight:bold; animation: jelly-bounce 2s infinite; } /* ê³ ìœ„í—˜ */
        .tag.atkup { background: #ef5350; color: #fff; }
        .tag.taunt {
            background: #212121;
            color: #ff5252;
            border: 1px solid #ff1744;
            box-shadow: 0 0 4px rgba(255, 23, 68, 0.6);
            font-weight: 900;
        }
        .tag.karma {
            background: #512da8;
            color: #fff;
            border: 1px solid #d1c4e9;
            animation: jelly-bounce 2s infinite;
        }
        /* ì„ ê³µë°©ì–´ ë©´ì—­ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.start-immunity { background: #00bcd4; color: #fff; border: 1px solid #80deea; box-shadow: 0 0 5px #00e5ff; }
        /* [ì‹ ê·œ] ì„¸ë‡Œ ê´€ë ¨ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.mc-wait { background: #5e35b1; color: #fff; border: 1px solid #b39ddb; animation: jelly-bounce 2s infinite; }
        .tag.mc-ready { background: #d500f9; color: #fff; border: 2px solid #ea80fc; box-shadow: 0 0 10px #d500f9; font-weight:900; }

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color: #1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color: #5d4037; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color: #5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        /* [ë°ë¯¸ì§€ í°íŠ¸ ì„¸ë¶„í™”] */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 28px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        .ft-dmg { color: #ff7043; }
        .ft-crit { color: #ffa726; font-size: 36px; text-shadow: 2px 2px 0 #d84315; }
        .ft-heal { color: #26a69a; animation: floatUpSlow 1.2s ease-out forwards; }
        .ft-miss { color: #b0bec5; font-size: 20px; }
        .ft-weak { color: #d32f2f; font-size: 32px; font-weight: 900; animation: shake-dmg 0.4s ease-in-out; }
        .ft-resist { color: #78909c; font-size: 18px; opacity: 0.8; }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        @keyframes floatUpSlow {
            0% { transform: translate(-50%, 0); opacity: 0; }
            50% { transform: translate(-50%, -40px); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        @keyframes shake-dmg {
            0%, 100% { transform: translate(-50%, -20px); }
            25% { transform: translate(-55%, -20px); }
            75% { transform: translate(-45%, -20px); }
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 248, 225, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 35px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3);
            overflow-y: auto;
            max-height: 80vh;
            border: 5px solid #ffcc80;
            position: relative;
        }

        /* [ì»·ì‹ ] ìŠ¤íƒ€ì¼ */
        #cut-in-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cut-in-img {
            font-size: 120px;
            animation: cut-in-zoom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .cut-in-text {
            font-size: 40px;
            color: #fff;
            font-weight: 900;
            margin-top: 20px;
            animation: slide-up 0.5s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes cut-in-zoom {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes slide-up {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* [íˆ´íŒ] ìŠ¤íƒ€ì¼ */
        #tooltip-view {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 150;
            max-width: 200px;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
            text-align: left;
        }

        .tooltip-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 45vh; }
            .btn-group { min-height: 72px; height: auto; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 10px; display: block; line-height: 1.2; }
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
/* [ì‹ ê·œ] ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° & ê°ì •í‘œí˜„ */
        .hp-preview {
            position: absolute;
            top: 0; bottom: 0;
            background: rgba(255, 23, 68, 0.8); /* ë¶‰ì€ìƒ‰ ë°ë¯¸ì§€ ê²½ê³  */
            z-index: 5; pointer-events: none;
            transition: all 0.1s;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
            animation: blink-preview 0.5s infinite alternate;
        }
        @keyframes blink-preview { from { opacity: 0.4; } to { opacity: 0.9; } }
        .emote-bubble {
            position: absolute; top: -45px; left: 50%; transform: translateX(-50%);
            background: #fff; border: 3px solid #333; border-radius: 20px;
            padding: 8px 12px; font-size: 24px; z-index: 50;
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            white-space: nowrap; pointer-events: none;
        }
        @keyframes pop-in { from { transform: translateX(-50%) scale(0); } to { transform: translateX(-50%) scale(1); } }
        
        .emote-menu {
            position: absolute; display: flex; gap: 8px; 
            background: rgba(255,255,255,0.95); padding: 8px; 
            border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 100; border: 2px solid #eee;
            animation: fade-up 0.2s;
        }
        @keyframes fade-up { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
        .emote-btn { 
            font-size: 22px; cursor: pointer; transition: 0.2s; 
            width: 36px; height: 36px; border-radius: 50%; 
            display:flex; align-items:center; justify-content:center;
        }
        .emote-btn:hover { transform: scale(1.2); background: #f0f0f0; }
        /* [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (ì‹œê°„ ì •ì§€ íš¨ê³¼) */
        body.hit-stopped .unit,
        body.hit-stopped .float-text {
            animation-play-state: paused !important;
            transition: none !important;
        }
       /* [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë° íƒ€ê²© ì´í™íŠ¸ */
        .projectile {
            position: absolute;
            font-size: 24px;
            z-index: 150;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        .impact-effect {
            position: absolute;
            font-size: 40px;
            z-index: 151;
            pointer-events: none;
            animation: impact-pop 0.3s ease-out forwards;
        }
        @keyframes impact-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
/* [ì‹ ê·œ] ì˜¤ë””ì˜¤ ì„¤ì • UI */
        .settings-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .settings-btn:active { transform: scale(0.9); }

        .settings-modal {
            display: none; position: absolute; top: 60px; right: 15px;
            width: 240px; background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 15px; z-index: 110;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); border: 2px solid #ffcc80;
            backdrop-filter: blur(5px); flex-direction: column; gap: 10px;
        }
        .set-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #5d4037; font-weight: bold; }
        .vol-slider { flex: 1; margin-left: 10px; accent-color: #ff80ab; height: 6px; }
        
        .bgm-select { display: flex; gap: 5px; margin-top: 5px; }
        .bgm-opt { 
            flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 10px; 
            background: #fff; font-size: 11px; cursor: pointer; text-align: center; color: #888;
        }
        .bgm-opt.active { background: #fff8e1; border-color: #ffb74d; color: #f57c00; font-weight: bold; }
        
        .toggle-btn {
            width: 40px; height: 20px; background: #ccc; border-radius: 20px;
            position: relative; cursor: pointer; transition: 0.3s;
        }
        .toggle-btn.on { background: #66bb6a; }
        .toggle-btn::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            transition: 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-btn.on::after { left: 22px; }
        /* =========================================
   [ìƒˆë¡œìš´ í„´ í™œì„±í™” ë””ìì¸ ì ìš©]
   ê¸°ì¡´ì˜ íŠ€ì–´ì˜¤ë¦„ ë° ë‘êº¼ìš´ í…Œë‘ë¦¬ë¥¼ ì œê±°í•˜ê³ ,
   ë ˆì´ì•„ì›ƒì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ë¹›(Glow) íš¨ê³¼ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.
========================================= */

/* 1. í™œì„±í™”ëœ ì¹´ë“œ ìŠ¤íƒ€ì¼ ì¬ì •ì˜ */
.unit.active-turn {
    /* [ì¬ìˆ˜ì •] ì´ì›ƒ ì¹´ë“œë¥¼ ê°€ë¦¬ì§€ ì•Šë„ë¡ í™•ëŒ€/íšŒì „ ì œê±° */
    /* ìœ„ë¡œë§Œ ì‚´ì§(-5px) ë– ì˜¤ë¥´ê²Œ í•˜ì—¬ "ë‚˜ ì—¬ê¸° ìˆì–´" ì‹ í˜¸ë§Œ ì¤ë‹ˆë‹¤ */
    transform: translateY(-5px) !important; 
    
    /* ëŒ€ì‹  í…Œë‘ë¦¬ë¥¼ ì•„ì£¼ ì§„í•˜ê³  ë‘ê»ê²Œ(3px -> 4px) ë³€ê²½í•˜ì—¬ ì‹œì¸ì„± í™•ë³´ */
    border: 4px solid #ff4081 !important; 
    z-index: 10 !important; /* í…Œë‘ë¦¬ê°€ ì˜ ë³´ì´ë„ë¡ ë ˆì´ì–´ ìˆœì„œ ë³´ì • */

    /* ë‚´ë¶€ê°€ í™˜í•˜ê²Œ ë¹„ì¹˜ëŠ” í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼ ì¶”ê°€ */
    box-shadow: 0 10px 20px rgba(255, 64, 129, 0.4), inset 0 0 15px rgba(255, 255, 255, 0.8) !important;
    
    transition: transform 0.2s ease-out, border 0.2s, box-shadow 0.2s;
    /* ì‹¬ì¥ ë°•ë™ì²˜ëŸ¼ ê¹œë¹¡ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ ìœ ì§€ */
    animation: active-glow-pulse 1.5s infinite ease-in-out;
}

/* 2. ë¹›ì´ ìˆ¨ì‰¬ë“¯ ì¼ë ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
@keyframes active-glow-pulse {
    0%, 100% {
        /* ë¹›ì´ ì€ì€í•  ë•Œ */
        box-shadow: 
            0 0 10px 2px var(--accent),          /* ì™¸ë¶€ í›„ê´‘ */
            inset 0 0 5px rgba(255, 255, 255, 0.3); /* ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸ */
    }
    50% {
        /* ë¹›ì´ ê°€ì¥ ê°•í•  ë•Œ */
        box-shadow: 
            0 0 20px 5px var(--accent),          /* ë” ë„“ê³  ì§„í•œ ì™¸ë¶€ í›„ê´‘ */
            inset 0 0 15px rgba(255, 255, 255, 0.5); /* ë” ê°•í•œ ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸ */
    }
}

/* 3. í”Œë ˆì´ì–´ ì¹´ë“œ ì¶”ê°€ ë³´ì • (í˜¹ì‹œ ëª¨ë¥¼ ë¯¸ì„¸ ê²¹ì¹¨ ë°©ì§€) */
/* í”Œë ˆì´ì–´ ì¹´ë“œëŠ” ì»¨íŠ¸ë¡¤ íŒ¨ë„ê³¼ ê°€ê¹Œìš°ë¯€ë¡œ í•˜ë‹¨ ë§ˆì§„ì„ ì‚´ì§ í™•ë³´ */
#player-row .unit.active-turn {
    margin-bottom: 4px; 
    transition: margin-bottom 0.3s ease;
}
/* ë¹„í™œì„± ìƒíƒœì¼ ë•Œ ìì—°ìŠ¤ëŸ½ê²Œ ë³µê·€ */
#player-row .unit:not(.active-turn) {
     margin-bottom: 0;
     transition: margin-bottom 0.3s ease;
}
/* í•˜ë‹¨ ë©”ë‰´ìš© ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜ */
@keyframes slide-up-menu { 
    from { opacity: 0; transform: translateY(20px); } 
    to { opacity: 1; transform: translateY(0); } 
}
.dock-folder.show { 
    animation: slide-up-menu 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards !important; 
}
/* [ì¤‘ìš”] ë©”ë‰´ê°€ íŒ¨ë„ ë°–ìœ¼ë¡œ íŠ€ì–´ë‚˜ì™€ë„ ì˜ë¦¬ì§€ ì•Šê²Œ í•¨ */
.control-panel {
    overflow: visible !important;
}
/* [ê¸´ê¸‰ ìˆ˜ì •] í•˜ë‹¨ íŒ¨ë„ ë° ë©”ë‰´ ê³„ì¸µ ìµœìƒìœ„ë¡œ ê²©ìƒ */
.control-panel {
    z-index: 5000 !important; /* ìœ ë‹›(100), ì´í™íŠ¸(999)ë³´ë‹¤ ë¬´ì¡°ê±´ ë†’ê²Œ */
    overflow: visible !important; /* ë©”ë‰´ê°€ íŒ¨ë„ ë°–ìœ¼ë¡œ íŠ€ì–´ë‚˜ê°€ë„ ë³´ì´ê²Œ */
}

/* ë©”ë‰´ ì•ˆì˜ íŒì—…ë“¤(ì €ì¥/ì„¤ì •) ìœ„ì¹˜ ë° í´ë¦­ ë³´ì • */
.dock-folder {
    z-index: 6000 !important; /* íŒ¨ë„ë³´ë‹¤ ë” ë†’ê²Œ */
    pointer-events: auto !important; /* í´ë¦­ ê°•ì œ í—ˆìš© */
}

/* ì„¤ì •/ì €ì¥ íŒì—…ì°½ ìŠ¤íƒ€ì¼ ë³´ì • (ë©”ë‰´ ì˜†ìœ¼ë¡œ ì˜ˆì˜ê²Œ ëœ¨ê²Œ) */
.settings-modal, .save-menu {
    position: absolute !important;
    bottom: 0 !important;
    right: 45px !important; /* ì•„ì´ì½˜ ë°”ë¡œ ì™¼ìª½ìœ¼ë¡œ ë°°ì¹˜ */
    top: auto !important;
    left: auto !important;
    z-index: 7000 !important; /* ë©”ë‰´ë³´ë‹¤ë„ ë†’ê²Œ */
    background: rgba(255, 255, 255, 0.95);
    border: 2px solid var(--text-main);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    width: 180px; /* ë„ˆë¹„ í™•ë³´ */
}
/* [ì‹ ê·œ] ì‹¤ë“œ ê²Œì´ì§€ ë° ì²´ë ¥ë°” ìŠ¤íƒ€ì¼ ë³´ì • */
.status-bar {
    position: relative; /* ì‹¤ë“œ ê²¹ì¹˜ê¸°ë¥¼ ìœ„í•œ ê¸°ì¤€ì  */
    background: #444; /* ë¹ˆ ê³µê°„ ë°°ê²½ìƒ‰ */
    overflow: hidden; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ ìœ ì§€ */
}

.hp-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    z-index: 1; /* ì²´ë ¥ì€ 1ì¸µ */
    transition: width 0.3s ease;
}

.shield-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    background-color: var(--shield); /* ë³´ë¼ìƒ‰ (#ce93d8) */
    opacity: 0.75; /* ì‚´ì§ íˆ¬ëª…í•˜ê²Œ í•´ì„œ ì²´ë ¥ê³¼ ê²¹ì³ ë³´ì´ê²Œ */
    z-index: 2; /* ì‹¤ë“œëŠ” ì²´ë ¥ ìœ„ì— 2ì¸µìœ¼ë¡œ í‘œì‹œ */
    pointer-events: none;
    transition: width 0.3s ease;
    box-shadow: 0 0 5px rgba(206, 147, 216, 0.5); /* ë¹›ë‚˜ëŠ” íš¨ê³¼ */
}
/* =========================================
   [ì—…ê·¸ë ˆì´ë“œ] ìŠ¤í‚¬ ì´í™íŠ¸ (VFX) ì‹œìŠ¤í…œ V2
   ========================================= */
.vfx-layer {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 10000; /* ìœ ë‹›ë³´ë‹¤ ë¬´ì¡°ê±´ ìœ„ (10000) */
    font-size: 80px; /* í¬ê¸° 2ë°° í™•ëŒ€ (40px -> 80px) */
    display: flex;
    justify-content: center;
    align-items: center;
    white-space: nowrap;
    filter: drop-shadow(0 0 10px rgba(0,0,0,0.5)); /* ê·¸ë¦¼ì ì¶”ê°€ë¡œ ê°€ì‹œì„± í™•ë³´ */
}

/* 1. íƒ€ê²©/í­ë°œ: í™”ë©´ì„ ëš«ê³  ë‚˜ì˜¬ ë“¯í•œ í™•ëŒ€ */
@keyframes vfx-boom {
    0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; filter: brightness(2.0); } /* ë°ê²Œ ë¹›ë‚¨ */
    100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; }
}

/* 2. ë² ê¸°: ë¹ ë¥´ê³  ê°•ë ¬í•œ ê¶¤ì  */
@keyframes vfx-slash {
    0% { transform: translate(-50%, -50%) scale(0.5) rotate(-45deg); opacity: 0; }
    20% { transform: translate(-50%, -50%) scale(1.2) rotate(0deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5) rotate(45deg); opacity: 0; }
}

/* 3. íšŒë³µ: ì²œì²œíˆ ìœ„ë¡œ ì˜¬ë¼ê°€ë©° ë°˜ì§ì„ */
@keyframes vfx-heal {
    0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
    50% { transform: translate(-50%, -50px) scale(1.2); opacity: 1; text-shadow: 0 0 20px #4caf50; }
    100% { transform: translate(-50%, -100px) scale(1.5); opacity: 0; }
}

/* 4. ë§ˆë²•: íšŒì „í•˜ë©° ì»¤ì§ */
@keyframes vfx-magic {
    0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(3) rotate(720deg); opacity: 0; }
}
/* [2P ì „ìš© ìŠ¤íƒ€ì¼: íŒŒë€ìƒ‰/ë³´ë¼ìƒ‰ ê³„ì—´ë¡œ ë³€í™˜] */
        .unit.team-1 .unit-img, 
        .hero-card.p2-selected .unit-img-bg {
            filter: hue-rotate(180deg) brightness(1.1) !important;
        }
        .unit.team-1 .hp-bar-fill {
            background: #5c6bc0 !important;
        }
        /* 2P ì„ íƒ ì¹´ë“œ ê°•ì¡° */
        .hero-card.p2-selected {
            border: 3px solid #5c6bc0 !important;
            transform: scale(1.05);
            box-shadow: 0 0 15px #5c6bc0;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
<div id="tooltip-view"></div>
<div id="flash-overlay"></div>
<!-- [ì»·ì‹ ] ì˜¤ë²„ë ˆì´ -->
<div id="cut-in-overlay">
    <div class="cut-in-img" id="cut-in-emoji">ğŸ¦</div>
    <div class="cut-in-text" id="cut-in-msg">FINISH!</div>
</div>
<!-- [íˆ´íŒ] ë·° -->

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v17.1 Fixed (ILLUST)</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="UI.showCollection()">ğŸ’ Codex</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="tutorial">ğŸ“š íŠœí† ë¦¬ì–¼ (ê¸°ì´ˆ)</option>
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
 
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="btn-online" class="btn-start" style="flex:1; background:#7e57c2; font-size:16px;" onclick="UI.openOnlineModal()">
                ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
            </button>
            <button id="btn-start" class="btn-start" style="flex:1; font-size:16px;" onclick="Game.start()" disabled>
                âš”ï¸ ì „íˆ¬ ì‹œì‘
            </button>
        </div>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header" style="position:relative; padding-right:50px;">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width: 100%;">Ready... ğŸ±</span>
                
                <div style="position:absolute; right:5px; top:50%; transform:translateY(-50%); z-index: 100;">
                    <div class="side-btn main-menu-btn" onclick="UI.toggleDock()" style="width:32px; height:32px; font-size:16px; margin:0;" title="ë©”ë‰´">âš™ï¸</div>
                    
                    <div id="dock-folder" class="dock-folder" style="position:absolute; bottom:110%; right:0; flex-direction:column-reverse; background:transparent; padding-bottom:5px;">
                        <div class="side-btn" onclick="Game.reset()" title="í™ˆ" style="width:32px; height:32px; font-size:16px;">ğŸ </div>
                        
                        <div style="position:relative;">
                            <div class="side-btn" onclick="UI.toggleSettings()" title="ì†Œë¦¬" style="width:32px; height:32px; font-size:16px;">ğŸµ</div>
                            <div id="audio-settings" class="settings-modal" style="bottom:0; right:40px; top:auto; left:auto;">
                                <div class="set-row"><span>ë³¼ë¥¨</span><input type="range" class="vol-slider" min="0" max="100" value="50" oninput="AudioSys.setMasterVolume(this.value)"></div>
                                <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
                                <div class="set-row"><span>BGM</span><div class="toggle-btn on" id="tog-bgm" onclick="AudioSys.toggleChannel('bgm')"></div></div>
                                <div class="bgm-select"><div class="bgm-opt active" onclick="UI.selectBGM('Canon_Piano', this)">ğŸ¹í”¼ì•„ë…¸</div><div class="bgm-opt" onclick="UI.selectBGM('Battle_Piano', this)">âš”ï¸ì „íˆ¬</div></div>
                                <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
                                <div class="set-row"><span>SFX</span><div class="toggle-btn on" id="tog-sfx" onclick="AudioSys.toggleChannel('sfx')"></div></div>
                            </div>
                        </div>

                        <div style="position:relative;">
                            <div class="side-btn" onclick="UI.toggleSaveMenu()" title="ì €ì¥" style="width:32px; height:32px; font-size:16px;">ğŸ’¾</div>
                            <div id="save-menu-popup" class="save-menu" style="bottom:0; right:40px; top:auto; left:auto;">
                                <div class="save-opt" onclick="Game.saveGame(); UI.toggleSaveMenu()">ğŸ’¾ì €ì¥</div>
                                <div class="save-opt" onclick="Game.loadGame(); UI.toggleSaveMenu()">ğŸ“‚ë¡œë“œ</div>
                            </div>
                        </div>

                        <div class="side-btn" onclick="UI.showGuide()" title="ê°€ì´ë“œ" style="width:32px; height:32px; font-size:16px;">ğŸ“–</div>
                        <div class="side-btn" onclick="UI.showCollection()" title="ë„ê°" style="width:32px; height:32px; font-size:16px;">ğŸ’</div>
                    </div>
                </div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
let socket;
// ==================== [ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸°] ====================
class SeededRandom {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0) this.seed += 2147483646;
    }
    
    next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    }
}

let globalRNG = null; // ì „ì—­ RNG ì¸ìŠ¤í„´ìŠ¤
if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {},
        emit: () => {},
        connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ");
}

let myRole = null;
let myRoom = null;
let isOnlineMode = false;
let netRndBuffer = []; // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ í˜¸í™˜ì„± ìœ ì§€
let netRndIdx = 0;
let isReplaying = false;
let gameSeed = null; // ì„œë²„ì—ì„œ ë°›ì€ ì‹œë“œ ì €ì¥

// [New] ë””ë²„ê·¸ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë„êµ¬
const DEBUG = {
    enabled: false, // ì½˜ì†”ì—ì„œ DEBUG.toggle()ë¡œ ì¼¤ ìˆ˜ ìˆìŒ
    log: function(...args) { if (this.enabled) console.log('%c[DEBUG]', 'color:cyan; font-weight:bold;', ...args); },
    error: function(...args) { if (this.enabled) console.error('%c[DEBUG ERR]', 'color:red; font-weight:bold;', ...args); },
    toggle: function() { this.enabled = !this.enabled; console.log(`ğŸ•µï¸ Debug Mode: ${this.enabled ? 'ON' : 'OFF'}`); }
};

const PERF = {
    timers: {},
    start: function(label) { if(DEBUG.enabled) this.timers[label] = performance.now(); },
    end: function(label) {
        if (DEBUG.enabled && this.timers[label]) {
            const t = performance.now() - this.timers[label];
            console.log(`%câ±ï¸ [PERF] ${label}: ${t.toFixed(2)}ms`, 'color:orange');
            delete this.timers[label];
        }
    }
};

// [ì¶”ê°€] ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('âš ï¸ Global Error:', {
        message: msg,
        line: lineNo,
        column: columnNo,
        error: error
    });
    
    // ê²Œì„ì´ ì´ë¯¸ ëë‚¬ê±°ë‚˜, Game ê°ì²´ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    if (typeof Game === 'undefined' || Game.isOver) return false;

    // ê²Œì„ ì¤‘ë‹¨ ë°©ì§€ (ìë™ ë³µêµ¬ ì‹œë„)
    if (Game.timer) clearTimeout(Game.timer);
    if (Game.watchdog) clearTimeout(Game.watchdog);
    
    // UIì— ì•Œë¦¼ í‘œì‹œ (Game.logê°€ ìˆë‹¤ë©´)
    if (Game.log) {
        Game.log("<span class='log-sys' style='color:red;'>âš ï¸ ì˜¤ë¥˜ ë°œìƒ! ìë™ ë³µêµ¬(í„´ ë„˜ê¸°ê¸°) ì‹œë„ ì¤‘...</span>");
    }

    // 1ì´ˆ ë’¤ ê°•ì œë¡œ í„´ì„ ë„˜ê²¨ì„œ ê²Œì„ì„ ì‚´ë¦¼
    setTimeout(() => {
        try {
            if (Game.endTurn) Game.endTurn();
        } catch(e) {
            console.error('Recovery failed:', e);
            alert("ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
        }
    }, 1000);
    
    return true; // ì—ëŸ¬ê°€ ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë¹¨ê°›ê²Œ ë„ë°°ë˜ëŠ” ê²ƒì„ ë°©ì§€
};

function getNetRandom() {
    // ì˜¨ë¼ì¸ ëª¨ë“œ: ì„œë²„ ì‹œë“œ ê¸°ë°˜ RNG ì‚¬ìš©
    if (isOnlineMode && globalRNG) {
        return globalRNG.next();
    }
    // ì˜¤í”„ë¼ì¸ ëª¨ë“œ: ì¼ë°˜ ë‚œìˆ˜
    return Math.random();
}

socket.on('gameStart', (data) => {
    isOnlineMode = true;
    myRole = data.role;
    myRoom = data.room;
    gameSeed = data.seed; // ì„œë²„ ì‹œë“œ ì €ì¥
    
    // ğŸ² ì‹œë“œ ê¸°ë°˜ RNG ì´ˆê¸°í™”
    globalRNG = new SeededRandom(gameSeed);
    console.log(`ğŸ² RNG ì´ˆê¸°í™” ì™„ë£Œ (Seed: ${gameSeed})`);
    
	// [Fix] ì˜¨ë¼ì¸ BGM ìë™ ì¬ìƒ
    MusicEngine.play('Battle_Piano');
	
    UI.closeModal();
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display = 'none';
    document.getElementById('battle-screen').style.display = 'flex';
    document.getElementById('logs').innerHTML = '';
    Game.difficulty = 'online';
    Game.mode = 'pvp';
    Game.turnCount = 1;
    Game.isOver = false;

    if (myRole === 'player2') Game.queue = [1, 0, 3, 2, 5, 4];
    else Game.queue = [0, 1, 2, 3, 4, 5];
    Game.curr = 0;
    Game.isProcessing = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra);
    });
    const enemyIndices = data.enemyDeck;
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(enIds[i], 1, original.base, original.extra);
    });
    Game.render();

    // [ì„ /í›„ê³µ ë³´ì •] ì˜¨ë¼ì¸ ëª¨ë“œ: í›„ê³µì—ê²Œ ë°©ì–´ë§‰ ë¶€ì—¬
    if (myRole === 'player2') {
        Game.pTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.log("<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ ë³´ë„ˆìŠ¤: ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ìƒíƒœ!</span>");
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.eTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.timer = setTimeout(() => Game.turn(), 1000);
    }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    
    if (attacker) {
        // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
        if (data.mcState) {
            if (data.mcState.isMindControlling) {
                const mcTarget = allUnits.find(u => u.id === data.mcState.mcTargetId);
                Game.isMindControlling = mcTarget || null;
                Game.currentMCCasterId = data.mcState.mcCasterId || null;
            } else {
                Game.isMindControlling = null;
                Game.currentMCCasterId = null;
            }
        }
        
        // RNGëŠ” ì´ë¯¸ ë™ê¸°í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ ë¶ˆí•„ìš”
        Game.execute(attacker, target, data.skillIdx, true);
    }
});

socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)");
    
    // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬
    isOnlineMode = false;
    globalRNG = null;
    gameSeed = null;
    Game.isMindControlling = null;
    Game.currentMCCasterId = null;
});

socket.on('waiting', (msg) => {
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.innerText = "â³ " + msg;
        btn.disabled = true;
    }
});

socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.disabled = false;
        btn.innerText = "ì…ì¥í•˜ê¸° ğŸš€";
    }
});

function startOnlineGame(code) {
    AudioSys.init();
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
    }
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    socket.emit('findMatch', {
        deck: Game.selected,
        roomCode: code
    });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };
const IMAGE_DB = {
    // [ê¸°ì´ˆ ì†ì„±]
    'Fire': './fire.png',
    'Water': './water.png',
    'Tree': './tree.png',
    'Metal': './metal.png',
    'Earth': './earth.png',
    'Light': './light.png',
    'Dark': './dark.png',
    'Normal': './normal.png',

    // [ë¹› ì¡°í•©]
    'Fire-Light': './fire_light.png',    // (ì™„ë£Œ) í‘¸ë¥¸ë¶ˆ
    'Water-Light': './water_light.png', // ì¦ê¸°
    'Tree-Light': './tree_light.png',   // ìˆ²
    'Metal-Light': './metal_light.png', // ë…ê°€ìŠ¤
    'Earth-Light': './earth_light.png', // ëª¨ë˜

    // [ì–´ë‘  ì¡°í•©]
    'Fire-Dark': './fire_dark.png',     // ê²€ì€ë¶ˆ
    'Water-Dark': './water_dark.png',   // ì–¼ìŒ
    'Tree-Dark': './tree_dark.png',     // ê°€ì‹œ
    'Metal-Dark': './metal_dark.png',   // ì „ê¸°
    'Earth-Dark': './earth_dark.png',   // ë°”ìœ„

    // [ê°•í™” ì†ì„±]
    'Light-Light': './light_enhanced.png', // ì²œì‚¬/ì„±ê¸°ì‚¬
    'Dark-Dark': './dark_enhanced.png',    // ì•…ë§ˆ/ì‹¬ì—°

    // [ê¸°ë³¸ê°’] (ì´ë¯¸ì§€ê°€ ì—†ê±°ë‚˜ ì´ë¦„ì´ í‹€ë ¸ì„ ë•Œ ë‚˜ì˜¤ëŠ” ì´ë¯¸ì§€)
    'Default': 'https://via.placeholder.com/150/cccccc/ffffff?text=No+Image'
};
const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.1ë°°+40%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15', type:'CC', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë°›ëŠ” í”¼í•´ MaxHP 20% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 20%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ë¿Œë¦¬ë¬¶ê¸°', s1d:'3í„´ê°„ ì•„êµ°í”¼í•´ 40% ëŒ€ì‹ ë°›ìŒ', s2:'ì¹˜ìœ ì˜ ì', s2d:'HP+100/ì •í™”(CCí•´ì œì‹œ ë€ê°â†‘)', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', desc:'ìˆ˜í˜¸í˜• íƒ±ì»¤<br>í”¼í•´ ë¶„ì‚° + ë€ê° íŒ¨ì‹œë¸Œ', passive:'ğŸŒ³ ê±°ëª©: ë°›ëŠ” í”¼í•´ê°€ 15% ê°ì†Œí•©ë‹ˆë‹¤. S2ë¡œ í–‰ë™ë¶ˆê°€ë¥¼ í•´ì œí•˜ë©´ ë€ê°ìœ¨ì´ 5%ì”© ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 25%).'},
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(3í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 30%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ 1íšŒ ìë™ íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.5ë°° +í™”ìƒ(60%)', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(30%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ / ìœ ë¦¬ëŒ€í¬', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2R ê³µ+15, 3~6R ê³µ+10, 7R~ ê³µ+5' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'âš–ï¸', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°© (ì•½ì :ë‹¨ì¼ê¸°ì´ˆ5ì†ì„±) + ì„œë¸Œíƒ±í‚¹', passive:'ğŸ² ë©´ì—­: í–‰ë™ ì œì–´ê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ,ì„¸ë‡Œ)ì— ê±¸ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.'},
    
    // [ìˆ˜ì •] ìê°€í™”ìƒ íŒ¨ì‹œë¸Œ ì„¤ëª… ì‚­ì œ
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ(100%)', s2:'ì†Œê°', s2d:'1.0ë°°+ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€íƒ€', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì—­ì´ìš© / ê°•ë ¥í•œ ê´‘ì—­ ë„íŠ¸', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ê³µê²©ë ¥ì´ ë†’ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.35ë°°+ìê°€ê¸°ì ˆ(1í„´)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ ì‚¬ìš© í›„ 1í„´ê°„ [ë°˜ë™] ìƒíƒœê°€ ë©ë‹ˆë‹¤. ë°˜ë™ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 15 ì¦ê°€í•˜ë©°, ì´ëŠ” ì •í™”ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.4ë°°+ë²„í”„í•´ì œ+(ê¸°ì ˆ25%/ì¹¨ë¬µ20%)', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ë²„í”„ íŒŒê´´ / ê¸°ì ˆ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°+ë°ë¯¸ì§€20%ì‰´ë“œ', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²° + ìê°€ì‰´ë“œ', passive:'â„ï¸ ì–¼ìŒ ê°‘ì˜·: S1 ì‚¬ìš© ì‹œ ì…íŒ ë°ë¯¸ì§€ì˜ 20%ë§Œí¼ ì‰´ë“œë¥¼ íšë“í•©ë‹ˆë‹¤.' },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'3ë€+í”¼ê²©ëŒ€ìƒ1.0ë°°(CCê±¸ë¦° ì 1.3ë°°)', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ë…(35) ë° ì¹˜ìœ ê°ì†Œ20% 3í„´', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë‚˜ë¬´(Tree) ì¹´ìš´í„° / íë°´', passive:null },
    
    // [ìˆ˜ì •] ì†ë°• -> ëª¨ë˜ì§€ì˜¥(ì§€ì†í”¼í•´) ëª…ì‹œ
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°(ê´€í†µ)+ì‰´ë“œíƒ€ê²©0.6ë°°', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•(60) ë° ì¹˜ìœ ê°ì†Œ(50%) 2í„´', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì‰´ë“œ íŒŒê´´ì / íëŸ¬ ì–µì œ', passive:null },
    
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë³µìˆ˜(ê³„ìˆ˜ì¦ê°€)', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì˜êµ¬ ì¦ê°€.' },
    
    // [ìˆ˜ì •] 1.5ë°°->1.4ë°°, íëŸ‰ í‘œê¸° ìˆ˜ì •, íŒ¨ì‹œë¸Œ ì¶”ê°€
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.4ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´ 110 íšŒë³µ', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:'ğŸ’§ ìƒëª…ìˆ˜: ìŠ¤í‚¬ ì‚¬ìš© ì‹œ 20% í™•ë¥ ë¡œ ì²´ë ¥ì´ ê°€ì¥ ë‚®ì€ ì•„êµ°ì„ 50 ì¶”ê°€ ì¹˜ìœ í•©ë‹ˆë‹¤.' },
    
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.3ë°°+ë¹ˆì‚¬ì•„êµ° ì‰´ë“œ40', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + ë³´í˜¸ë§‰', passive:null },
    
    // [ìˆ˜ì •] ì¤‘ì²© ì‹œ íš¨ê³¼ ê°•í™” ëª…ì‹œ
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15(ì¤‘ì²©â†‘)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    
    // [ìˆ˜ì •] ê³µê¹ ìˆ˜ì¹˜ ì¡°ê±´ ëª…ì‹œ
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(í”¼í•´ëŸ‰30%ë°˜ì‚¬/CCë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.4ë°°/ê³µ20~35%â†“', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    
    // [ìˆ˜ì •] ì½”ìŠ¤íŠ¸ 20% -> 12% ìˆ˜ì •
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.8ë°°+ì¹¨ë¬µ(1í„´)', s2:'ì •ì‹ ì§€ë°°', s2d:'HP12%ì†Œëª¨/ì„¸ë‡Œ(30~55%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ§ ', desc:'ì‹¬ì—°ì˜ ì§€ë°°ì<br>ì  ì œì–´ê¶Œ íƒˆì·¨', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ì„¸ë‡Œ ì„±ê³µë¥ ì€ ê¸°ë³¸ 30%ì´ë©°, ëŒ€ìƒì˜ ì²´ë ¥ì´ ë‚®ì„ìˆ˜ë¡ ìµœëŒ€ 55%ê¹Œì§€ ì¦ê°€í•©ë‹ˆë‹¤. ì„±ê³µ ì‹œ ë‹¤ìŒ í„´ ì ì„ 1íšŒ ì¡°ì¢…í•©ë‹ˆë‹¤.' }
};

// [ì‹ ê·œ] Emotion Alias Database (English)
const EMOTION_DB = {
    'Fire': { t: 'Rage', d: 'Burning instinct of destruction' },
    'Water': { t: 'Sorrow', d: 'Cold grief that freezes the heart' },
    'Tree': { t: 'Vigor', d: 'Unstoppable life force' },
    'Metal': { t: 'Coldness', d: 'Reason without emotion' },
    'Earth': { t: 'Stoicism', d: 'Unshakable calmness' },
    'Light': { t: 'Bliss', d: 'Pure joy and light' },
    'Dark': { t: 'Terror', d: 'Fear of the unknown' },
    'Normal': { t: 'Void', d: 'Emptiness unaffected by anything' },
    
    'Fire-Light': { t: 'Passion', d: 'Rage sublimated into positivity' },
    'Fire-Dark': { t: 'Madness', d: 'Uncontrollable frenzy' },
    'Water-Light': { t: 'Compassion', d: 'Sorrow that embraces others' },
    'Water-Dark': { t: 'Misery', d: 'Solidified pain and cold' },
    'Tree-Light': { t: 'Hope', d: 'A forest embracing everyone' },
    'Tree-Dark': { t: 'Obsession', d: 'Twisted love and pain' },
    'Metal-Light': { t: 'Critique', d: 'Sharp and piercing analysis' },
    'Metal-Dark': { t: 'Thrill', d: 'Hidden stimulating excitement' },
    'Earth-Light': { t: 'Tenacity', d: 'Persistence that never lets go' },
    'Earth-Dark': { t: 'Pride', d: 'Overwhelming weight of arrogance' },
    'Light-Light': { t: 'Salvation', d: 'Liberation from suffering' },
    'Dark-Dark': { t: 'Domination', d: 'Power to control minds' }
};

// [ì‹ ê·œ] Title Manager (Unlock System)
const TitleManager = {
    unlocked: JSON.parse(localStorage.getItem('et_titles_en') || '[]'),
    unlock: function(key) {
        if (!this.unlocked.includes(key)) {
            this.unlocked.push(key);
            localStorage.setItem('et_titles_en', JSON.stringify(this.unlocked));
            return true;
        }
        return false;
    }
};

const ChallengeDB = [
    /* === [ì´ˆê¸‰] ê¸°ë³¸ ê¸°ë¯¹ í•™ìŠµ === */
    // 1. [ì…ë¬¸] íƒ±ì»¤ì˜ ê¸°ë³¸ (Metal ë“±ì¥ 1/4)
    { name: "ë¶€ë™ì˜ ì² ì˜¹ì„±", desc: "ì‡ (Metal)ê°€ ì•ì„ ë§‰ê³  ìˆìŠµë‹ˆë‹¤. ë’¤ì— ìˆ¨ì€ ë”œëŸ¬ë¶€í„° ë…¸ë¦¬ì„¸ìš”!", team: ['Metal', 'Water', 'Fire'] },

    // 2. [ìœ ì§€ë ¥] í¡í˜ˆê³¼ í
    { name: "ë¶‰ì€ ê·€ì¡±", desc: "ë•Œë ¤ì„œ íšŒë³µí•˜ëŠ” í¡í˜ˆê·€ë“¤ì…ë‹ˆë‹¤. í•œ ëª…ì”© í™•ì‹¤í•˜ê²Œ ëŠì–´ì•¼ í•©ë‹ˆë‹¤.", team: ['Fire-Light', 'Tree', 'Fire-Dark'] },

    // 3. [ì‹¬ë¦¬ì „] ë°˜ì‚¬ì™€ ë³µìˆ˜
    { name: "ë”œë ˆë§ˆì˜ ìˆ²", desc: "ì–´ë‘ (Dark)ì„ ì¹˜ë©´ ë°˜ì‚¬ë˜ê³ , ë‚˜ë¬´(Tree-Dark)ë¥¼ ë‚¨ê¸°ë©´ ê´´ë¬¼ì´ ë©ë‹ˆë‹¤.", team: ['Dark', 'Tree-Dark', 'Normal'] },

    /* === [ì¤‘ê¸‰] íŠ¹ìˆ˜ ê³µëµ í•„ìš” === */
    // 4. [íšŒí”¼] ë¬¼ë¦¬ ê³µê²© ë¬´íš¨í™”
    { name: "ì‹ ê¸°ë£¨ ì‘ì „", desc: "ì¦ê¸°(Water-Light)ëŠ” ìœ„ê¸° ì‹œ íšŒí”¼í•©ë‹ˆë‹¤. ë…ì´ë‚˜ í•œë°© ë”œì´ í•„ìš”í•©ë‹ˆë‹¤.", team: ['Water-Light', 'Fire-Dark', 'Light'] },

    // 5. [ë°©ì–´] í†µê³¡ì˜ ì¢€ë¹„ ë²½ (Metal ë“±ì¥ 2/4)
    { name: "ë¶ˆë©¸ì˜ ìš”ìƒˆ", desc: "ì£½ì§€ ì•ŠëŠ” ì¢€ë¹„ ì¡°í•©. ì‡ (Metal)ë¥¼ ëš«ì„ ê°•ë ¥í•œ í™”ë ¥ì´ í•„ìš”í•©ë‹ˆë‹¤.", team: ['Metal', 'Tree', 'Water'] },

    // 6. [ì €ê²©] íëŸ¬ ë§ë ¤ ì£½ì´ê¸°
    { name: "ëª¨ë˜ í­í’", desc: "ì¹˜ìœ  ê°ì†Œ íš¨ê³¼ë¡œ ë‹¹ì‹ ì˜ íëŸ¬ë¥¼ ë¬´ë ¥í™”ì‹œí‚µë‹ˆë‹¤.", team: ['Earth-Light', 'Metal-Light', 'Earth'] },

    /* === [ìƒê¸‰] ë©”íƒ€ ì¡°í•© (ì§€ì˜¥) === */
    // 7. [CC] ë¬´í•œ ë©”ì¦ˆ ì§€ì˜¥
    { name: "ì ˆëŒ€ ì˜ë„", desc: "ì–¼ë¦¬ê³ , ê¸°ì ˆì‹œí‚¤ê³ , ì¡°ì¢…í•©ë‹ˆë‹¤. ë‹¹ì‹ ì—ê²Œ í„´ì€ ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤.", team: ['Water-Dark', 'Metal-Dark', 'Dark-Dark'] },

    // 8. [ì½¤ë³´] ë¦¬ë¯¸íŠ¸ í•´ì œ (Metal ë“±ì¥ 3/4) - â˜… ìˆ˜ì •ë¨!
    // ì„¤ëª…: ë°”ìœ„ê°€ ë•Œë¦¬ê³ (ê¸°ì ˆ) -> ì²œì‚¬ê°€ í’€ì–´ì£¼ê³  -> ë°”ìœ„ê°€ ë˜ ë•Œë¦¼ (ë¬´í•œ ë°˜ë³µ)
    { name: "ëŒ€ì§€ì˜ ì§„ê²©", desc: "ì²œì‚¬(Light-Light)ê°€ ë°”ìœ„(Earth-Dark)ì˜ ê¸°ì ˆ íŒ¨ë„í‹°ë¥¼ ì§€ì›Œì¤ë‹ˆë‹¤. ë¬´í•œ í•µí€ì¹˜ë¥¼ ì¡°ì‹¬í•˜ì„¸ìš”.", team: ['Metal', 'Earth-Dark', 'Light-Light'] },

    // 9. [ë³€ìˆ˜] ìµœì•…ì˜ ì„œí¬íŒ…
    { name: "ì„±ì—­ì˜ ì§€ë°°ì", desc: "ë¬´í•œ ì‰´ë“œì™€ ì •í™”, ê·¸ë¦¬ê³  ì„¸ë‡Œ. ê°€ì¥ ë¶ˆì¾Œí•œ ê²½í—˜ì„ ì„ ì‚¬í•©ë‹ˆë‹¤.", team: ['Light-Light', 'Dark-Dark', 'Water-Light'] },

    // 10. [ë³´ìŠ¤] ì—”ë“œ ì»¨í…ì¸  (Metal ë“±ì¥ 4/4)
    { name: "The Apex (ì •ì )", desc: "ë„ë°œ(Metal), ì„¸ë‡Œ(Dark-Dark), ì •í™”(Light-Light). ì´ ê²Œì„ì˜ ìµœê°•ìë“¤ì…ë‹ˆë‹¤.", team: ['Metal', 'Dark-Dark', 'Light-Light'] }
];

// [Online] ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸° (ë™ê¸°í™” í•„ìˆ˜)
// Math.random() ëŒ€ì‹  ì´ê±¸ ì¨ì•¼ ë‘ í”Œë ˆì´ì–´ì˜ ê²°ê³¼ê°€ ë˜‘ê°™ìŠµë‹ˆë‹¤.
const RNG = {
    seed: 1,
    init: function(s) { 
        this.seed = s % 2147483647; 
        if (this.seed <= 0) this.seed += 2147483646; 
    },
    next: function() {
        // Park-Miller ì•Œê³ ë¦¬ì¦˜ (ê°€ë³ê³  ë¹ ë¦„)
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
    },
    // ë²”ìœ„ ëœë¤ (min ~ max)
    range: function(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
};

const Common = {
    logAction: function(game, type, source, target, value, extra='') {
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else { msg = `[${source.name.split(' ')[0]}] ${extra}`; }
        game.log(msg);
    },
    // [ê³µìœ  ë¡œì§] ë°ë¯¸ì§€ ë¶„ì‚° ì²˜ë¦¬ê¸°
    distributeDamage: function(atk, def, dmg, game, isFire, ignoreShield) {
        // 1. ë°©ì–´ìê°€ ë‚˜ë¬´ê°€ ì•„ë‹ˆê³ , ì•„êµ° ì¤‘ì— [ë¿Œë¦¬ë¬¶ê¸°(ROOT_GUARD)] ì¼œì§„ ë‚˜ë¬´ê°€ ìˆëŠ”ì§€ í™•ì¸
        const allies = def.team === 0 ? game.pTeam : game.eTeam;
        const protector = allies.find(u => u.id !== def.id && !u.isDead && u.base === 'Tree' && u.hasStatus('ROOT_GUARD'));

        // 2. ë³´í˜¸ìê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ëŒ€ë¡œ ë‹¨ì¼ í”¼ê²©
        if (!protector) {
            const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
            return { targetAct: act, split: false };
        }

        // 3. ë°ë¯¸ì§€ ë¶„ì‚° (ë‚˜ë¬´ 40% : ë³´í˜¸ëŒ€ìƒ 60%)
        // [Fix] ì†Œìˆ˜ì  ë²„ë¦¼ìœ¼ë¡œ ì¸í•œ 0 ë°ë¯¸ì§€ ë°©ì§€ (ìµœì†Œ 1 ë³´ì¥ ë¡œì§ì€ ì œì™¸í•˜ë˜ ê³„ì‚° ëª…í™•í™”)
        const shareDmg = Math.floor(dmg * 0.4); 
        const originalDmg = dmg - shareDmg;

        // [ì´í™íŠ¸] ì—°ê²°ì„  í‘œí˜„
        if (!game.isProcessing) {
            UI.fireProjectile(protector, def, 'ğŸŒ¿'); 
        }

        // 4. ë°ë¯¸ì§€ ì ìš©
        const act1 = def.takeDamage(originalDmg, isFire, ignoreShield, atk);
        const act2 = protector.takeDamage(shareDmg, isFire, ignoreShield, atk);

        // 5. ë¡œê·¸ ì¶œë ¥
        game.log(`<span class="log-sys" style="color:#66bb6a;">ğŸ›¡ï¸ [${protector.name}] í”¼í•´ ë¶„ë‹´! <b style="color:#ff7043;">(-${act2})</b></span>`);
        UI.floatText(protector, `-${act2} (ëŒ€ì‹ ë§ê¸°)`, "ft-dmg");

        return { targetAct: act1, split: true };
    },

    basicAttack: function(atk, def, game) {
        // 1. ì†Œë¦¬ëŠ” ê³µê²© ì‹œë„ ì‹œ ë°”ë¡œ ì¬ìƒ (ì·¨í–¥ì— ë”°ë¼ ì‹¤ëª…ì¼ ë•Œ ëŒ ìˆ˜ë„ ìˆìŒ)
        AudioSys.play('HIT');

        // 2. ì‹¤ëª…(BLIND) ì²´í¬ ë¡œì§ (ê¸°ì¡´ ì½”ë“œ ë³µêµ¬)
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { 
            Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)");
            UI.floatText(atk, "BLINDED", "ft-miss"); 
            return; // ì‹¤ëª…ì´ë©´ ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ (ë°ë¯¸ì§€ X, ì´í™íŠ¸ X)
        }

        // 3. ì‹¤ëª…ì´ ì•„ë‹ ë•Œë§Œ ê³µê²© ë¡œê·¸ ë° ì´í™íŠ¸ ì¶œë ¥
        game.log(`<b>[${atk.name}]</b> ê³µê²©! âš”ï¸`);
        
        // [ì´í™íŠ¸] ê³µê²© ì„±ê³µ ì‹œì—ë§Œ ìƒ¥! (ì‹¤ëª…ì¼ ë• ì•ˆ ë‚˜ì˜´)
        UI.playVFX(def, 'slash'); 

        // 4. ë°ë¯¸ì§€ ê³„ì‚°
        const act = Common.applyDamage(atk, def, 1.0, game);
        if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
    },

    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { 
            UI.floatText(atk, "BLINDED", "ft-miss");
            Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); 
            return -1; 
        }
        
        const baseAtk = atk.getAtk();
        const applyAffinity = (def.team !== atk.team) || (game.isMindControlling);
        const aff = applyAffinity ? game.calc(atk, def) : {v:1, t:''};

        // [ìˆ˜ì •] ìµœì¢… ë°ë¯¸ì§€ ì‚°ì¶œ
        const rawDmg = Math.floor(baseAtk * mult * aff.v);
        
        // [ìˆ˜ì •] ë¶„ì‚° ë¡œì§ í˜¸ì¶œ
        const res = Common.distributeDamage(atk, def, rawDmg, game, isFire, ignoreShield);
        const act = res.targetAct;

        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) { 
            let type = act>=200 ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type); 
            game.shake(def); 

            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.30));
                if(healAmt > 0) { 
                    atk.heal(healAmt);
                    const buff = atk.status.find(s => s.type === 'LIFESTEAL_BUFF');
                    if (buff && buff.sourceId !== -1 && buff.sourceId !== atk.id) {
                        const allUnits = [...game.pTeam, ...game.eTeam];
                        const provider = allUnits.find(u => u.id === buff.sourceId);
                        if(provider) game.recordStat(provider, 'heal', healAmt);
                    } else {
                        Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)");
                    }
                }
            }
        } else { 
            Common.logAction(game, 'miss', atk, def, 0);
            UI.floatText(def, "MISS", "ft-miss"); 
        }
        return act;
    },
    // [ìˆ˜ì •] ì„¸ë‡Œ ìƒíƒœì¼ ë•Œ í”¼ì•„ì‹ë³„ ë°˜ì „ ë¡œì§ (ê´‘ì—­ê¸° ë²„ê·¸ ìˆ˜ì •)
    forEachAlly: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì ì´ ë‚´ ì•„êµ°
        }
        const team = effectiveTeam === 0 ? game.pTeam : game.eTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    },
    forEachEnemy: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì›ë˜ ì•„êµ°ì´ ì 
        }
        const team = effectiveTeam === 0 ? game.eTeam : game.pTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    }
};

const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                UI.playVFX(def, 'fire'); // [ì´í™íŠ¸] ë¶ˆê½ƒ ë°œì‚¬
                
                // [Balance] í™”ìƒ í™•ë¥  60% ìœ ì§€, ê³„ìˆ˜ 1.5ë¡œ ë„ˆí”„
                const act = Common.applyDamage(atk, def, 1.5, game, false, true);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.60) def.addStatus('BURN', 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                // [ì´í™íŠ¸] ì  ì „ì²´ í­ë°œ
                Common.forEachEnemy(atk, game, (e) => UI.playVFX(e, 'fire'));

                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if (act !== -1) {
                         Common.logAction(game, 'dmg', atk, e, act, "");
                         if (game.netRandom() < 0.30) e.addStatus('BURN', 2, 0, atk);
                    }
                });
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                // [Balance] 1.5ë°° -> 1.4ë°° ë„ˆí”„
                const act = Common.applyDamage(atk, def, 1.4, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    // [Fix] ê¸°ë³¸ íëŸ‰ 110ìœ¼ë¡œ ìƒí–¥
                    const h = a.heal(110);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
            }

            // [New Passive] S1, S2 ì‚¬ìš© ì‹œ 20% í™•ë¥ ë¡œ ìµœì € ì²´ë ¥ ì•„êµ° ì¹˜ìœ 
            if (sIdx > 0 && game.netRandom() < 0.20) {
                const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                // ì²´ë ¥ì´ ê°€ì¥ ë‚®ì€(ì ˆëŒ€ê°’ ê¸°ì¤€) ì•„êµ° ì°¾ê¸°
                const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                if (target) {
                    const h = target.heal(50);
                    game.recordStat(atk, 'heal', h);
                    UI.floatText(target, "+50(P)", "ft-heal");
                    game.log(`<span class='log-sys'>ğŸ’§ [íŒ¨ì‹œë¸Œ] ${target.name} ì¶”ê°€ ì¹˜ìœ  (+${h})</span>`);
                }
            }
            
            if (sIdx === 2) return false; // S2ëŠ” ê³µê²©ì´ ì•„ë‹ˆë¯€ë¡œ íˆ¬ì‚¬ì²´ ì†Œë¦¬ ë°©ì§€
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                // S1: ë¿Œë¦¬ ë¬¶ê¸° (ìì‹ ì—ê²Œ ìˆ˜í˜¸ ë²„í”„)
                game.log(`<b>[${atk.name}]</b> ë¿Œë¦¬ ë¬¶ê¸° ğŸªµ`);
                AudioSys.play('POWER_UP');
                
                // ROOT_GUARD: ì•„êµ° í”¼í•´ 50% ëŒ€ì‹  ë°›ìŒ
                atk.addStatus('ROOT_GUARD', 3, 0, atk);
                UI.floatText(atk, "ìˆ˜í˜¸íƒœì„¸", "ft-heal");
                Common.logAction(game, 'buff', atk, atk, 0, "(3í„´ê°„ í”¼í•´ë¶„ì‚°)");
                return false;
            } else {
                // S2: ì¹˜ìœ ì˜ ì (í 140 + ì¡°ê±´ë¶€ íŒ¨ì‹œë¸Œ ê°•í™”)
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                
                // 1. í ì‹¤í–‰ [Balance] 140 -> 100 ë„ˆí”„
                const h = def.heal(100);
                
                // 2. í–‰ë™ë¶ˆê°€ CC ì²´í¬ (ê¸°ì ˆ, ë¹™ê²°, ìˆ˜ë©´ ë“±)
                // (ì¼ë°˜ ë””ë²„í”„ì¸ ì¹¨ë¬µ, ì†ë°• ë“±ì€ ì œì™¸í•˜ê³  ì™„ë²½í•œ í–‰ë™ë¶ˆê°€ë§Œ ì¹´ìš´íŠ¸í•˜ì—¬ ë°¸ëŸ°ìŠ¤ ì¡°ì ˆ)
                const hardCC = ['STUN', 'FREEZE', 'SLEEP', 'BANISH'];
                const hasHardCC = def.status.some(s => hardCC.includes(s.type));
                
                // 3. ì •í™”
                def.cleanse();
                
                // 4. CC í•´ì œ ì„±ê³µ ì‹œ íŒ¨ì‹œë¸Œ ê°•í™” (ìµœëŒ€ 2ìŠ¤íƒ = +10%)
                let extraMsg = "(ì •í™”)";
                if (hasHardCC) {
                    if (atk.treeStack < 2) {
                        atk.treeStack++;
                        UI.floatText(atk, "ê±°ëª©ì„±ì¥!", "ft-crit");
                        extraMsg += " + ğŸ›¡ï¸ì„±ì¥";
                    } else {
                        UI.floatText(atk, "MAX", "ft-miss");
                    }
                }

                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, extraMsg);
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                // [Fix] ë”œ 1.1ë°°ë¡œ í•˜í–¥
                const act = Common.applyDamage(atk, def, 1.1, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Fix] ì‰´ë“œ í¡ìˆ˜ëŸ‰ 40%ë¡œ ìƒí–¥
                    const absorb = Math.floor(act * 0.40);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸª¨`);
                
                // [Balance] ë²„í”„ 1ê°œ íŒŒê´´ (ëŒë¡œ ê¹¨ë¶€ìˆ˜ê¸°)
                let dispelled = false;
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) { def.s2Count--; dispelled = true; }
                else if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) { def.elecStacks--; dispelled = true; }
                else if (def.getKey() === 'Tree' && def.treeStack > 0) { def.treeStack--; dispelled = true; }
                if (!dispelled) {
                    const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT', 'DMG_RED', 'GROWTH', 'LIFESTEAL_BUFF', 'ROOT_GUARD', 'START_IMMUNITY'];
                    const idx = def.status.findIndex(s => buffs.includes(s.type));
                    if (idx !== -1) {
                        def.status.splice(idx, 1);
                        UI.floatText(def, "íŒŒê´´", "ft-miss");
                        dispelled = true;
                    }
                }
                if(dispelled) game.log(" (ğŸ’¥ ë²„í”„ íŒŒê´´!)");

                // [Balance] 1.4ë°° ë°ë¯¸ì§€
                const act = Common.applyDamage(atk, def, 1.4, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if (game.netRandom() < 0.25) def.addStatus('STUN', 1, 0, atk);
                    else if (game.netRandom() < 0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u => !u.isDead).length;
                const eAlive = game.eTeam.filter(u => !u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, mult, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 70;
                    const existing = a.status.find(s => s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    a.addStatus('LIGHT_MIGHT', 2, nextVal);
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    // [Balance] 0.3ë°° -> 0.4ë°° ìƒí–¥
                    const act = Common.applyDamage(atk, e, 0.4, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s => s.type === 'ATK_DOWN');
                        e.status = e.status.filter(s => s.type !== 'ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear ? 35 : 20, atk);
                        if (e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                if (atk.hp > 30) {
                    atk.hp -= 30;
                    UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                    if (target) {
                        target.shield += 60;
                        game.recordStat(atk, 'shield', 60);
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í¡í˜ˆ ë¶€ì—¬ ğŸ©¸`);
                Common.forEachAlly(atk, game, (a) => {
                    // [Fix] ë²„í”„ ì´ë¦„ í†µì¼ (VAMP -> LIFESTEAL_BUFF)
                    a.addStatus('LIFESTEAL_BUFF', 3, 0, atk);
                });
            } else {
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                Common.forEachAlly(atk, game, (a) => a.addStatus('ATK_BUFF_SMALL', 1));
                return false;
            }
        }
    },
    'Water-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.3) {
                        def.addStatus('BLIND', 1, 0, atk);
                        game.log(" (ì‹¤ëª…!)");
                    }
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ ğŸŒ«ï¸`);
                AudioSys.play('HEAL');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt);
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id !== atk.id) a.addStatus('EVADE', 2);
                });
                return false;
            }
        }
    },
    'Tree-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Balance] ìµœì € ì²´ë ¥ ì•„êµ°ì—ê²Œ ì‰´ë“œ 40 ë¶€ì—¬
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => (a.hp/a.maxHp) - (b.hp/b.maxHp))[0];
                    if (target) {
                        target.shield += 40;
                        game.recordStat(atk, 'shield', 40);
                        UI.floatText(target, "+40ğŸ›¡ï¸", "ft-heal");
                        Common.logAction(game, 'shield', atk, target, 40, "(ë³´í˜¸)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.cleanse();
                    const h = a.heal(70);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // [S1] ê°€ìŠ¤íƒ„ (ë‚˜ë¬´ ì €ê²© + í­ë°œ)
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                
                // 1. ë‚˜ë¬´(Tree) ë³´í˜¸ì í™•ì¸
                const allies = def.team === 0 ? game.pTeam : game.eTeam;
                const protector = allies.find(u => u.id !== def.id && !u.isDead && u.base === 'Tree' && u.hasStatus('ROOT_GUARD'));
                
                // 2. ì´ˆê¸° 3 ë°ë¯¸ì§€ (ê³µìš© ë¶„ì‚° ë¡œì§ ì‚¬ìš©!)
                // ì´ë ‡ê²Œ í•´ì•¼ ë‚˜ë¬´ê°€ ë¼ì–´ë“¤ì–´ ë°ë¯¸ì§€ë¥¼ ë‚˜ëˆ  ê°–ê³ , ë¡œê·¸ë„ ì •ìƒ ì¶œë ¥ë©ë‹ˆë‹¤.
                Common.distributeDamage(atk, def, 3, game, false, true); 
                
                // 3. í­ë°œ ëŒ€ìƒ ì„ ì • (ë³¸ì²´ + ë³´í˜¸ì)
                // ë³´í˜¸ìê°€ ìˆë‹¤ë©´ ë¬´ì¡°ê±´ ê°€ìŠ¤ ì „ì´ ëŒ€ìƒìœ¼ë¡œ í¬í•¨
                let targets = [def];
                if (protector) {
                    targets.push(protector);
                    game.log(`<span class="log-crit">â˜£ï¸ [${protector.name}] ê°€ìŠ¤ ì „ì´!</span>`);
                }

                // 4. ì—°ì‡„ í­ë°œ (ì¦‰ì‹œ ì‹¤í–‰ - ì˜¤ë¥˜ ë°©ì§€)
                targets.forEach((t) => {
                    if (t.isDead) return;

                    const isCC = t.hasStatus('STUN') || t.hasStatus('FREEZE') || t.hasStatus('SLEEP');
                    const mult = isCC ? 1.3 : 1.0;
                    
                    // ì‹œê° íš¨ê³¼ (ì¦‰ì‹œ ì¬ìƒ)
                    UI.playVFX(t, 'magic');
                    
                    // ë°ë¯¸ì§€ ì ìš©
                    const act = Common.applyDamage(atk, t, mult, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, t, act, isCC ? "(CCì¶”ê°€íƒ€)" : "(ê°€ìŠ¤í­ë°œ)");
                    }
                });
            } else { // [S2] ë§¹ë… ì‚´í¬
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    e.addStatus('POISON', 3, 0, atk);
                    // [Balance] í íš¨ìœ¨ 20% ê°ì†Œ
                    e.addStatus('HEAL_DOWN', 3, 20, atk); 
                });
                game.log("<span class='log-sys'>(ì „ì²´ ì¤‘ë… + ì¹˜ìœ íš¨ìœ¨ 20% ê°ì†Œ)</span>");
            }
        }
    },
    'Earth-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                // 1. ì²´ë ¥ ì§ì ‘ íƒ€ê²© (ì‰´ë“œ ë¬´ì‹œ 1.3ë°°)
                const hpAct = Common.applyDamage(atk, def, 1.3, game, true);
                
                if (hpAct !== -1) { // ëª…ì¤‘í–ˆì„ ë•Œë§Œ ì‹¤í–‰
                    Common.logAction(game, 'dmg', atk, def, hpAct, "(ì‰´ë“œë¬´ì‹œ)");
                    
                    // 2. ì‰´ë“œ ì¶”ê°€ íƒ€ê²© (0.6ë°°)
                    if (def.shield > 0) {
                        const aff = game.calc(atk, def);
                        const shieldDmg = Math.floor(atk.getAtk() * 0.6 * aff.v);
                        def.shield = Math.max(0, def.shield - shieldDmg); // ì•ˆì „í•œ ì°¨ê° (HPë¡œ ì•ˆ ë„˜ì–´ê°)
                        UI.floatText(def, `-${shieldDmg}ğŸ›¡ï¸`, "ft-dmg");
                        game.log(`<span class='log-ally'>[ì¶”ê°€íƒ€]</span> ì‰´ë“œ íŒŒê´´ : -${shieldDmg}`);
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                // ì†ë°•(TRAP) ë¶€ì—¬
                def.addStatus('TRAP', 2, 60, atk); // ë°ë¯¸ì§€ 60 ëª…ì‹œ
                
                // [Fix] ì¹˜ìœ  ê°ì†Œ 50% ë¶€ì—¬ (ì •í™”ë˜ì§€ ì•ŠìŒ)
                def.addStatus('HEAL_DOWN', 2, 50, atk); 
                game.log("<span class='log-sys'>(ì¹˜ìœ íš¨ìœ¨ 50% ê°ì†Œ)</span>");
            }
        }
    },
    'Water-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    // [Balance] ì…íŒ í”¼í•´ì˜ 20% ì‰´ë“œ íšë“ (íŒ¨ì‹œë¸Œ)
                    const shieldAmt = Math.floor(act * 0.2);
                    if (shieldAmt > 0) {
                        atk.shield += shieldAmt;
                        game.recordStat(atk, 'shield', shieldAmt);
                        UI.floatText(atk, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                // [Balance] íŒ¨ì‹œë¸Œ(ìê°€ í™”ìƒ) ì‚­ì œë¨
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => e.addStatus('BURN', 2, 0, atk));
                }
            } else {
                // [Balance] íŒ¨ì‹œë¸Œ(ìê°€ í™”ìƒ) ì‚­ì œë¨
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    // [Balance] ì  ê³µê²©ë ¥ë§Œí¼ ì¶”ê°€ ë°ë¯¸ì§€
                    const extra = def.getAtk();
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act + extra, "(ê³µê²©ë ¥ë¹„ë¡€)");
                } else {
                    Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (atk.elecStacks < 3) {
                        atk.elecStacks++;
                        atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                UI.playVFX(def, 'rock'); // [ì´í™íŠ¸] ëŒë©ì´ ì¿µ
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                UI.playVFX(def, 'rock'); // [ì´í™íŠ¸] ê°•ë ¥í•œ ë°”ìœ„
                
                // 2.35ë°° ë°ë¯¸ì§€ + ë°˜ë™ ë¡œì§ ìœ ì§€
                const act = Common.applyDamage(atk, def, 2.35, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                
                if (atk.hasStatus('IMMUNITY')) {
                    atk.status = atk.status.filter(s => s.type !== 'IMMUNITY');
                    UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss");
                }

                // ê¸°ì ˆ ë¶€ì—¬
                const ex = atk.status.find(s => s.type === 'STUN');
                if (ex) ex.turn = 2;
                else atk.status.push({ type: 'STUN', turn: 2, val: 0 });

                // ë°˜ë™ ë¶€ì—¬ (ë°›ëŠ” í”¼í•´ 15 ì¦ê°€)
                const recoil = atk.status.find(s => s.type === 'EARTH_RECOIL');
                if (recoil) recoil.turn = 2;
                else atk.status.push({ type: 'EARTH_RECOIL', turn: 2, val: 15 });

                UI.floatText(atk, "ğŸ’¤íœ´ì‹+ë°˜ë™", "ft-miss");
                game.log("(ë°˜ë™: ê¸°ì ˆ + ë°›ëŠ”ë°ë¯¸ì§€ ì¦ê°€)");
            }
        }
    },
    'Light-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 50;
                    a.cleanse();
                    game.recordStat(atk, 'shield', 50);
                    Common.logAction(game, 'shield', atk, a, 50, "(ì •í™”)");
                });
                return false;
            }
        }
    },
'Dark-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`);
                const act = Common.applyDamage(atk, def, 0.8, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                // ì„¸ë‡Œ ìŠ¤í‚¬
                game.log(`<b>[${atk.name}]</b> ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ ğŸ§ `);
        
                // [ì œì•½ 1] ì´ë¯¸ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
                if (game.isMindControlling) {
                    game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                    UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                    return;
                }
                
                // [ì œì•½ 2] ë©´ì—­ ì²´í¬
                if (def.getKey() === 'Dark-Dark' || def.hasStatus('IMMUNITY') || (def.isNormal && !def.extra)) {
                    game.log("<span class='log-sys'>ğŸš« ì •ì‹  ì§€ë°°ê°€ í†µí•˜ì§€ ì•ŠëŠ” ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                    UI.floatText(def, "ë©´ì—­", "ft-miss");
                    return;
                }

                // 1. ì½”ìŠ¤íŠ¸ ì§€ë¶ˆ
                const cost = Math.floor(atk.hp * 0.12);
                atk.hp = Math.max(1, atk.hp - cost);
                UI.floatText(atk, `HPì†Œëª¨(-${cost})`, "ft-miss");
                
                // 2. í™•ë¥  ê³„ì‚°
                const missingPct = 1.0 - (def.hp / def.maxHp);
                let chance = 0.30 + (missingPct * 0.25);
                
                // ğŸŸ¢ [ìˆ˜ì •ë¨] ì±Œë¦°ì§€ ëª¨ë“œ + 'ì êµ°(Team 1)'ì¼ ë•Œë§Œ 90% ì ìš©
                if (game.mode === 'challenge' && atk.team === 1) {
                    chance = 0.90;
                    game.log("<span class='log-sys' style='color:#ff5252;'>âš ï¸ [BOSS] ì ì˜ ì •ì‹ ì§€ë°° í™•ë¥ ì´ ëŒ€í­ ìƒìŠ¹í•©ë‹ˆë‹¤! (90%)</span>");
                }

                // 3. ì„±ê³µ/ì‹¤íŒ¨ íŒì •
                if (game.netRandom() < chance) {
                    def.addStatus('MC_WAIT', 1, 0, atk, true); 
                    game.log(` ğŸŒ€ <b>[${def.name}]</b> ì •ì‹  ì§€ë°° ì‹œì‘! (1í„´ í›„ ìŠ¤í‚µ, ê·¸ ë‹¤ìŒ ì¡°ì¢…)`);
                    UI.floatText(def, "ì„¸ë‡Œ ëŒ€ê¸°", "ft-crit");
                    AudioSys.play('DEBUFF');
                } else {
                    game.log(" (ì •ì‹ ë ¥ìœ¼ë¡œ ì €í•­í–ˆìŠµë‹ˆë‹¤!)");
                    UI.floatText(def, "ì €í•­", "ft-miss");
                }
            }
        }
    }
}; // SKILL_LOGIC ë

class Unit {
    constructor(id, team, base, extra) {
        this.id = id;
        this.team = team;
        this.base = base;
        this.extra = extra;
        // [Balance] ê¸°ë³¸ ì²´ë ¥ +100 ìƒí–¥ (ì „íˆ¬ í˜¸í¡ ì¡°ì ˆ)
        this.maxHp = 700;
        // ê°€ì‹œ(Tree-Dark)ëŠ” íƒ±ì»¤í˜• ë”œëŸ¬ë¼ ë” ë†’ê²Œ ìœ ì§€ (+100 ì°¨ì´)
        if (base === 'Tree' && extra === 'Dark') this.maxHp = 800;
        // í‘¸ë¥¸ë¶ˆ(Fire-Light)ì€ ì„œë¸Œ íƒ±ì»¤ë¼ ì•½ê°„ ë†’ê²Œ ìœ ì§€ (+50 ì°¨ì´)
        if (base === 'Fire' && extra === 'Light') this.maxHp = 750;
        // [Balance] ë¶ˆ(Fire) ê¸°ë³¸ ì²´ë ¥ 50 ë„ˆí”„ (ìœ ë¦¬ëŒ€í¬ í™”)
        if (base === 'Fire' && !extra) this.maxHp = 650;
        this.hp = this.maxHp;
        this.evadeTriggered = false;
        this.revengeAtk = 0;
        this.shield = (base === 'Metal' && !extra) ? 100 : 0;

        if (this.team === 1 && typeof Game !== 'undefined' && Game.difficulty === 'hell') {
            this.atk = 70;
        } else {
            this.atk = 55 + (id * 7 % 15);
        }

        this.status = [];
        this.isDead = false;
        this.thornStack = 0;
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.growthStack = 0;
        this.treeStack = 0; // [Tree] íŒ¨ì‹œë¸Œ ìŠ¤íƒ (0~2)
        this.resist = 0;
        this.stats = {
            dmg: 0,
            heal: 0,
            shieldGiven: 0,
            taken: 0,
            kills: 0
        };
        this.isSuper = false;
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base === 'Light' && this.extra === 'Dark') || (this.base === 'Dark' && this.extra === 'Light');
        this.isEnhanced = (this.base === this.extra && (this.base === 'Light' || this.base === 'Dark'));

        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() {
        if (this.isNormal) return 'Normal';
        if (this.isEnhanced) return `${this.base}-${this.extra}`;
        return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base;
    }

    checkAwakening() {
        // [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ëª¨ë“œì—ì„œëŠ” ê°ì„± ë°œë™ ê¸ˆì§€ (ë„ê° ì˜¤ì—¼ ë°©ì§€)
        if (typeof Game !== 'undefined' && Game.difficulty === 'tutorial') return;

        if (this.isSuper) return;
        let trigger = false;
        // [Balance] ì‰´ë“œ ìµœëŒ€ëŸ‰ 400ìœ¼ë¡œ ì œí•œ
        if (this.shield > 400) this.shield = 400;

        if (this.isSuper) return;
        const key = this.getKey();
        const role = SKILL_DB[key].role;
        let awakened = false;
        if (role === 'nuker') {
            if (this.stats.kills >= 2 || this.stats.dmg >= 1500) awakened = true;
        } else if (role === 'tank') {
            if (this.stats.taken >= 1000) awakened = true;
        } else if (role === 'supp') {
            if ((this.stats.heal + this.stats.shieldGiven) >= 1000) awakened = true;
        }
if (awakened) {
            this.isSuper = true;
            
            // [Modified] Emotion Awakening Logic
            const emo = EMOTION_DB[key];
            if (emo) {
                const isNew = TitleManager.unlock(key);
                const titleText = `[${emo.t}] Awakened!`;
                UI.floatText(this, titleText, "ft-crit");
                
                if (isNew) {
                    setTimeout(() => {
                        Game.log(`<span class="log-crit" style="color:#d500f9;">ğŸ† New Title Unlocked: [${emo.t}]</span>`);
                        // ì•Œë¦¼ ë©”ì‹œì§€ëŠ” í•œ ë²ˆë§Œ
                        const bubble = document.createElement('div');
                        bubble.style.cssText = "position:fixed; top:20%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.8); color:#fff; padding:15px 25px; border-radius:30px; z-index:9999; font-size:18px; box-shadow:0 5px 15px rgba(0,0,0,0.3); animation:floatUp 2s forwards;";
                        bubble.innerHTML = `ğŸ’ New Emotion: <b>${emo.t}</b><br><span style='font-size:12px; color:#aaa;'>${emo.d}</span>`;
                        document.body.appendChild(bubble);
                        setTimeout(() => bubble.remove(), 2500);
                    }, 500);
                }
            } else {
                UI.floatText(this, "âš¡AWAKENING!!âš¡", "ft-crit");
            }

            AudioSys.play('AWAKEN');
            Game.render();
        }
    }

    getAtk() {
        let v = this.atk;
        if (this.base === 'Fire' && !this.extra) {
            // [ìˆ˜ì •] í„´(í–‰ë™ìˆ˜) ëŒ€ì‹  ë¼ìš´ë“œ(ì‚¬ì´í´) ê¸°ì¤€ ì ìš©
            const r = (typeof Game !== 'undefined' && Game.globalRound) ? Game.globalRound : 1;
            
            if (r <= 2) v += 15;      // 1~2ë¼ìš´ë“œ (ì´ˆë°˜)
            else if (r <= 6) v += 10; // 3~6ë¼ìš´ë“œ (ì¤‘ë°˜)
            else v += 5;              // 7ë¼ìš´ë“œ ì´í›„ (í›„ë°˜)
        }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        const lightMight = this.status.find(s => s.type === 'LIGHT_MIGHT');
        if (lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        if (this.hasStatus('ATK_BUFF_SMALL')) v += 10;

        // [ì‹ ê·œ] ë°ë¯¸ì§€ 10% ì¦ê°€ ë²„í”„ ì ìš© (ìµœì¢… ê³±ì—°ì‚°)
        if (this.hasStatus('DMG_UP_10')) v = Math.floor(v * 1.1);
        
        v = Math.max(10, v);
        const ads = this.status.filter(s => s.type === 'ATK_DOWN');
        if (ads.length > 0) {
            ads.forEach(s => {
                if (s.val > 0) v -= Math.floor(v * (s.val / 100));
                else v -= 15;
            });
        }
        return Math.max(0, v);
    }

    resetTurn() {
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
    }

    takeDamage(dmg, isFire = false, ignoreShield = false, source = null) {
        // [Tree íŒ¨ì‹œë¸Œ] ê±°ëª©: ê¸°ë³¸ 15% ë€ê° + ìŠ¤íƒë‹¹ 5% (ìµœëŒ€ 25%)
        if (this.base === 'Tree') {
            const reducePct = 0.15 + (this.treeStack * 0.05);
            dmg = Math.floor(dmg * (1.0 - reducePct));
        }

        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);

        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            // [Balance] íŒ¨ì‹œë¸Œ ë°œë™ ì¡°ê±´ ì™„í™” (MaxHP 30% -> 20%)
            const cap = Math.floor(this.maxHp * 0.20);
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal");
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) {
            if (Game.netRandom() < 0.40) {
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                this.status = this.status.filter(s => s.type !== 'EVADE');
                return -1;
            }
        }
        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            if (karma && !isDarkVsDark) {
                const reflectDmg = Math.floor(dmg * 0.3);
                if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null);
                    this.stats.dmg += actualReflect;
                    UI.floatText(source, reflectDmg, "ft-crit");
                }
            }
        }

        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) {
            if (this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg;
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield;
                this.shield = 0;
            }
        } else {
            hpDmg = dmg;
        }
        if (hpDmg > 0 && this.hasStatus('EARTH_RECOIL')) {
            hpDmg += 15;
            this.stats.taken += 15;
            UI.floatText(this, "Crack(+15)", "ft-crit");
        }
        this.hp = Math.max(0, this.hp - hpDmg);

        if (this.hp <= 0 && source) {
            source.stats.kills = (source.stats.kills || 0) + 1;
            if (source.isSuper && !source.isDead) {
                const allies = source.team === 0 ? Game.pTeam : Game.eTeam;
                const aliveAllies = allies.filter(a => !a.isDead);
                if (aliveAllies.length === 1 && aliveAllies[0].id === source.id) {
                    UI.showCutIn(source);
                }
            }
            if (source.checkAwakening) source.checkAwakening();
        }

        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.evadeTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        this.checkAwakening();

        // [Fix] HPê°€ 0 ì´í•˜ë©´ ì¦‰ì‹œ ì‚¬ë§ ì²˜ë¦¬ (ë°˜ì‚¬ ë°ë¯¸ì§€ ì¢€ë¹„í™” ë°©ì§€)
        if (this.hp <= 0 && !this.isDead) {
            if (typeof Game !== 'undefined' && Game.die) {
                Game.die(this);
            }
        }

        return hpDmg + shieldDmg;
    }

    addStatus(type, turn, val = 0, source = null, force = false) {
        const CC_LIST = ['STUN', 'FREEZE', 'BANISH', 'SILENCE', 'SLEEP'];
        
        // 1. ì„ ê³µ ë°©ì–´ë§‰ ì²´í¬
        if (this.hasStatus('START_IMMUNITY') && !force) {
            if (CC_LIST.includes(type) || type.startsWith('PROVOKED')) { 
                UI.floatText(this, "ğŸ›¡ï¸CCë°©ì–´", "ft-miss");
                return;
            }
        }

        // 2. ì—…ë³´(Karma) ë°˜ì‚¬ ì²´í¬
        if (source && source.id !== this.id && !force) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            const isPuppet = (this.hasStatus('MC_READY') || (Game.isMindControlling && Game.isMindControlling.id === this.id));
            
            if (karma && !isDarkVsDark && !isPuppet) {
                if (Game.netRandom() < 0.5) {
                    UI.floatText(this, "ë°˜ì‚¬!", "ft-crit");
                    Game.log(`<span class='log-crit'>ğŸ‘ï¸ [${this.name}]ì˜ ì—…ë³´ ë°œë™! [${source.name}]ì—ê²Œ ${type} ë°˜ì‚¬</span>`);
                    source.addStatus(type, turn, val, null, true);
                    return;
                }
            }
        }

        // 3. ë…¸ë§ ë©´ì—­ ì²´í¬
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE'];
        if (this.isNormal && !force && NORMAL_IMMUNE.includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }

        // ğŸ”¥ 4. ì¤‘ì²© ê°€ëŠ¥ ìƒíƒœì´ìƒ(ê³µê²©/ì¹˜ìœ  ê°ì†Œ) ìµœìš°ì„  ì²˜ë¦¬
        if (type === 'ATK_DOWN' || type === 'HEAL_DOWN') {
            const s = this.status.filter(s => s.type === type);
            if (s.length < 2) {
                this.status.push({ type, turn, val, sourceId: source ? source.id : -1 });
            } else {
                const shortest = s.sort((a, b) => a.turn - b.turn)[0];
                shortest.turn = turn;
                shortest.val = val; 
                if (source) shortest.sourceId = source.id;
            }
            return;
        }

        // 5. ê·¸ ì™¸ ì¼ë°˜ ìƒíƒœì´ìƒ (ì¤‘ë³µ ì‹œ ë®ì–´ì“°ê¸°/ê°±ì‹ )
        const existing = this.status.find(s => s.type === type);
        if (existing && !force) {
            if (turn > existing.turn) {
                existing.turn = turn;
                existing.val = val;
                existing.sourceId = source?.id;
            }
            return;
        }
        
        // 6. ìƒí˜¸ ë°°íƒ€ì  ìƒíƒœì´ìƒ ì œê±°
        const MUTUALLY_EXCLUSIVE = {
            'STUN': ['FREEZE', 'BANISH', 'SLEEP'],
            'FREEZE': ['STUN', 'BANISH', 'SLEEP'],
            'BANISH': ['STUN', 'FREEZE', 'SLEEP'],
            'SLEEP': ['STUN', 'FREEZE', 'BANISH']
        };
        
        if (MUTUALLY_EXCLUSIVE[type]) {
            const removed = [];
            MUTUALLY_EXCLUSIVE[type].forEach(conflictType => {
                const conflict = this.status.find(s => s.type === conflictType);
                if (conflict) {
                    removed.push(conflictType);
                    this.status = this.status.filter(s => s.type !== conflictType);
                }
            });
            if (removed.length > 0) {
                Game.log(`<span class='log-sys'>[${this.name}] ${removed.join(', ')} ìƒíƒœê°€ ${type}ìœ¼ë¡œ ëŒ€ì²´ë¨</span>`);
            }
        }
        
        // 7. íšŒí”¼ ì²´í¬
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return;
                }
            }
        }

        // 8. ë„ë°œ ë° ê¸°íƒ€ ë©´ì—­
        if (this.isNormal && !force && type.startsWith('PROVOKED')) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY') && !force) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            if (!source || source.id !== this.id || force) {
                this.status.push({
                    type: 'IMMUNITY',
                    turn: turn + 1
                });
            }
        }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'HEAL_DOWN'].includes(type)) return;
        
        // 9. ìµœì¢… ë“±ë¡
        this.status.push({
            type,
            turn,
            val,
            sourceId: source ? source.id : -1
        });
    }
    hasStatus(type) {
        return this.status.some(s => s.type === type);
    }
    cleanse() {
        const bad = ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'KARMA_VICTIM', 'MC_WAIT', 'MC_READY'];
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM'));
    }
    dispel() {
        const buffs = ['EVADE', 'DMG_RED', 'ATK_BUFF', 'GROWTH', 'LIGHT_MIGHT'];
        const has = this.status.some(s => buffs.includes(s.type));
        this.status = this.status.filter(s => !buffs.includes(s.type));
        return has;
    }

    tickStatus() {
        let log = [];
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const findSource = (id) => allUnits.find(u => u.id === id) || null;

        // 1. ë… (Poison)
        const poison = this.status.find(s => s.type === 'POISON');
        if (poison) {
            const src = findSource(poison.sourceId);
            const d = this.takeDamage(35, false, false, src); // í‚¬ ë¡œê·¸ë¥¼ ìœ„í•´ src ì „ë‹¬
            if (src) Game.recordStat(src, 'dmg', d);          // í†µê³„ ê¸°ë¡
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`);
        }

        // 2. í™”ìƒ (Burn)
        const burn = this.status.find(s => s.type === 'BURN');
        if (burn) {
            const src = findSource(burn.sourceId);
            const d = this.takeDamage(20, false, false, src);
            if (src) Game.recordStat(src, 'dmg', d);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`);
        }

        // 3. ëª¨ë˜ì§€ì˜¥ (Trap)
        const trap = this.status.find(s => s.type === 'TRAP');
        if (trap) {
            const src = findSource(trap.sourceId);
            // [Balance] ì†ë°• ë°ë¯¸ì§€ 40 -> 60 ìƒí–¥ ìœ ì§€
            const d = this.takeDamage(60, false, false, src);
            if (src) Game.recordStat(src, 'dmg', d);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`);
        }
        return log;
    }
    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    heal(amount) {
        // [ìˆ˜ì •] ì¹˜ìœ  ê°ì†Œ(HEAL_DOWN) ë¡œì§ ê²€ì¦ ë° ë””ë²„ê¹…
        const healDebuffs = this.status.filter(s => s.type === 'HEAL_DOWN');
        if (healDebuffs.length > 0) {
            // ê°ì†Œìœ¨ í•©ì‚° (ì˜ˆ: ë…20 + ëª¨ë˜70 = 90)
            const totalReduction = healDebuffs.reduce((sum, s) => sum + (s.val || 0), 0);
            
            // ê¸°ì¡´ íëŸ‰ ì €ì¥ (ë””ë²„ê¹…ìš©)
            const originalAmount = amount;
            
            // íš¨ìœ¨ ê³„ì‚° (100 - ê°ì†Œìœ¨)% ì ìš©
            const multiplier = Math.max(0, (100 - totalReduction) / 100);
            amount = Math.floor(amount * multiplier);

            // [ë””ë²„ê·¸ ë¡œê·¸] ì½˜ì†”ì°½(F12)ì—ì„œ ì‘ë™ ì—¬ë¶€ í™•ì¸ ê°€ëŠ¥
            console.log(`ğŸ’‰ [Healing] ${this.name}: ${originalAmount} -> ${amount} (ê°ì†Œìœ¨: ${totalReduction}%)`);
            
            // ì¹˜ìœ  ê°ì†Œë¡œ 0ì´ ë˜ì—ˆì„ ë•Œ "ì¹˜ìœ ì°¨ë‹¨" í…ìŠ¤íŠ¸ í‘œì‹œ
            if (amount === 0 && originalAmount > 0) {
                UI.floatText(this, "ì¹˜ìœ ì°¨ë‹¨", "ft-miss");
            }
        }

        const prev = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + amount);
        const diff = this.hp - prev;
        if (diff > 0) {
            UI.floatText(this, diff, 'ft-heal');
        }
        this.checkAwakening();
        return diff;
    }
}

const AudioSys = {
    ctx: null,
    masterVol: 0.5,
    bgmMuted: false,
    sfxMuted: false,

    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    // ğŸŸ¢ [ì¶”ê°€] ì´ ë¶€ë¶„ì´ ë¹ ì ¸ìˆì–´ì„œ ì‹¤í–‰ì´ ì•ˆ ëœ ê²ƒì…ë‹ˆë‹¤!
    resume: function() {
        this.init();
    },
    
    // [ì‹ ê·œ] ë³¼ë¥¨ ì¡°ì ˆ
    setMasterVolume: function(val) {
        this.masterVol = val / 100;
    },

    // [ì‹ ê·œ] ì±„ë„ í† ê¸€ (bgm/sfx)
    toggleChannel: function(type) {
        if (type === 'bgm') {
            this.bgmMuted = !this.bgmMuted;
            document.getElementById('tog-bgm').classList.toggle('on');
            // [Fix] MusicEngineìœ¼ë¡œ ë³€ê²½
            if(this.bgmMuted) MusicEngine.stop(); 
            else MusicEngine.play('Battle_Piano'); // ì¼œì§ˆ ë•Œ ê¸°ë³¸ ì¬ìƒ
        } else {
            this.sfxMuted = !this.sfxMuted;
            document.getElementById('tog-sfx').classList.toggle('on');
        }
    },

    // ì†Œë¦¬ ì¬ìƒ (ì œê³µí•´ì£¼ì‹  ë¡œì§ í†µí•©)
    playTone: function(freq, type, duration, vol, detune = 0, isBGM = false) {
        if (!this.ctx) return;
        if (isBGM && this.bgmMuted) return;
        if (!isBGM && this.sfxMuted) return;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        if (detune !== 0) osc.detune.value = detune;

        // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì ìš©
        const finalVol = vol * this.masterVol;

        // ë³¼ë¥¨ ì—”ë²¨ë¡œí”„ (ë¶€ë“œëŸ¬ìš´ ì‹œì‘ê³¼ ë)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.05); // Attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration); // Decay

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration + 0.1);
    },

    // íš¨ê³¼ìŒ ì „ìš© ë˜í¼ (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ìš©)
    play: function(type) {
        if (this.sfxMuted) return;
        this.init();
        // ê¸°ì¡´ íš¨ê³¼ìŒ ë¡œì§ ìœ ì§€ (playTone í˜¸ì¶œ ì‹œ íŒŒë¼ë¯¸í„° ì „ë‹¬)
        switch (type) {
            case 'HIT': this.playTone(150, 'square', 0.1, 0.2); break;
            case 'CRITICAL': 
                this.playTone(800, 'sawtooth', 0.2, 0.3); 
                setTimeout(()=>this.playTone(1200, 'square', 0.1, 0.2), 50);
                break;
            case 'SKILL': this.playTone(400, 'sine', 0.3, 0.2); break;
            case 'HEAL': 
                this.playTone(600, 'sine', 0.15, 0.2);
                setTimeout(()=>this.playTone(800, 'sine', 0.3, 0.2), 150);
                break;
            case 'DEBUFF': this.playTone(300, 'sawtooth', 0.3, 0.15); break;
            case 'POWER_UP':
                this.playTone(300, 'square', 0.1, 0.15);
                setTimeout(()=>this.playTone(450, 'square', 0.1, 0.15), 100);
                break;
            case 'WIN': 
                [0,200,400,600].forEach((d,i)=> setTimeout(()=>this.playTone(523+(i*100),'triangle',0.3,0.3), d));
                break;
            case 'CUTIN': this.playTone(100, 'sawtooth', 0.8, 0.4); break;
            case 'AWAKEN': this.playTone(200, 'square', 0.5, 0.3); break;
        }
    },
    speak: function(unit) {
        if(this.sfxMuted) return;
        this.init();
        const base = 400 + (unit.id*50);
        for(let i=0; i<2; i++) {
            setTimeout(()=> this.playTone(base+(Math.random()*100-50), 'triangle', 0.08, 0.15), i*80);
        }
    }
};
// ==========================================
// ğŸ¹ Music Engine (Hybrid: Canon + New Tracks)
// ==========================================
const MusicEngine = {
    ctx: null, isPlaying: false, currentTrack: null, tempo: 100, timeoutId: null, bgmOscillators: [],
    
    // [ìºë…¼ ì›ë³¸ ë°ì´í„°] ì‚¬ìš©ì ìš”ì²­ ì›ë³¸ ìœ ì§€
    canon: {
        melody: [587, 554, 494, 440, 392, 370, 392, 440, 587, 0, 494, 0, 494, 554, 587, 659, 740, 587, 659, 587, 554, 494, 554, 440, 392, 440, 494, 554, 370, 440, 494, 554],
        bass:   [293, 0, 220, 0, 246, 0, 185, 0, 196, 0, 293, 0, 196, 0, 220, 0, 293, 220, 246, 293, 185, 246, 196, 220, 196, 220, 293, 220, 293, 370, 440, 554],
        step: 0,
        style: 1 // 1:Piano, 2:Harp, 3:Mix
    },

    init: () => {
        if (!MusicEngine.ctx) { MusicEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (MusicEngine.ctx.state === 'suspended') MusicEngine.ctx.resume();
    },

    // [ì†Œë¦¬ ë°œìƒê¸°] (ìºë…¼ ì›ë³¸ ë¡œì§ í˜¸í™˜ìš©)
    playTone: (freq, type, duration, vol, detune=0) => {
        const t = MusicEngine.ctx.currentTime;
        const osc = MusicEngine.ctx.createOscillator();
        const gain = MusicEngine.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        if(detune) osc.detune.value = detune;

        // [Fix] ë§ˆìŠ¤í„° ë³¼ë¥¨ ì—°ë™ (0ì¼ ë•Œ 0.5ë¡œ ê°•ì œë˜ëŠ” ë²„ê·¸ ìˆ˜ì •)
        // AudioSys.masterVolì´ ì •ì˜ë˜ì–´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì“°ê³ , ì—†ìœ¼ë©´ 0.5ë¥¼ ì”€
        const master = (AudioSys.masterVol !== undefined) ? AudioSys.masterVol : 0.5;
        const finalVol = vol * master * 0.3;
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain); gain.connect(MusicEngine.ctx.destination);
        osc.start(t); osc.stop(t + duration + 0.1);
        MusicEngine.bgmOscillators.push(osc);
    },

    // [ìŒê³„ ë³€í™˜ê¸°] (ì‹ ê·œ ê³¡ìš©)
    getFreq: (note) => {
        if (!note) return 0;
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = parseInt(note.slice(-1));
        const idx = notes.indexOf(note.slice(0, -1));
        return idx === -1 ? 0 : 440 * Math.pow(2, (idx - 9 + (octave - 4) * 12) / 12);
    },

    // [ì¬ìƒ ë©”ì¸ í•¨ìˆ˜]
    play: (trackName) => {
        MusicEngine.init(); MusicEngine.stop();
        MusicEngine.isPlaying = true;

        // A. ìºë…¼ ëª¨ë“œ (ê¸°ì¡´ ë¡œì§)
        if (trackName.startsWith('Canon')) {
            if (trackName === 'Canon_Piano') MusicEngine.canon.style = 1;
            else if (trackName === 'Canon_Harp') MusicEngine.canon.style = 2;
            else if (trackName === 'Canon_Mix') MusicEngine.canon.style = 3;
            
            MusicEngine.canon.step = 0;
            MusicEngine.loopCanon();
        } 
        // B. ì‹ ê·œ íŠ¸ë™ ëª¨ë“œ
        else {
            MusicEngine.currentTrack = MusicEngine.Tracks[trackName];
            if (!MusicEngine.currentTrack) return;
            MusicEngine.tempo = MusicEngine.currentTrack.bpm;
            
            let noteIndex = 0;
            const playNext = () => {
                if (!MusicEngine.isPlaying) return;
                const noteData = MusicEngine.currentTrack.notes[noteIndex];
                // ë…¸íŠ¸ ì¬ìƒ
                if (noteData[0]) {
                    const notes = Array.isArray(noteData[0]) ? noteData[0] : [noteData[0]];
                    notes.forEach(n => {
                        // ì‹ ê·œ ê³¡ì€ ë¶€ë“œëŸ¬ìš´ Triangle íŒŒí˜• ì‚¬ìš©
                        const f = MusicEngine.getFreq(n);
                        MusicEngine.playTone(f, 'triangle', noteData[1] * (60/MusicEngine.tempo), 0.3);
                    });
                }
                const timeToNext = noteData[1] * (60000 / MusicEngine.tempo);
                noteIndex = (noteIndex + 1) % MusicEngine.currentTrack.notes.length;
                MusicEngine.timeoutId = setTimeout(playNext, timeToNext);
            };
            playNext();
        }
    },

    // [ìºë…¼ ë£¨í”„] (ì‚¬ìš©ì ì›ë³¸ ë¡œì§ ë³µì›)
    loopCanon: function() {
        if (!this.isPlaying) return;
        
        // í…œí¬ ë¡œì§ (ìœ„ê¸° ì‹œ ë¹¨ë¼ì§)
        // const isDanger = Game.pTeam && Game.pTeam.some(u => !u.isDead && u.hp < u.maxHp * 0.3);
        const tempo = 400; // ê¸°ë³¸ 400ms

        const idx = this.canon.step;
        const mNote = this.canon.melody[idx];
        const bNote = this.canon.bass[idx];
        const style = this.canon.style;

        // === ì›ë³¸ ìŠ¤íƒ€ì¼ ë¡œì§ ===
        if (style === 1) { // Soft Piano
            if(mNote) {
                this.playTone(mNote, 'sine', 0.6, 0.3);
                this.playTone(mNote, 'triangle', 0.6, 0.2);
            }
            if(bNote) this.playTone(bNote, 'sine', 0.8, 0.4);
        } 
        else if (style === 2) { // Harp
            if(mNote) this.playTone(mNote, 'triangle', 0.3, 0.3);
            if(bNote) {
                this.playTone(bNote, 'triangle', 0.4, 0.3);
                setTimeout(() => this.playTone(bNote * 1.5, 'sine', 0.2, 0.1), 50);
            }
        } 
        else if (style === 3) { // Mix
            if(mNote) {
                this.playTone(mNote, 'sine', 0.5, 0.3);
                this.playTone(mNote * 2, 'triangle', 0.2, 0.1);
            }
            if(bNote) {
                this.playTone(bNote, 'square', 0.1, 0.05);
                this.playTone(bNote, 'sine', 0.8, 0.3);
            }
        }

        this.canon.step = (this.canon.step + 1) % this.canon.melody.length;
        this.timeoutId = setTimeout(() => this.loopCanon(), tempo);
    },

    stop: () => {
        MusicEngine.isPlaying = false;
        clearTimeout(MusicEngine.timeoutId);
        MusicEngine.bgmOscillators.forEach(o => { try{o.stop();}catch(e){} });
        MusicEngine.bgmOscillators = [];
    },

    // ì‹ ê·œ ê³¡ ì•…ë³´
    Tracks: {
        'Battle_Piano': { bpm: 90, notes: [['A3',0.5],['E4',0.5],['A4',0.5],['E4',0.5],['F3',0.5],['C4',0.5],['F4',0.5],['C4',0.5],['G3',0.5],['D4',0.5],['G4',0.5],['D4',0.5],['E3',0.5],['B3',0.5],['E4',1.0],[['A3','C4'],1.0],['B3',0.5],['A3',0.5],[['F3','A3'],1.5],['G3',0.5],[['C4','E4'],1.0],['D4',0.5],['C4',0.5],[['G3','B3'],2.0],[['F3','A3'],1.0],['G3',0.5],['A3',0.5],[['D3','F3'],1.5],['E3',0.5],[['E3','G#3'],2.0],[null,0.5],['E4',0.5],['D4',0.5],['C4',0.5],[['A3','C4','E4'],2.0],[['F3','A3','C4'],2.0],[['G3','B3','D4'],2.0],[['E3','G#3','B3'],2.0],['A3',0.5],['B3',0.5],['C4',1.0],[null,1.0]] },
        'Thinking': { bpm: 100, notes: [['D4',0.5],['A3',0.5],['D4',0.5],['E4',0.5],['F4',1.5],['E4',0.5],['D4',0.5],['A3',0.5],['F4',0.5],['E4',0.5],['D4',1.5],[null,0.5],[['D3','D4'],0.5],['A3',0.5],['D4',0.5],['E4',0.5],[['F3','F4'],1.5],['E4',0.5],[['G3','D4'],0.5],['A3',0.5],['F4',0.5],['E4',0.5],[['A2','D4'],1.5],[null,0.5],[['Bb3','D5'],1.0],['C5',0.5],['A4',0.5],[['C4','G4'],1.5],['F4',0.5],[['D3','D4'],1.0],['F4',0.5],['E4',0.5],[['A2','D4'],2.0],['D4',0.25],['F4',0.25],['A4',0.25],['D5',0.25],['C5',1.0],[null,1.0]] },
        'Aftermath': { bpm: 80, notes: [[['C4','E4'],2.0],[['D4','F4'],2.0],[['E4','G4'],3.0],[null,1.0],['G4',0.5],['A4',0.5],[['C4','G4'],2.0],['F4',0.5],['E4',0.5],[['A3','D4'],2.0],['C4',1.0],[['F3','A3','C4'],2.0],[['G3','B3','D4'],2.0],[['E3','G3','C4'],3.0],[null,1.0],['C5',0.5],['B4',0.5],['A4',0.5],['G4',0.5],[['F4','A4'],1.5],['E4',0.5],[['D4','G4'],1.5],['C4',0.5],[['C4','E4','C5'],4.0]] }
    }
};

 

const UI = {
    toggleSettings: function() {
        const el = document.getElementById('audio-settings');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
    // [ì‹ ê·œ] ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë©”ë‰´ í† ê¸€
    toggleSaveMenu: function() {
        const el = document.getElementById('save-menu-popup');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
	// [UI] BGM ì„ íƒ ë° í•˜ì´ë¼ì´íŠ¸ ì²˜ë¦¬
    selectBGM: function(trackName, el) {
        // 1. ëª¨ë“  ì˜µì…˜ì—ì„œ active ì œê±°
        document.querySelectorAll('.bgm-opt').forEach(opt => opt.classList.remove('active'));
        
        // 2. í´ë¦­í•œ ì˜µì…˜ì— active ì¶”ê°€
        if(el) el.classList.add('active');
        
        // 3. ìŒì•… ì¬ìƒ
        MusicEngine.play(trackName);
        
        // 4. í† ê¸€ ë²„íŠ¼ì´ êº¼ì ¸ìˆë‹¤ë©´ ì¼œê¸°
        const tog = document.getElementById('tog-bgm');
        if (tog && !tog.classList.contains('on')) {
            AudioSys.toggleChannel('bgm');
        }
    },

    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() {
        document.getElementById('modal-overlay').style.display = 'none';
    },

    // [UI ê°œì„ ] ì˜¨ë¼ì¸ ì½”ë“œ ì…ë ¥ ëª¨ë‹¬
    openOnlineModal: function() {
        if (!socket || !socket.connected) {
            alert("âš ï¸ ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n(ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” AIì™€ ëŒ€ê²°í•˜ì„¸ìš”)");
            return;
        }
        if (Game.selected.length !== 3) {
            alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        const content = `
            <div style="text-align:center;">
                <p style="color:#555; margin-bottom:15px;">ì¹œêµ¬ì™€ ê³µìœ í•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple)</p>
                <input type="text" id="modal-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥" 
                    style="font-size:20px; padding:15px; width:80%; text-align:center; border-radius:15px; border:2px solid #ddd; outline:none; font-weight:bold; color:#7e57c2;">
                <button id="modal-submit-btn" onclick="Game.submitOnline()" 
                    style="width:100%; margin-top:20px; padding:15px; background:#7e57c2; color:white; border:none; border-radius:15px; font-weight:bold; cursor:pointer; font-size:18px;">
                    ì…ì¥í•˜ê¸° ğŸš€
                </button>
            </div>
        `;
        this.showModal("ğŸŒ ì˜¨ë¼ì¸ ë§¤ì¹­", content);
        setTimeout(() => document.getElementById('modal-room-code').focus(), 100);
    },

    showGuide: function() {
        let heroList = '';
        const guideOrder = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark'];
        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if (k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if (parts.length === 2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';
            // [íŒ¨ì‹œë¸Œ í‘œì‹œ ì¶”ê°€]
            heroList += `<div class="guide-item"> 
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> 
                <div class="guide-info"> 
                    <div class="guide-name">${name}</div> 
                    <div class="guide-desc">${s.desc}</div> 
                    <div style="font-size:10px; color:#555; margin-top:2px;"> 
                        <div>S1: ${s.s1} (${s.s1d})</div> 
                        <div>S2: ${s.s2} (${s.s2d})</div> 
                        ${s.passive ? `<div style="color:#00695c; font-weight:bold; margin-top:2px; border-top:1px dashed #ddd; padding-top:2px;">PASSIVE: ${s.passive}</div>` : ''}
                    </div> 
                </div> 
            </div>`;
        });

        // [ìˆ˜ì •ë¨] íƒ­ 2 (ì‹œìŠ¤í…œ ê·œì¹™) ì¶”ê°€ëœ ì»¨í…ì¸  HTML
        const content = `
        <div class="tab-header">
            <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button>
            <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button>
            <button class="tab-btn" onclick="UI.switchTab(2)">âš™ï¸ ì‹œìŠ¤í…œ</button>
        </div>
        
        <div id="tab-0" class="tab-content active">
            <table class="chart-table">
                <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
                <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr>
            </table>
            
            <div class="dual-chart">
                <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div>
            </div>

            <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; margin-top: 10px; border: 1px solid #90caf9;">
                <h4 style="margin: 0 0 5px 0; color: #1565c0;">ğŸ›¡ï¸ í›„ê³µ(2P) ì „ìˆ  ë³´ë„ˆìŠ¤</h4>
                <p style="font-size: 0.9em; margin: 0; color: #424242;">
                    1. <b>ëª¨ë“  ìœ ë‹›:</b> ì‹œì‘ ì‹œ í–‰ë™ ë¶ˆê°€ <span style="color:#2980b9;">ë©´ì—­</span><br>
                    2. <b>ì„ ë´‰ì¥(1ë²ˆ ìœ ë‹›):</b> 1í„´ê°„ <b style="color:red;">ìµœì¢… ë°ë¯¸ì§€ 10% ì¦ê°€</b>
                </p>
            </div>
        </div>
        
        <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;">
            ${heroList}
        </div>

        <div id="tab-2" class="tab-content" style="max-height: 50vh; overflow-y:auto; font-size:13px; color:#555;">
            <div style="margin-bottom:15px;">
                <h4 style="color:#ff7043; border-bottom:2px solid #ffcc80; padding-bottom:3px;">â˜ ï¸ ìƒíƒœì´ìƒ ë°ë¯¸ì§€ (ê³ ì •)</h4>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>ğŸ”¥ í™”ìƒ:</b> í„´ ì‹œì‘ ì‹œ <b style="color:#ff5722;">20</b> í”¼í•´ (Fireë¡œë¶€í„° ë°›ëŠ” í”¼í•´ 25% ì¦ê°€)</li>
                    <li><b>â˜ ï¸ ë§¹ë…:</b> í„´ ì‹œì‘ ì‹œ <b style="color:#9c27b0;">35</b> í”¼í•´</li>
                    <li><b>â³ ì†ë°•(ëª¨ë˜ì§€ì˜¥):</b> í„´ ì‹œì‘ ì‹œ <b style="color:#f57f17;">60</b> í”¼í•´</li>
                </ul>
            </div>

            <div style="margin-bottom:15px;">
                <h4 style="color:#ffd700; border-bottom:2px solid #fff176; padding-bottom:3px;">âš¡ ê°ì„±(Super Hero) ì¡°ê±´</h4>
                <p style="margin:5px 0; font-size:12px;">ì¡°ê±´ ë‹¬ì„± ì‹œ í…Œë‘ë¦¬ê°€ ë¹›ë‚˜ë©° ìŠ¤íƒ¯ ê¸°ë¡ë¨.</p>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>âš”ï¸ ë”œëŸ¬:</b> 2í‚¬ ì´ìƒ OR ëˆ„ì  ë°ë¯¸ì§€ <b style="color:#f44336;">1500</b></li>
                    <li><b>ğŸ›¡ï¸ íƒ±ì»¤:</b> ëˆ„ì  ë°›ì€ í”¼í•´ <b style="color:#2196f3;">1000</b></li>
                    <li><b>ğŸ§© ì§€ì›:</b> ëˆ„ì  í+ì‰´ë“œ ì œê³µëŸ‰ <b style="color:#4caf50;">1000</b></li>
                </ul>
            </div>

            <div style="margin-bottom:15px;">
                <h4 style="color:#ef5350; border-bottom:2px solid #e57373; padding-bottom:3px;">ğŸ’€ ì„œë“  ë°ìŠ¤ (ë°ìŠ¤ë§¤ì¹˜)</h4>
                <p style="margin:5px 0;">
                    <b>15ë¼ìš´ë“œ</b>(ì•½ 90í„´)ê°€ ì§€ë‚˜ë©´, ëª¨ë“  ì˜ì›…ì˜ ê³µê²©ë ¥ì´ ë§¤ í„´ <b style="color:red;">+10</b>ì”© ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.
                </p>
            </div>

            <div>
                <h4 style="color:#78909c; border-bottom:2px solid #b0bec5; padding-bottom:3px;">â„¹ï¸ ê¸°íƒ€ ìƒì„¸ ê·œì¹™</h4>
                <ul style="padding-left:20px; margin:5px 0;">
                    <li><b>â›°ï¸ í™(Earth) S1:</b> 25% ê¸°ì ˆ / 20% ì¹¨ë¬µ / 55% íš¨ê³¼ì—†ìŒ</li>
                    <li><b>ğŸ›¡ï¸ ì‡ (Metal) íŒ¨ì‹œë¸Œ:</b> ì‰´ë“œê°€ ìˆì„ ë•Œë§Œ ë°œë™ (ìµœëŒ€ì²´ë ¥ 20% ì´ˆê³¼ë¶„ ì‚­ì œ)</li>
                    <li><b>ğŸ§  ì„¸ë‡Œ ë¹„ìš©:</b> ì‹œì „ì í˜„ì¬ ì²´ë ¥ì˜ <b>12%</b> ì†Œëª¨</li>
                </ul>
            </div>
        </div>`;
        
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if (i === idx) b.classList.add('active');
            else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if (i === idx) c.classList.add('active');
            else c.classList.remove('active');
        });
    },

    // [ë°ë¯¸ì§€ í°íŠ¸] ì„¸ë¶„í™” ì ìš©
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id);
        if (!unitEl) return;
        const el = document.createElement('div');
        el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        const randomX = (Math.random() - 0.5) * 40;
        const randomY = (Math.random() - 0.5) * 20;
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px';
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    },

    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        if (!banner) return; // ë°°ë„ˆ ì—†ìœ¼ë©´ ì¡°ìš©íˆ ì¢…ë£Œ

        // (ê¸°ì¡´ ë°°ë„ˆ ë¡œì§ ìœ ì§€)
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´";
        }
        banner.style.animation = 'none';
        void banner.offsetWidth;
        banner.style.animation = 'banner-swipe 1.2s forwards';
    },
    // [ìˆ˜ì •] ì´í™íŠ¸ë¥¼ í™”ë©´ ì „ì²´ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ìƒì„± (ê°€ë ¤ì§ ë°©ì§€)
    playVFX: function(unit, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const el = document.getElementById(id);
        if (!el) return;

        // íƒ€ê²Ÿ ì¹´ë“œì˜ í˜„ì¬ í™”ë©´ìƒ ìœ„ì¹˜(ì¢Œí‘œ)ë¥¼ ê°€ì ¸ì˜´
        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const vfx = document.createElement('div');
        vfx.className = 'vfx-layer';
        // ì¢Œí‘œë¥¼ ì§ì ‘ ì§€ì • (í™”ë©´ ê¸°ì¤€ ì ˆëŒ€ ì¢Œí‘œ)
        vfx.style.left = `${centerX}px`;
        vfx.style.top = `${centerY}px`;
        vfx.style.transform = "translate(-50%, -50%)"; // ì¤‘ì•™ ì •ë ¬ ë³´ì •
        
        switch(type) {
            case 'hit': vfx.innerText = 'ğŸ’¥'; vfx.style.animation = 'vfx-boom 0.4s ease-out forwards'; break;
            case 'slash': vfx.innerText = 'âš”ï¸'; vfx.style.animation = 'vfx-slash 0.3s ease-out forwards'; break;
            case 'fire': vfx.innerText = 'ğŸ”¥'; vfx.style.animation = 'vfx-boom 0.6s ease-out forwards'; vfx.style.color = 'orange'; break;
            case 'ice': vfx.innerText = 'â„ï¸'; vfx.style.animation = 'vfx-boom 0.5s ease-out forwards'; break;
            case 'heal': vfx.innerText = 'âœ¨'; vfx.style.animation = 'vfx-heal 0.8s ease-out forwards'; break;
            case 'rock': vfx.innerText = 'ğŸª¨'; vfx.style.animation = 'vfx-boom 0.4s cubic-bezier(0.1, 0.7, 1.0, 0.1) forwards'; break;
            case 'magic': vfx.innerText = 'ğŸŒ€'; vfx.style.animation = 'vfx-magic 0.7s ease-out forwards'; break;
            default: vfx.innerText = 'ğŸ’¥'; vfx.style.animation = 'vfx-boom 0.4s ease-out forwards'; break;
        }
        
        // ì¹´ë“œê°€ ì•„ë‹Œ 'body'ì— ì§ì ‘ ë¶™ì—¬ì„œ ê°€ì¥ ìœ„ì— í‘œì‹œ
        document.body.appendChild(vfx);
        setTimeout(() => vfx.remove(), 1000);
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);
        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        const mvp = allUnits.sort((a, b) => (b.stats.dmg + b.stats.heal + b.stats.shieldGiven) - (a.stats.dmg + a.stats.heal + a.stats.shieldGiven))[0];
        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`;
        };
        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },

    // [íˆ´íŒ] ì •ë³´ í‘œì‹œ
    showTooltip: function(u, el) {
        const info = SKILL_DB[u.getKey()];
        const statusText = u.status.map(s => {
            let info = `â€¢ ${s.type} (${s.turn}í„´)`;
            // [UI] í™•ë¥  ë° ìƒì„¸ ì •ë³´ í‘œì‹œ
            if (s.type.startsWith('KARMA_VICTIM')) info += ' <span style="color:#ffcc80; font-size:10px;">(ë°˜ì‚¬ 50%)</span>';
            if (s.type === 'MC_WAIT') info += ' <span style="color:#ff80ab; font-size:10px;">(ì„¸ë‡Œ ëŒ€ê¸°)</span>';
            return info;
        }).join('<br>') || 'ì—†ìŒ';
        const html = `
            <div class="tooltip-title">${u.name} (HP: ${u.hp})</div>
            <div style="margin-bottom:5px;">${info.desc}</div>
            <div style="color:#aaa; border-top:1px solid #555; padding-top:3px; margin-top:3px;">
                <b>ìƒíƒœì´ìƒ:</b><br>${statusText}
            </div>
        `;
        const tooltip = document.getElementById('tooltip-view');
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';

        const rect = el.getBoundingClientRect();
        let top = rect.top - 100;
        let left = rect.left + rect.width / 2 - 100;
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
    },
    hideTooltip: function() {
        document.getElementById('tooltip-view').style.display = 'none';
    },

    // [ì»·ì‹ ] ì—°ì¶œ
    showCutIn: function(unit) {
        const ov = document.getElementById('cut-in-overlay');
        const em = document.getElementById('cut-in-emoji');
        const msg = document.getElementById('cut-in-msg');

        const key = unit.getKey();
        em.innerText = SKILL_DB[key].icon || ATTR[unit.base].i;
        msg.innerText = "HEROIC FINISH!";

        ov.style.display = 'flex';
        AudioSys.play('CUTIN');

        // 1.2ì´ˆ í›„ ì¢…ë£Œ
        setTimeout(() => {
            ov.style.display = 'none';
        }, 1200);
    }, 

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ë©”ë‰´ ì—´ê¸°
    showEmoteMenu: function(u, el) {
        const existing = document.querySelector('.emote-menu');
        if (existing) existing.remove();

        const menu = document.createElement('div');
        menu.className = 'emote-menu';
        const emojis = ['ğŸ‘', 'ğŸ˜¡', 'ğŸ˜±', 'ğŸ˜œ', 'ğŸ³ï¸'];
        emojis.forEach(e => {
            const btn = document.createElement('span');
            btn.className = 'emote-btn';
            btn.innerText = e;
            btn.onclick = (ev) => {
                ev.stopPropagation();
                UI.triggerEmote(u, e);
                menu.remove();
            };
            menu.appendChild(btn);
        });
        
        const rect = el.getBoundingClientRect();
        // ìœ ë‹› ë¨¸ë¦¬ ìœ„ì— í‘œì‹œ
        menu.style.top = (rect.top - 60 + window.scrollY) + 'px';
        menu.style.left = (rect.left + rect.width/2 - 100 + window.scrollX) + 'px';
        
        document.body.appendChild(menu);
        
        // ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
        setTimeout(() => {
            document.addEventListener('click', function close() {
                if(menu.parentNode) menu.remove();
                document.removeEventListener('click', close);
            }, {once:true});
        }, 0);
    },

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ì‹¤í–‰
    triggerEmote: function(u, emoji) {
        // ìœ ë‹› ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (!el) return;
        
        const rect = el.getBoundingClientRect();
        
        // ë§í’ì„  ìƒì„± (bodyì— ì§ì ‘ ì¶”ê°€í•˜ì—¬ ìµœìƒìœ„ ë ˆì´ì–´ ë³´ì¥)
        const bubble = document.createElement('div');
        bubble.className = 'emote-bubble';
        bubble.innerText = emoji;
        
        // ìœ„ì¹˜ ì ˆëŒ€ê°’ ê³„ì‚° (ìŠ¤í¬ë¡¤ í¬í•¨)
        bubble.style.left = (rect.left + rect.width / 2) + 'px'; 
        bubble.style.top = (rect.top - 50 + window.scrollY) + 'px';
        // z-indexë¥¼ ì•„ì£¼ ë†’ê²Œ ì„¤ì •
        bubble.style.zIndex = "9999"; 
        
        document.body.appendChild(bubble);
        
        setTimeout(() => bubble.remove(), 2000);
    }, 

// [New] Emotion Codex UI
    showCollection: function() {
        const list = Object.keys(EMOTION_DB);
        let html = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">`;
        let unlockedCount = 0;

        list.forEach(key => {
            const isUnlocked = TitleManager.unlocked.includes(key);
            if (isUnlocked) unlockedCount++;
            
            const data = EMOTION_DB[key];
            const base = key.split('-')[0] === 'Normal' ? 'Normal' : key.split('-')[0];
            let bgClass = `bg-${base}`;
            if (key.includes('-') && key.split('-')[0] === key.split('-')[1]) bgClass += '-Enhanced';
            if (key === 'Normal') bgClass = 'bg-Normal';

            // Style: Unlocked vs Locked
            const style = isUnlocked 
                ? `border:2px solid #ff80ab; background:#fff; color:#333;` 
                : `background:#eee; color:#aaa; border:2px dashed #ccc; opacity:0.7;`;
            
            const icon = isUnlocked ? (SKILL_DB[key].icon || ATTR[base].i) : 'ğŸ”’';
            const title = isUnlocked ? data.t : '???';
            const desc = isUnlocked ? data.d : 'Unlock by Awakening';

            html += `
                <div style="padding:10px; border-radius:15px; display:flex; flex-direction:column; align-items:center; text-align:center; ${style}">
                    <div class="attr-icon ${isUnlocked ? bgClass : ''}" style="width:36px; height:36px; font-size:20px; margin-bottom:5px; ${!isUnlocked?'background:#ccc;':''}">${icon}</div>
                    <div style="font-weight:bold; font-size:14px; margin-bottom:3px;">${title}</div>
                    <div style="font-size:10px; line-height:1.2;">${desc}</div>
                </div>
            `;
        });
        html += `</div>`;
        
        const pct = Math.floor((unlockedCount / list.length) * 100);
        const header = `
            <div style="text-align:center; margin-bottom:15px; padding-bottom:10px; border-bottom:2px dashed #ffcdd2;">
                <h3 style="margin:0 0 5px 0; color:#ff80ab;">ğŸ’ Emotion Codex</h3>
                <div style="font-size:14px; color:#888;">
                    Collection: <b style="color:${pct===100?'#ffca28':'#5d4037'}">${unlockedCount} / ${list.length}</b> (${pct}%)
                </div>
            </div>
        `;

        this.showModal("Codex", header + html);
    },
    // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ ì• ë‹ˆë©”ì´ì…˜
    fireProjectile: function(atk, def, icon) {
        return new Promise(resolve => {
            // ìœ„ì¹˜ ê³„ì‚°
            const startId = atk.team === 0 ? `p-card-${atk.id}` : `e-card-${atk.id}`;
            const endId = def.team === 0 ? `p-card-${def.id}` : `e-card-${def.id}`;
            const sEl = document.getElementById(startId);
            const eEl = document.getElementById(endId);
            
            if (!sEl || !eEl) { resolve(); return; }

            const sRect = sEl.getBoundingClientRect();
            const eRect = eEl.getBoundingClientRect();

            // íˆ¬ì‚¬ì²´ ìƒì„±
            const p = document.createElement('div');
            p.className = 'projectile';
            p.innerText = icon;
            p.style.left = (sRect.left + sRect.width/2) + 'px';
            p.style.top = (sRect.top + sRect.height/2) + 'px';
            document.body.appendChild(p);

            // ë°œì‚¬ (ê°•ì œ ë¦¬í”Œë¡œìš° í›„ ì´ë™)
            requestAnimationFrame(() => {
                p.style.left = (eRect.left + eRect.width/2) + 'px';
                p.style.top = (eRect.top + eRect.height/2) + 'px';
            });

            // ë„ì°© í›„ ì²˜ë¦¬
            setTimeout(() => {
                p.remove();
                // íƒ€ê²© ì´í™íŠ¸
                const boom = document.createElement('div');
                boom.className = 'impact-effect';
                boom.innerText = 'ğŸ’¥';
                boom.style.left = (eRect.left + eRect.width/2) + 'px';
                boom.style.top = (eRect.top + eRect.height/2) + 'px';
                document.body.appendChild(boom);
                setTimeout(() => boom.remove(), 300);
                resolve();
            }, 400); // 0.4ì´ˆ ë¹„í–‰
        });
    },

    // [ê¸°ì¡´ íˆíŠ¸ ìŠ¤í†± ê¸°ëŠ¥ ìœ ì§€]
    hitStop: function(duration = 150) {
        document.body.classList.add('hit-stopped');
        setTimeout(() => {
            document.body.classList.remove('hit-stopped');
        }, duration);
    },

    // [ë©”ë‰´ ì—´ê¸°/ë‹«ê¸° ê¸°ëŠ¥]
    toggleDock: function() {
        const el = document.getElementById('dock-folder');
        if (!el) return; 

        if (el.classList.contains('show')) {
            el.classList.remove('show');
            el.style.display = 'none'; 
            
            const s1 = document.getElementById('audio-settings');
            const s2 = document.getElementById('save-menu-popup');
            if(s1) s1.style.display = 'none';
            if(s2) s2.style.display = 'none';
        } else {
            el.style.display = 'flex'; 
            void el.offsetWidth; 
            el.classList.add('show');
            el.style.zIndex = '9999';
        }
    }
}; // UI ê°ì²´ ì—¬ê¸°ì„œ ë! (ì¤‘ê´„í˜¸, ì„¸ë¯¸ì½œë¡  í•„ìˆ˜)


const Game = {
    // [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
    DEBUG_MODE: true, // ê°œë°œ ì¤‘ì—” true, ë°°í¬ ì‹œ falseë¡œ ë³€ê²½

    debugLog: function(msg, data) {
        if (this.DEBUG_MODE) {
            // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê°ì²´ë¡œ, ì—†ìœ¼ë©´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
            if (data) console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;', data);
            else console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;');
        }
    },
    pool: [],
    selected: [],
    pTeam: [],
    eTeam: [],
    queue: [],
    curr: 0,
    selectedSkillIdx: -1,
    timer: null,
    turnCount: 1,
    difficulty: 'normal',
    watchdog: null,
    isOver: false,
    mode: 'pve',
    isProcessing: false,
    challengeStage: 0,
    isMindControlling: null, // [ì‹ ê·œ] ì„¸ë‡Œ ì¡°ì¢… ìƒíƒœ í”Œë˜ê·¸
    currentMCCasterId: null,
    cleanup: function() {
        console.log("ğŸ§¹ Game cleanup started");
        
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.watchdog) {
            clearTimeout(this.watchdog);
            this.watchdog = null;
        }
        
        this.isOver = true;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        MusicEngine.stop();
        
        console.log("âœ… Game cleanup completed");
    },
	
    netRandom: function() {
        return getNetRandom();
    },

    init: function() {
        // íƒ€ì´ë¨¸ ì •ë¦¬
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // ìƒíƒœ ì´ˆê¸°í™”
        this.isOver = false;
        this.isProcessing = false;
        this.isMindControlling = null;
        this.currentMCCasterId = null;
        
        // BGM ì •ì§€
        MusicEngine.stop();
        
        // ë°ì´í„° ì´ˆê¸°í™”
        this.pool = [];
        this.selected = [];
        const allCombos = [{
            b: 'Metal',
            e: null
        }, {
            b: 'Tree',
            e: null
        }, {
            b: 'Fire',
            e: 'Light'
        }, {
            b: 'Water',
            e: 'Light'
        }, {
            b: 'Fire',
            e: null
        }, {
            b: 'Normal',
            e: null
        }, {
            b: 'Fire',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: null
        }, {
            b: 'Water',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Light'
        }, {
            b: 'Earth',
            e: 'Light'
        }, {
            b: 'Tree',
            e: 'Dark'
        }, {
            b: 'Water',
            e: null
        }, {
            b: 'Tree',
            e: 'Light'
        }, {
            b: 'Light',
            e: null
        }, {
            b: 'Light',
            e: 'Light'
        }, {
            b: 'Dark',
            e: null
        }, {
            b: 'Dark',
            e: 'Dark'
        }];
        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // [UI ê°œì„ ] ì˜¨ë¼ì¸ ë²„íŠ¼ì€ í•­ìƒ í™œì„±í™”, í´ë¦­ ì‹œ ëª¨ë‹¬ ì²˜ë¦¬
        const btnOnline = document.getElementById('btn-online');
        if (btnOnline) {
            btnOnline.style.backgroundColor = '#7e57c2';
        }

        this.checkMode();
    },

    // [UI ê°œì„ ] ëª¨ë‹¬ì—ì„œ ì½”ë“œ ì…ë ¥ í›„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    submitOnline: function() {
        const codeInput = document.getElementById('modal-room-code');
        const code = codeInput.value.trim();
        if (!code) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            codeInput.focus();
            return;
        }

        const btn = document.getElementById('modal-submit-btn');
        if (btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
        btn.disabled = true;
        btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";

        startOnlineGame(code);
    },

    renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block';
        grid.style.overflowY = 'auto';

        const categories = [
            { name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)", range: [0, 3], color: "#e3f2fd", border: "#90caf9" },
            { name: "âš”ï¸ ë”œëŸ¬ (Dealer)", range: [4, 13], color: "#ffebee", border: "#ef9a9a" },
            { name: "ğŸ§© ì§€ì› (Support)", range: [14, 19], color: "#f1f8e9", border: "#a5d6a7" }
        ];

        categories.forEach(cat => {
            // ì¹´í…Œê³ ë¦¬ í—¤ë”
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px 15px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:15px; border-radius:8px; color:#455a64; text-align:left; box-sizing:border-box; font-size:15px;`;
            header.innerText = cat.name;
            grid.appendChild(header);

            // ì¹´ë“œ ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ
            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(auto-fill, minmax(100px, 1fr)); gap:10px; padding:10px 0;";

            for (let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const key = u.getKey();
                const info = SKILL_DB[key];
                
                // [1] ì•„ì´ì½˜ ìƒì„± (ì „íˆ¬ í™”ë©´ê³¼ ë™ì¼ ë¡œì§)
                let iconsHtml = '';
                if (ATTR[u.base]) iconsHtml += `<div class="tiny-icon">${ATTR[u.base].i}</div>`;
                if (u.extra && ATTR[u.extra]) iconsHtml += `<div class="tiny-icon">${ATTR[u.extra].i}</div>`;
                if (iconsHtml === '' && info) iconsHtml = `<div class="tiny-icon">${info.icon}</div>`;

                // [2] ì´ë¦„ ë° ì„¤ëª… ê°„ì†Œí™”
                // ì´ë¦„ì—ì„œ ë¶ˆí•„ìš”í•œ ê´„í˜¸ ì œê±° (ì˜ˆ: "í‘¸ë¥¸ë¶ˆ (ë¶ˆ+ë¹›)" -> "í‘¸ë¥¸ë¶ˆ")
                const cleanName = u.name.split(' ')[0]; 
                // ì„¤ëª…ì€ ìŠ¤í‚¬DBì˜ ì§§ì€ ì„¤ëª… ì‚¬ìš© (ì˜ˆ: "ê´‘ì—­ ë”œëŸ¬")
                // HTML íƒœê·¸(<br>)ê°€ ìˆë‹¤ë©´ ì²« ì¤„ë§Œ ê°€ì ¸ì˜´
                let shortDesc = info.desc.split('<br>')[0];

                const imgUrl = IMAGE_DB[key] || IMAGE_DB['Default'];
                
                // ë°°ê²½ í‹´íŠ¸
                let tintColor = 'transparent';
                if(u.base === 'Fire') tintColor = 'rgba(255, 0, 0, 0.1)';
                else if(u.base === 'Water') tintColor = 'rgba(0, 0, 255, 0.1)';
                else if(u.base === 'Tree') tintColor = 'rgba(0, 255, 0, 0.1)';

                const el = document.createElement('div');
                // .unit í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì—¬ ì „íˆ¬ ì¹´ë“œ ìŠ¤íƒ€ì¼ì„ ê°€ì ¸ì˜¤ê³ , .hero-cardë¡œ ì„ íƒ í™”ë©´ ì „ìš© ìŠ¤íƒ€ì¼ ë®ì–´ì“°ê¸°
                el.className = 'unit hero-card'; 
                el.id = `card-${i}`;
                
                // [3] HTML ì¡°ë¦½
                el.innerHTML = `
                    <div class="unit-img-bg" style="background-image: url('${imgUrl}');">
                        <div style="position:absolute; inset:0; background:${tintColor};"></div>
                    </div>
                    
                    <div class="card-badge" style="top:5px; left:5px;">${iconsHtml}</div>

                    <div class="unit-info-overlay" style="padding-bottom:8px;">
                        <div class="card-name" style="font-size:15px; margin-bottom:2px;">${cleanName}</div>
                        <div style="font-size:10px; color:#ddd; font-weight:normal;">${shortDesc}</div>
                    </div>
                `;

                el.onclick = () => { this.toggle(i, el); };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },
    renderCard: function(u) {
    if (!u) return '';

    let bgClass = 'bg-' + u.base;
    if (u.isEnhanced) {
        bgClass = 'bg-' + u.base + '-Enhanced';
    } else if (u.isNormal) {
        bgClass = 'bg-Normal';
    }

    const key = u.getKey();
    const info = SKILL_DB[key];
    
    if (!info) {
        console.error('SKILL_DB missing for key:', key);
        return '<div class="attr-icon bg-Normal">?</div><div style="font-weight:bold;">ERROR</div>';
    }

    const mainIcon = info.icon || (ATTR[u.base] ? ATTR[u.base].i : '?');
    const baseIcon = ATTR[u.base] ? ATTR[u.base].i : '?';
    const extraIcon = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : '';
    const displayName = u.name ? u.name.split(' ')[0] : 'Unknown';
    const fullName = u.name || 'Unknown';
    const description = info.desc || 'ì •ë³´ ì—†ìŒ';

    let html = '<div class="attr-icon ' + bgClass + '">';
    html += mainIcon;
    html += '<div class="mini-attr-box">';
    html += '<div class="mini-icon">' + baseIcon + '</div>';
    if (extraIcon) {
        html += '<div class="mini-icon">' + extraIcon + '</div>';
    }
    html += '</div></div>';
    html += '<div style="font-weight:bold; margin-bottom:2px; font-size:15px;">' + displayName + '</div>';
    html += '<div style="font-size:11px; color:#999;">' + fullName + '</div>';
    html += '<div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">';
    html += description + '</div>';
    
    return html;
},
    toggle: function(i, el) {
        if (!el) el = document.getElementById(`card-${i}`);
        
        // [ì˜¤í”„ë¼ì¸ PVP ëª¨ë“œ ë¡œì§]
        const diff = document.getElementById('diff-select').value;
        if (diff === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;
            if (!this.p1Selection) this.p1Selection = [];
            if (!this.p2Selection) this.p2Selection = [];

            const isP1 = (this.pickTurn === 0);
            const list = isP1 ? this.p1Selection : this.p2Selection;
            
            // ì„ íƒ í† ê¸€ ë¡œì§
            if (list.includes(i)) {
                // ì´ë¯¸ ì„ íƒí–ˆë‹¤ë©´ í•´ì œ
                if (isP1) {
                    this.p1Selection = this.p1Selection.filter(x => x !== i);
                    el.classList.remove('selected');
                } else {
                    this.p2Selection = this.p2Selection.filter(x => x !== i);
                    el.classList.remove('p2-selected');
                }
            } else {
                // ì„ íƒ ì¶”ê°€ (ìµœëŒ€ 3ëª…)
                if (list.length >= 3) {
                    el.classList.add('shake');
                    setTimeout(() => el.classList.remove('shake'), 500);
                    return;
                }
                list.push(i);
                if (isP1) el.classList.add('selected');
                else el.classList.add('p2-selected');
            }
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ê°±ì‹ 
            const count = (isP1 ? this.p1Selection : this.p2Selection).length;
            const btn = document.getElementById('btn-start');
            btn.innerText = isP1 ? `ğŸ”´ 1P ì„ íƒ (${count}/3)` : `ğŸ”µ 2P ì„ íƒ (${count}/3)`;
            btn.disabled = count !== 3; // 3ëª…ì„ ë‹¤ ê³¨ë¼ì•¼ ë²„íŠ¼ í™œì„±í™”
            return;
        }

        // [ê¸°ì¡´ PVE/ì˜¨ë¼ì¸ ë¡œì§ ìœ ì§€]
        if (this.selected.includes(i)) {
            this.selected = this.selected.filter(x => x !== i);
            el.classList.remove('selected');
        } else {
            if (this.selected.length >= 3) {
                el.classList.add('shake');
                setTimeout(() => el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },
    randomPick: function() {
        const diff = document.getElementById('diff-select').value;

        // [A] ì˜¤í”„ë¼ì¸ 1:1 (Local) ëª¨ë“œ ì „ìš© ë¡œì§
        if (diff === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;
            const isP1 = (this.pickTurn === 0);
            const cssClass = isP1 ? 'selected' : 'p2-selected';

            // 1. ê¸°ì¡´ ì„ íƒ ì´ˆê¸°í™” (ì‹œê°ì  + ë°ì´í„°)
            const currentList = isP1 ? (this.p1Selection || []) : (this.p2Selection || []);
            currentList.forEach(idx => {
                const el = document.getElementById(`card-${idx}`);
                if (el) el.classList.remove(cssClass);
            });

            // 2. ë°ì´í„° ë°°ì—´ ì´ˆê¸°í™”
            if (isP1) this.p1Selection = [];
            else this.p2Selection = [];
            const targetList = isP1 ? this.p1Selection : this.p2Selection;

            // 3. ëœë¤ 3ëª… ë½‘ê¸° (ì¤‘ë³µ ì—†ì´)
            while (targetList.length < 3) {
                const r = Math.floor(Math.random() * 20);
                if (!targetList.includes(r)) {
                    targetList.push(r);
                    const el = document.getElementById(`card-${r}`);
                    if (el) el.classList.add(cssClass);
                }
            }

            // 4. ë²„íŠ¼ í…ìŠ¤íŠ¸ ê°±ì‹ 
            const btn = document.getElementById('btn-start');
            btn.innerText = isP1 ? `ğŸ”´ 1P ì„ íƒ (3/3)` : `ğŸ”µ 2P ì„ íƒ (3/3)`;
            btn.disabled = false;
            return;
        }

        // [B] ê¸°ì¡´ PvE / ì˜¨ë¼ì¸ ëª¨ë“œ ë¡œì§
        Game.selected.forEach(i => {
            const el = document.getElementById(`card-${i}`);
            if (el) el.classList.remove('selected');
        });
        Game.selected = [];
        while (Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if (!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.getElementById(`card-${r}`);
                if (el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        
        // [ê¸°ì¡´ ë¡œì§ ìœ ì§€] ì±Œë¦°ì§€ ëª¨ë“œ UI ì²˜ë¦¬
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            if (this.challengeStage > maxStage) this.challengeStage = maxStage;
            
            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }

        // ============================================================
        // [New Feature] ì˜¤í”„ë¼ì¸ PVP ëª¨ë“œ ì§„ì…/ì´íƒˆ ì‹œ 'ì„ íƒ ì´ˆê¸°í™”'
        // ============================================================
        const isLocal = (diff === 'local');
        
        // 1. ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ë³€ê²½í–ˆê±°ë‚˜
        // 2. ì´ë¯¸ ì„ íƒëœ ë°ì´í„°ê°€ ìˆëŠ”ë° ëª¨ë“œë¥¼ ë°”ê¿¨ë‹¤ë©´ -> ì´ˆê¸°í™”
        if (isLocal || (this.p1Selection && this.p1Selection.length > 0) || (this.p2Selection && this.p2Selection.length > 0)) {
            
            // ë°ì´í„° ì´ˆê¸°í™”
            this.selected = [];
            this.p1Selection = [];
            this.p2Selection = [];
            this.pickTurn = 0;
            
            // ì‹œê°ì  ì„ íƒ í•´ì œ (íšŒìƒ‰/íŒŒë€ìƒ‰/í”ë“¤ë¦¼ ì œê±°)
            const cards = document.querySelectorAll('.hero-card');
            cards.forEach(el => {
                el.classList.remove('selected');
                el.classList.remove('p2-selected');
                el.classList.remove('shake');
            });
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            const btn = document.getElementById('btn-start');
            if (isLocal) {
                btn.innerText = "ğŸ”´ 1P ì„ íƒ (0/3)";
            } else {
                btn.innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
            }
            btn.disabled = true;
        }
    },
    
    // [ìœ ì§€] ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ ì„ íƒ (ì‚­ì œ ê¸ˆì§€!)
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    
    // [ìœ ì§€] ìŠ¤í…Œì´ì§€ ì •ë³´ ê°±ì‹  (ì‚­ì œ ê¸ˆì§€!)
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },
    start: function() {
        AudioSys.init();
        AudioSys.resume();
        MusicEngine.play('Canon_Piano'); 
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        // =========================================
        // [1] ì˜¤í”„ë¼ì¸ PVP (1:1) ëª¨ë“œ ë¡œì§
        // =========================================
        if (diffVal === 'local') {
            if (typeof this.pickTurn === 'undefined') this.pickTurn = 0;

            // [ë‹¨ê³„ A] 1P ì„ íƒ ì™„ë£Œ ì‹œì  -> 2P í„´ìœ¼ë¡œ ë„˜ê¸°ê¸°
            if (this.pickTurn === 0) {
                this.pickTurn = 1; // í„´ ë„˜ê¹€
                alert("ğŸ”´ 1P ì„ íƒ ì™„ë£Œ!\nğŸ”µ 2P(íŒŒë€íŒ€)ê°€ ì„ íƒí•  ì°¨ë¡€ì…ë‹ˆë‹¤.\n(ì¤‘ë³µ ì„ íƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤)");
                
                // 1Pê°€ ê³ ë¥¸ ì¹´ë“œë“¤ì˜ 'ì„ íƒë¨(íšŒìƒ‰)' í‘œì‹œ ì œê±° -> 2Pê°€ ë‹¤ì‹œ ê³ ë¥¼ ìˆ˜ ìˆê²Œ í•¨
                const cards = document.querySelectorAll('.hero-card');
                cards.forEach(c => c.classList.remove('selected'));
                
                // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
                const btn = document.getElementById('btn-start');
                btn.innerText = "ğŸ”µ 2P ì„ íƒ (0/3)";
                btn.disabled = true;
                
                // ì—¬ê¸°ì„œ í•¨ìˆ˜ ì¢…ë£Œ (ê²Œì„ì„ ì‹œì‘í•˜ì§€ ì•Šê³  2P ì…ë ¥ì„ ê¸°ë‹¤ë¦¼)
                return;
            }
            
            // [ë‹¨ê³„ B] 2P ì„ íƒ ì™„ë£Œ ì‹œì  -> ì‹¤ì œ ê²Œì„ ë°ì´í„° ìƒì„±
            // 1P íŒ€ ìƒì„±
            this.pTeam = (this.p1Selection || []).map((idx, i) => {
                const u = this.pool[idx];
                return new Unit(i, 0, u.base, u.extra);
            });
            // 2P íŒ€ ìƒì„± (ì¤‘ë³µ í”½ í—ˆìš©ë¨, íŒ€ ID 1)
            this.eTeam = (this.p2Selection || []).map((idx, i) => {
                const u = this.pool[idx];
                return new Unit(i + 3, 1, u.base, u.extra);
            });
            
            // ë‹¤ìŒ íŒì„ ìœ„í•´ í”½ ë³€ìˆ˜ ì´ˆê¸°í™”
            this.pickTurn = 0; 
            this.p1Selection = [];
            this.p2Selection = [];

        } else {
            // =========================================
            // [2] PVE (ì‹±ê¸€/íŠœí† ë¦¬ì–¼) í†µí•© ë¡œì§
            // =========================================
            
            // ğŸŸ¢ [A] íŠœí† ë¦¬ì–¼ ëª¨ë“œ: ê°•ì œ ì„¸íŒ…
            if (this.difficulty === 'tutorial') {
                if (!this.tStage) this.tStage = 1; 
                
                let pDeck = [], eDeck = [];
                let guideMsg = "";

                // ë‹¨ê³„ë³„ ë°ì´í„° ì •ì˜
                if (this.tStage === 1) {
                    // [ìˆ˜ì •] 1ë‹¨ê³„: ë¶ˆ vs ë‚˜ë¬´/ë¬¼/ì‡ 
                    pDeck = ['Fire', 'Normal', 'Normal'];
                    eDeck = ['Tree', 'Water', 'Metal'];
                    guideMsg = "Lesson 1: <b>ì†ì„± ìƒì„± ê¸°ì´ˆ</b><br>ë¶ˆ(ğŸ”¥)ë¡œ ì ë“¤ì„ ê³µê²©í•˜ë©° ë°ë¯¸ì§€(ì•½ì /ì €í•­) ì°¨ì´ë¥¼ í™•ì¸í•˜ì„¸ìš”!<br>(ì ì€ í›ˆë ¨ìš© ìƒŒë“œë°± ìƒíƒœì…ë‹ˆë‹¤)";
                } else if (this.tStage === 2) {
                    // 2ë‹¨ê³„: íƒ±ì»¤/ë”œëŸ¬
                    pDeck = ['Metal', 'Water', 'Normal'];
                    eDeck = ['Earth', 'Earth'];
                    guideMsg = "Lesson 2: ì‡ (âš”ï¸)ì˜ <b>[ë„ë°œ]</b>ë¡œ ì•„êµ°ì„ ë³´í˜¸í•˜ê³ , ğŸ’§ ë¬¼ë¡œ ê³µê²©í•˜ì„¸ìš”!";
                } else if (this.tStage === 3) {
                    // 3ë‹¨ê³„: í/CC (ì—¬ê¸°ê°€ ë¬¸ì œì˜€ìŒ)
                    pDeck = ['Tree', 'Metal-Dark', 'Normal'];
                    eDeck = ['Metal-Light', 'Metal'];
                    guideMsg = "Lesson 3: ë‚˜ë¬´(ğŸŒ¿)ì˜ <b>[ì¹˜ìœ ]</b>ì™€ âš¡ ì „ê¸°ì˜ <b>[ì„±ì¥]</b>ì„ í™œìš©í•˜ì„¸ìš”!";
                } else {
                    alert("ğŸ‰ íŠœí† ë¦¬ì–¼ ì™„ë£Œ! ì´ì œ ì‹¤ì „ì…ë‹ˆë‹¤.");
                    this.tStage = 1; location.reload(); return;
                }

                // [ì¤‘ìš”] í”Œë ˆì´ì–´ íŒ€ ìƒì„± (ë³µí•© ì†ì„± íŒŒì‹± ë¡œì§ í¬í•¨ - í•˜ë‚˜ë§Œ ìˆì–´ì•¼ í•¨!)
                this.pTeam = pDeck.map((key, i) => {
                    let base = key, extra = null;
                    // '-'ê°€ ìˆìœ¼ë©´ ë¶„ë¦¬, ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ
                    if (key !== 'Normal' && key.includes('-')) {
                        [base, extra] = key.split('-');
                    } else {
                        base = key;
                    }
                    
                    const u = new Unit(i, 0, base, extra);
                    if(key === 'Normal') { u.hp = 0; u.isDead = true; } 
                    return u;
                });
                
                // [ì¤‘ìš”] ì  íŒ€ ìƒì„± (ë³µí•© ì†ì„± íŒŒì‹± + ë„ˆí”„ ë¡œì§)
                this.eTeam = eDeck.map((key, i) => {
                    let base = key, extra = null;
                    if (key !== 'Normal' && key.includes('-')) {
                        [base, extra] = key.split('-');
                    } else {
                        base = key;
                    }

                    const u = new Unit(i+3, 1, base, extra);
                    
                    if (this.tStage === 1) {
                        // 1ë‹¨ê³„: ìƒŒë“œë°±
                        u.maxHp = 100; u.hp = 100;
                        u.addStatus('SILENCE', 999, 0, null, true);
                        u.name = `[í›ˆë ¨] ${u.name}`;
                    } else if (this.tStage === 2) {
                        // 2ë‹¨ê³„: ì²´ë ¥ 40%
                        u.maxHp = Math.floor(u.maxHp * 0.4); u.hp = u.maxHp;
                        u.name = `[ì‹¤ìŠµ] ${u.name}`;
                    } else {
                        // 3ë‹¨ê³„: ì²´ë ¥ 50%
                        u.maxHp = Math.floor(u.maxHp * 0.5); u.hp = u.maxHp;
                        u.name = `[ì‹¤ìŠµ] ${u.name}`;
                    }
                    return u;
                });

                // ì‹œì‘ ì‹œ ê°€ì´ë“œ ë©”ì‹œì§€ ì˜ˆì•½
                setTimeout(() => UI.showModal(`Lesson ${this.tStage}`, guideMsg), 500);

            } else {
                // ğŸ”µ [B] ì¼ë°˜ PVE ëª¨ë“œ: í”Œë ˆì´ì–´ ì„ íƒ ê¸°ë°˜ ìƒì„±
                if (!this.selected || this.selected.length < 3) {
                    alert("ì˜ì›… 3ëª…ì„ ì„ íƒí•˜ê±°ë‚˜ 'ëœë¤'ì„ ëˆ„ë¥´ì„¸ìš”!"); return; 
                }

                this.pTeam = this.selected.map((idx, i) => {
                    const u = this.pool[idx];
                    u.id = i; u.team = 0;
                    return u;
                });
                
                this.eTeam = [];
                const makeEnemy = (idx, b, e) => new Unit(idx + 3, 1, b, e);

                if (this.difficulty === 'hell') {
                    if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
                    const stageData = ChallengeDB[this.challengeStage];
                    let currentTeamList = [...stageData.team];
                    if (!stageData.fixedOrder) currentTeamList.sort(() => Math.random() - 0.5);
                    this.eTeam = currentTeamList.map((key, i) => {
                        let b, e;
                        if (key === 'Normal') { b = 'Normal'; e = null; } 
                        else if (key.includes('-')) { [b, e] = key.split('-'); } 
                        else { b = key; e = null; }
                        return makeEnemy(i, b, e);
                    });
                } else if (this.difficulty === 'mirror') {
                    this.eTeam = this.pTeam.map((pu, i) => {
                        const u = new Unit(i + 3, 1, pu.base, pu.extra);
                        u.maxHp = Math.floor(u.maxHp * 1.15); u.hp = u.maxHp; u.atk = Math.floor(u.atk * 1.15);
                        return u;
                    });
                } else if (this.difficulty === 'easy') {
                    const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
                    while (this.eTeam.length < 3) {
                        const b = basics[Math.floor(Math.random() * basics.length)];
                        if (!this.eTeam.some(u => u.base === b)) this.eTeam.push(makeEnemy(this.eTeam.length, b, null));
                    }
                } else if (this.difficulty === 'hard') {
                    const used = new Set();
                    while (this.eTeam.length < 3) {
                        const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                        const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                        let key = `${b}-${e}`;
                        if (!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
                    }
                    this.eTeam.forEach(u => { u.atk = Math.floor(u.atk*1.1); u.maxHp = Math.floor(u.maxHp*1.1); u.hp = u.maxHp; });
                } else {
                    const used = new Set();
                    while (this.eTeam.length < 3) {
                        const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                        const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                        if (b === 'Dark' && e === 'Light') continue;
                        let key = `${b}-${e}`;
                        if (b === 'Light' && e === 'Dark') key = 'Normal';
                        if (!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
                    }
                }
            }
        }

        // =========================================
        // [3] ê³µí†µ ì´ˆê¸°í™” (í™”ë©´ ì „í™˜, ë¡œê·¸, í„´ ì„¤ì •)
        // =========================================
        this.isOver = false;
        this.queue = [0, 1, 2, 3, 4, 5];
        
        // [Fix] ì˜¨ë¼ì¸ ëª¨ë“œ ë™ê¸°í™”: ì´ˆê¸° í„´ ìˆœì„œë„ ì‹œë“œ ê¸°ë°˜ RNG ì‚¬ìš©
        if (typeof isOnlineMode !== 'undefined' && isOnlineMode && typeof globalRNG !== 'undefined' && globalRNG) {
            this.curr = Math.floor(globalRNG.next() * 6);
        } else {
            this.curr = Math.floor(Math.random() * 6);
        }
        
        this.turnCount = 1;
        this.globalRound = 1; // [ì‹ ê·œ] ë¼ìš´ë“œ ì¹´ìš´í„° ì´ˆê¸°í™”
        this.isProcessing = false;
        
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('battle-screen').style.display = 'flex';
        document.getElementById('logs').innerHTML = '';
        
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        if (this.difficulty === 'local') diffText = 'ğŸ“´ ì˜¤í”„ë¼ì¸ 1:1';
        
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);

        // [ì¤‘ìš”] ì„ /í›„ê³µ ë³´ì • ë¡œì§ (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„)
        const firstTurnUnitId = (this.queue[this.curr] % 2 === 0 ? this.queue[this.curr] / 2 : (this.queue[this.curr] - 1) / 2 + 3);
        const firstTurnTeam = this.queue[this.curr] % 2; // 0 (PíŒ€) or 1 (EíŒ€)
        const secondTeam = firstTurnTeam === 0 ? this.eTeam : this.pTeam;

        // [ë°¸ëŸ°ìŠ¤ íŒ¨ì¹˜] í›„ê³µ íŒ€ ë³´ì •: ë©´ì—­ ë¶€ì—¬ (ìƒì¡´ë ¥)
        secondTeam.forEach(u => {
            u.addStatus('START_IMMUNITY', 99, 0, null, true);
            // ì‰´ë“œ +100 ì‚­ì œë¨
        });

        // [ì‹ ê·œ] í›„ê³µ ì²« ë²ˆì§¸ ìºë¦­í„°(ì„ ë´‰)ì—ê²Œë§Œ '1í„´ê°„ ë°ë¯¸ì§€ 10% ì¦ê°€' ë¶€ì—¬ (ë°˜ê²© ëŠ¥ë ¥)
        if (secondTeam.length > 0) {
            secondTeam[0].addStatus('DMG_UP_10', 1, 0, null, true);
        }
        
        const teamName = firstTurnTeam === 0 ? 'ì êµ°(í›„ê³µ)' : 'ì•„êµ°(í›„ê³µ)';
        this.log(`<span class='log-sys' style='color:#7986cb;'>ğŸ›¡ï¸ [í›„ê³µ ë³´ì •] ${teamName}ì—ê²Œ ë©´ì—­ ë° <b>ì„ ë´‰ ë”œëŸ¬ ê°•í™”(+10%)</b> ì ìš©!</span>`);

        // [ì¤‘ìš”] ê²Œì„ ë£¨í”„ ì‹œì‘ (ëˆ„ë½ë˜ì—ˆë˜ ë¶€ë¶„)
        this.render();
        this.timer = setTimeout(() => this.turn(), 1000);
    },

turn: function() {
        const battleScreen = document.getElementById('battle-screen');
        if (this.isOver || !battleScreen || battleScreen.style.display === 'none') {
            console.warn("âš ï¸ Turn called but game is over or not visible");
            this.cleanup();
            return;
        }
        
        this.isProcessing = false;
        if (this.isOver) return;

        // [Fix] ì„¸ë‡Œ ëŒ€ìƒ ì‚¬ë§ ì‹œ ì•ˆì „í•˜ê²Œ í•´ì œ
        if (this.isMindControlling && this.isMindControlling.isDead) {
            this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ëŒ€ìƒì´ ì‚¬ë§í•˜ì—¬ ì œì–´ê¶Œì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.</span>");
            this.isMindControlling = null;
            this.currentMCCasterId = null;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }

        const round = this.globalRound;
        const tVal = this.queue[this.curr];
        
        // [Fix] ìœ ë‹› ì •ì˜ ë° null/undefined ì²´í¬ ê°•í™”
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        
        // [Fix] ìœ ë‹›ì´ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì´ë¯¸ ì£½ì—ˆìœ¼ë©´ ì¦‰ì‹œ í„´ ì¢…ë£Œ
        if (!u || u.isDead) {
            console.error('âŒ Turn error: Unit not found or dead', { tVal, u });
            this.endTurn(true);
            return;
        }

// [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ì¸ê²Œì„ íŒ (í„´ ì‹œì‘ ì‹œ)
        if (this.difficulty === 'tutorial' && u && u.team === 0 && !u.isDead) {
            let tip = "";
            if (this.tStage === 1) tip = "Tip: ë¶ˆ(Fire) ìŠ¤í‚¬ë¡œ ë‚˜ë¬´ë¥¼ ê³µê²©í•˜ì„¸ìš”! (1.2ë°°)";
            if (this.tStage === 2) {
                 if(u.base === 'Metal') tip = "Tip: 2ë²ˆ ìŠ¤í‚¬ [ê²°íˆ¬ ì‹ ì²­]ì„ ì¨ì„œ ì–´ê·¸ë¡œë¥¼ ë„ì„¸ìš”!";
                 else if(u.base === 'Water') tip = "Tip: ì‡ ê°€ ë§ëŠ” ë™ì•ˆ ë¬¼ ì†ì„±ìœ¼ë¡œ ë”œì„ ë„£ìœ¼ì„¸ìš”!";
            }
            if (this.tStage === 3) {
                 if(u.base === 'Tree') tip = "Tip: ì•„êµ°ì´ ìœ„í—˜í•˜ë©´ 2ë²ˆ ìŠ¤í‚¬ [ì¹˜ìœ ]ë¥¼ ì“°ì„¸ìš”.";
                 else if(u.base.includes('Metal')) tip = "Tip: ì „ê¸°ì˜ ê³µê²©ì€ ë°˜ë³µí• ìˆ˜ë¡ ê°•í•´ì§‘ë‹ˆë‹¤.";
            }
            if (tip) this.log(`<span style="color:#2ecc71; font-weight:bold;">${tip}</span>`);
        }

        // 2. [ë¡œì§ ì‚­ì œë¨] ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ì–´, ì‚¬ì „ ì¤€ë¹„(MC_READY) ë‹¨ê³„ê°€ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
        // (ì´ê³³ì— ìˆë˜ ë¬¸ë²• ì˜¤ë¥˜ ë° êµ¬ë²„ì „ ë¡œì§ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.)


        // 3. [ê¶Œí•œ íŒì •] ì¡°ì‘ ê¶Œí•œ ì„¤ì • (ëª¨ë“  ìœ ë‹› ê³µí†µ ë¡œì§)
        // ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ íŒ€(0)ì´ë©´ ë‚´ í„´.
        let isMyTurn = (u.team === 0);
        let isPuppetTurn = false;

        // ì„¸ë‡Œ ìƒíƒœ ì²´í¬: í˜„ì¬ í„´ ìœ ë‹›ì´ ì„¸ë‡Œëœ ëŒ€ìƒì´ê³ , ì„¸ë‡Œì˜ ì£¼ì²´ê°€ 'ë‚˜'ì¸ê°€?
        if (this.isMindControlling && this.isMindControlling.id === u.id) {
            // ê°„ë‹¨ í•´ê²°: ë‚´ íŒ€ì´ ì•„ë‹Œë°(ì êµ°ì¸ë°) ì„¸ë‡Œ ë³€ìˆ˜ê°€ ì¼œì ¸ìˆë‹¤ë©´, ë‚´ê°€ ì¡°ì¢…í•˜ëŠ” ê²ƒì„.
            if (u.team !== 0) { 
                isMyTurn = true; 
                isPuppetTurn = true; 
            } else {
                // ë°˜ëŒ€ë¡œ ë‚´ ìœ ë‹›ì´ ì ì—ê²Œ ì„¸ë‡Œë‹¹í–ˆë‹¤ë©´? -> ì¡°ì‘ ê¶Œí•œ ë°•íƒˆ
                isMyTurn = false;
            }
        }

        // 4. AI ê°ì‹œì (Watchdog) ë° ì¢…ë£Œ ì²´í¬
        if (this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            // ì˜¤í”„ë¼ì¸ AIì „ì¼ ë•Œë§Œ ê°•ì œ í„´ ë„˜ê¹€ ê°€ë™
            this.watchdog = setTimeout(() => {
                console.log("AI Stuck. Forcing next.");
                this.endTurn();
            }, 4000); // 3ì´ˆ -> 4ì´ˆë¡œ ì—¬ìœ  í™•ë³´
        } else if (isOnlineMode) {
            // [Fix] ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ì„ì˜ë¡œ í„´ì„ ë„˜ê¸°ì§€ ì•Šë„ë¡ í™•ì‹¤íˆ í•´ì œ
            if (this.watchdog) clearTimeout(this.watchdog);
        }
        if (this.endCheck()) return;

        // 5. [ìˆ˜ì •] í„´ ì‹œì‘ ì§í›„ ë„íŠ¸ ë°ë¯¸ì§€ ì ìš© (ê°€ì¥ ë¨¼ì € ì‹¤í–‰)
        if (!u.isDead) {
            u.resetTurn();
            
            // [ì¤‘ìš”] ë„íŠ¸ ë°ë¯¸ì§€(ë…, í™”ìƒ) ì ìš© ì‹œì 
            const dotLogs = u.tickStatus();
            dotLogs.forEach(log => this.log(log));
            
            // âœ… [Fix] ë„íŠ¸ ë°ë¯¸ì§€ê°€ ë°œìƒí–ˆë‹¤ë©´ ì¦‰ì‹œ í™”ë©´(ì²´ë ¥ë°”)ì„ ê°±ì‹ í•©ë‹ˆë‹¤.
            if (dotLogs.length > 0) this.render();
            
            // ë§Œì•½ ë„íŠ¸ ë°ë¯¸ì§€ë¡œ ì‚¬ë§í–ˆë‹¤ë©´, ì•„ë¬´ í–‰ë™ë„ ëª»í•˜ê³  í„´ ì¢…ë£Œ
            if (u.isDead) {
                this.log(`<span class='log-crit'>â˜ ï¸ [${u.name}] í„´ ì‹œì‘ê³¼ ë™ì‹œì— ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤!</span>`);
                this.endTurn(true);
                return;
            }

            // [í›„ê³µ ë³´ì •] í•´ì œ
            if (u.hasStatus('START_IMMUNITY')) {
                const myTeam = u.team === 0 ? this.pTeam : this.eTeam;
                myTeam.forEach(member => {
                    member.status = member.status.filter(s => s.type !== 'START_IMMUNITY');
                });
                this.log(`<span class='log-sys'>ğŸ”“ [${u.team===0?'ì•„êµ°':'ì êµ°'}] í›„ê³µ ë³´í˜¸ë§‰ í•´ì œ!</span>`);
                this.render();
            }
        }

        // 5-2. í–‰ë™ ë¶ˆê°€(CC) ì²´í¬ (ìš°ì„ ìˆœìœ„: ì‚¬ë§ > ê¸°ì ˆ/ë¹™ê²° > ì„¸ë‡Œ)
        const hasCC = u.hasStatus('STUN') || u.hasStatus('FREEZE') || u.hasStatus('SLEEP');
        
        if (hasCC) {
            UI.floatText(u, "í–‰ë™ë¶ˆê°€", "ft-miss");
            this.log(`<span class='log-crit'>ğŸš« [${u.name}] ìƒíƒœì´ìƒìœ¼ë¡œ í–‰ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
            
            // [Fix] ì„¸ë‡Œ ì˜ˆì•½(MC_WAIT) ì¤‘ ê¸°ì ˆ ì‹œ ì˜ˆì•½ ì·¨ì†Œ
            if (u.hasStatus('MC_WAIT')) {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸŒ€ [${u.name}] ê¸°ì ˆí•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ ë¶ˆë°œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
            
            // [Fix] ì´ë¯¸ ì¡°ì¢… ì¤‘(ì„¸ë‡Œ ìƒíƒœ)ì¼ ë•Œ ê¸°ì ˆí•˜ë©´, í„´ ê¼¬ì„ ë°©ì§€ë¥¼ ìœ„í•´ ì¤‘ë³µ ì‹¤í–‰ ì°¨ë‹¨ í›„ í„´ ì¢…ë£Œ
            this.isProcessing = true; 
            setTimeout(() => {
                this.isProcessing = false; // íƒ€ì„ì•„ì›ƒ í›„ í•´ì œ
                this.endTurn();
            }, 1000);
            return;
        }
        
        // (ì—¬ê¸° ìˆë˜ ì¤‘ë³µ ì½”ë“œë“¤ì„ ê¹¨ë—ì´ ì§€ì› ìŠµë‹ˆë‹¤)

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        // 6. [ì„¸ë‡Œ ë°œë™] í„´ í•˜ì´ì¬í‚¹ (ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨)
        const mcWaitStatus = u.status.find(s => s.type === 'MC_WAIT');
        if (mcWaitStatus) {
            // ì‹œì „ì(ì£¼ì¸) í™•ì¸
            let caster = null;
            if (mcWaitStatus.sourceId !== undefined && mcWaitStatus.sourceId !== -1) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                caster = allUnits.find(unit => unit.id === mcWaitStatus.sourceId);
            }

                    // ì‹œì „ìê°€ ë‚´ íŒ€ì´ë©´ -> ë‚´ í„´ìœ¼ë¡œ ê°•ì œ ì „í™˜ (ëª¨ë“  ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥)
        if (caster && !caster.isDead && caster.team === 0) {
            // [ìˆ˜ì •] ì„¸ë‡Œ ì„±ê³µ ì‹œ, ì´ë¯¸ ëŒì•„ê°€ê³  ìˆëŠ” AI ê°ì‹œì(Watchdog)ë¥¼ ë°˜ë“œì‹œ êº¼ì•¼ í•¨
            if (this.watchdog) clearTimeout(this.watchdog);

            isMyTurn = true;
            isPuppetTurn = true;
            this.isMindControlling = u; // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
            this.currentMCCasterId = caster.id; // [ì¶”ê°€] ì‹œì „ì ID ì €ì¥ (ì‚¬ë§ íŒì •ìš©)

            this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°° ì„±ê³µ! ì œì–´ê¶Œì„ íƒˆì·¨í–ˆìŠµë‹ˆë‹¤.</span>`);

                UI.floatText(u, "ì œì–´ê¶Œ íšë“", "ft-crit");
                
                // ìƒíƒœ ì œê±° (ì´ë²ˆ í„´ì— ë°”ë¡œ í–‰ë™í•˜ë¯€ë¡œ ìƒíƒœ ì•„ì´ì½˜ ì‚­ì œ)
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            } 
            // ì‹œì „ìê°€ ì  íŒ€ì´ë©´ -> ì ì´ ì¡°ì¢… (ë‚´ ì…ë ¥ ì°¨ë‹¨)
            else if (caster && !caster.isDead && caster.team === 1) {
                isMyTurn = false;
                this.isMindControlling = u;
                
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì ì—ê²Œ ì¡°ì¢…ë‹¹í•©ë‹ˆë‹¤!</span>`);
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            }
            // ì‹œì „ìê°€ ì£½ì—ˆìœ¼ë©´ í•´ì œ
            else {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ìê°€ ì‚¬ë§í•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤.</span>`);
            }
            
            // ì£¼ì˜: ê¸°ì¡´ì˜ 'return'ì„ ì‚­ì œí•˜ì—¬ ì•„ë˜ì˜ input() ë¡œì§ìœ¼ë¡œ íë¥´ê²Œ í•¨
        }

        // 7. [UI ì—…ë°ì´íŠ¸] ë°°ë„ˆ ë° ë©”ì‹œì§€
        let turnName = u.name.split(' ')[0];
        let indicatorText = `Round ${round} : ${turnName}`;
        
        if (isPuppetTurn) {
            UI.showTurnBanner(true);
            indicatorText = `ğŸ§  ì •ì‹  ì§€ë°° ì¤‘! [${turnName}] ì¡°ì¢…í•˜ì„¸ìš”!`;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #d500f9";
        } else if (isMyTurn) {
            UI.showTurnBanner(true);
            if (this.mode === 'pvp') indicatorText += " (ë‚˜)";
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ff80ab";
        } else {
            UI.showTurnBanner(false);
            if (this.mode === 'pvp') indicatorText = "ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
            if (this.isMindControlling && u.id === this.isMindControlling.id && u.team === 0) {
                 indicatorText = "ğŸ§  ë‚´ ìœ ë‹›ì´ ì¡°ì¢…ë‹¹í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
            }
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }
        
        document.getElementById('turn-indicator').innerText = indicatorText;
        // [ì‚­ì œ] ìƒˆ ì—”ì§„ì€ ê³¡ ë³€ê²½ ë°©ì‹ì´ë¯€ë¡œ í…œí¬ ì¡°ì ˆ ë¶ˆí•„ìš”
        // const danger = ... 
        // MusicEngine.play('Crisis_Track'); // í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì„œ ìœ„ê¸° ì „ìš© ê³¡ ì¬ìƒ ê°€ëŠ¥
        this.turnCount++;

        // 8. [ì…ë ¥ í™œì„±í™” ì—¬ë¶€ ê²°ì •]
        if (isMyTurn || this.difficulty === 'local') {
            this.input(u);
            // ë§Œì•½ ê¼­ë‘ê°ì‹œ í„´ì´ë¼ë©´ íˆ´íŒ ë„ì›Œì£¼ê¸°
            if (isPuppetTurn) {
                setTimeout(() => {
                    const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                    const el = document.getElementById(cardId);
                    if(el) UI.showTooltip(u, el);
                }, 100);
            }
        } else {
            this.noInput();
            if (this.mode !== 'pvp') {
                // [Fix] ê¸°ì¡´ íƒ€ì´ë¨¸ ì œê±° í›„ ì‹¤í–‰ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
                if (this.timer) clearTimeout(this.timer);
                this.timer = setTimeout(() => this.ai(u), 800);
            }
        }
    },

    render: function() {
        // [ìˆ˜ì • ì™„ë£Œ] íƒ€ì„ë¼ì¸ ì½”ë“œ ì™„ì „ ì œê±°ë¨
        
        // 1. ìœ ë‹› ê·¸ë¦¬ê¸°
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            if (!row) return;

            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if (!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });
            
            team.forEach((u) => {
                const cardId = tid === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }
                
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isSuper ? 'super-hero' : ''} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;

                // ì´ë²¤íŠ¸ ì—°ê²°
                d.onclick = (e) => {
                    if (Game.selectedSkillIdx !== -1) return;
                    if (u.team === 0) { UI.showEmoteMenu(u, d); e.stopPropagation(); }
                };

                // [ì‹ ê·œ] ëª¨ë°”ì¼ 2ì´ˆ ë¡±í„°ì¹˜ êµ¬í˜„
                let longPressTimer = null;
                let isTouching = false; // í„°ì¹˜ ì¤‘ì¸ì§€ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

                d.ontouchstart = () => {
                    isTouching = true;
                    longPressTimer = setTimeout(() => {
                        UI.showTooltip(u, d); // 2ì´ˆ ìœ ì§€ ì‹œ íˆ´íŒ í‘œì‹œ
                    }, 2000);
                };

                d.ontouchend = () => {
                    if (longPressTimer) clearTimeout(longPressTimer); // ì† ë–¼ë©´ íƒ€ì´ë¨¸ ì·¨ì†Œ
                    setTimeout(() => isTouching = false, 500); // í”Œë˜ê·¸ í•´ì œ ì§€ì—° (ë§ˆìš°ìŠ¤ì—”í„° ë°©ì§€)
                };

                d.ontouchmove = () => {
                    if (longPressTimer) clearTimeout(longPressTimer); // ìŠ¤í¬ë¡¤ ì‹œ íƒ€ì´ë¨¸ ì·¨ì†Œ
                };

                d.onmouseenter = () => {
                     // [ìˆ˜ì •] í„°ì¹˜(íƒ­) ë™ì‘ ì¤‘ì¼ ë•ŒëŠ” ì¦‰ì‹œ íˆ´íŒ í‘œì‹œë¥¼ ë§‰ìŒ
                     if (isTouching) return;

                     if (Game.selectedSkillIdx !== -1 && tid !== 0 && !Game.isProcessing) {
                         const pred = Game.predictDmg(u);
                         if (pred > 0) {
                            const bar = d.querySelector('.status-bar');
                            if (bar) {
                                const preview = document.createElement('div');
                                preview.className = 'hp-preview';
                                const currentHpPct = (u.hp / u.maxHp) * 100;
                                const dmgPct = Math.min(currentHpPct, (pred / u.maxHp) * 100);
                                preview.style.left = Math.max(0, currentHpPct - dmgPct) + '%';
                                preview.style.width = dmgPct + '%';
                                bar.appendChild(preview);
                            }
                        }
                     }
                     UI.showTooltip(u, d);
                };

                d.onmouseleave = () => { 
                    UI.hideTooltip(); 
                    const p = d.querySelector('.hp-preview'); 
                    if(p) p.remove(); 
                    if(longPressTimer) clearTimeout(longPressTimer); 
                };

                // ìƒíƒœì´ìƒ íƒœê·¸ ìƒì„±
                let tags = u.status.map(s => {
                    let c = 'tag';
                    const map = {'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn','BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown','BLIND':'blind','IMMUNITY':'immunity','HEAL_DOWN':'healdown','LIGHT_MIGHT':'atkup','LIFESTEAL_BUFF':'lifesteal','ATK_BUFF_SMALL':'atkup_s','START_IMMUNITY':'start-immunity','ROOT_GUARD':'bind','MC_WAIT':'mc-wait','MC_READY':'mc-ready','EARTH_RECOIL':'atkdown'};
                    if (s.type.includes('PROVOKED')) c += ' taunt';
                    else if (s.type.startsWith('KARMA_VICTIM')) c += ' karma';
                    else if (map[s.type]) c += ` ${map[s.type]}`;

                // [ìˆ˜ì •] ì¹˜ìœ  ê°ì†Œ ìˆ˜ì¹˜ë³„ í´ë˜ìŠ¤ ë° í…ìŠ¤íŠ¸ ì ìš©
                if (s.type === 'HEAL_DOWN') {
                    if (s.val <= 20) c += ' heal-20';       // ë…ê°€ìŠ¤(ë³´ë¼)
                    else if (s.val <= 50) c += ' heal-50';  // ëª¨ë˜ì§€ì˜¥(ì£¼í™©)
                    else c += ' heal-critical';             // ì¤‘ì²©ë¨(ë¹¨ê°•)
                }

                let txt = s.type;
                const tMap = {'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ','TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…','IMMUNITY':'ë©´ì—­','HEAL_DOWN':`ğŸ’”-${s.val}%`,'LIGHT_MIGHT':'ê³µê²©â†‘','LIFESTEAL_BUFF':'ğŸ©¸í¡í˜ˆ','ATK_BUFF_SMALL':'ğŸ”¥ê³µê²©â†‘','START_IMMUNITY':'ğŸ›¡ï¸ì„ ê³µë°©ì–´','ROOT_GUARD':'ğŸªµìˆ˜í˜¸','MC_WAIT':'ğŸŒ€ì„¸ë‡Œì¤‘','MC_READY':'ğŸ§ ì¡°ì¢…','EARTH_RECOIL':'ğŸ’”ë°˜ë™'};

                if (s.type.includes('PROVOKED')) txt = 'ë„ë°œ';
                else if (s.type.startsWith('KARMA_VICTIM')) txt = 'ğŸ‘ï¸ì—…ë³´';
                else if (tMap[s.type]) txt = tMap[s.type];

                    if (s.turn < 90) txt += ` <b style="font-family:sans-serif; margin-left:1px;">${s.turn}</b>`;
                    return `<span class="${c}">${txt}</span>`;
                }).join('');

                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60;">ğŸ”—Link</span>`;

                const key = u.getKey();
                const imgUrl = IMAGE_DB[key] || IMAGE_DB['Default'];
                
                const hpPct = (u.hp / u.maxHp) * 100;
                let hpColor = '#66bb6a';
                if (hpPct <= 25) hpColor = '#ef5350';
                else if (hpPct <= 50) hpColor = '#ffb74d';

                let displayName = u.name.split(' ')[0];
                if (u.isSuper) {
                    const emo = EMOTION_DB[u.getKey()];
                    if (emo) displayName = `[${emo.t}] ${displayName}`;
                }

                let iconsHtml = '';
                if (ATTR[u.base]) iconsHtml += `<div class="tiny-icon">${ATTR[u.base].i}</div>`;
                if (u.extra && ATTR[u.extra]) iconsHtml += `<div class="tiny-icon">${ATTR[u.extra].i}</div>`;
                if (iconsHtml === '' && SKILL_DB[key]) iconsHtml = `<div class="tiny-icon">${SKILL_DB[key].icon}</div>`;

                // [ì‹ ê·œ] ìƒì„± í‘œì‹œê¸° ë¡œì§
                // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì)ì´ ëˆ„êµ¬ì¸ì§€ í™•ì¸
                const tVal = this.queue[this.curr];
                const activeUnit = (tVal !== undefined) ? (tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)]) : null;
                
                let matchupBadge = '';
                // ì¡°ê±´: í˜„ì¬ ë‚´ í„´(activeUnit.team === 0)ì´ê³ , ê·¸ë¦¬ëŠ” ëŒ€ìƒì´ ì (u.team === 1)ì¼ ë•Œ
                if (activeUnit && activeUnit.team === 0 && u.team === 1 && !u.isDead) {
                    const sim = this.calc(activeUnit, u);
                    if (sim.v > 1.0) { // ìœ ë¦¬í•¨ (1.2ë°° ì´ìƒ)
                        // [ì¬ìˆ˜ì •] ìš°ì¸¡ì€ ë²ˆê°œìŠ¤íƒ(âš¡)ê³¼ ê²¹ì¹  ìœ„í—˜ì´ ìˆì–´, ì¢Œì¸¡ ì†ì„± ì•„ì´ì½˜ ì•„ë˜(top:34px)ë¡œ ì´ë™
                        matchupBadge = `<div style="position:absolute; top:34px; left:4px; background:#00e676; color:#004d40; font-size:10px; padding:2px 6px; border-radius:10px; font-weight:900; z-index:20; box-shadow:0 2px 4px rgba(0,0,0,0.3); border:2px solid #fff; animation: jelly-bounce 1s infinite;">âš¡ì•½ì </div>`;
                    } else if (sim.v < 1.0) { // ë¶ˆë¦¬í•¨ (0.8ë°° ì´í•˜)
                        // [ì¬ìˆ˜ì •] ìš°ì¸¡ì€ ë²ˆê°œìŠ¤íƒ(âš¡)ê³¼ ê²¹ì¹  ìœ„í—˜ì´ ìˆì–´, ì¢Œì¸¡ ì†ì„± ì•„ì´ì½˜ ì•„ë˜(top:34px)ë¡œ ì´ë™
                        matchupBadge = `<div style="position:absolute; top:34px; left:4px; background:#ff5252; color:#fff; font-size:10px; padding:2px 6px; border-radius:10px; font-weight:900; z-index:20; box-shadow:0 2px 4px rgba(0,0,0,0.3); border:2px solid #fff;">ğŸ›¡ï¸ì €í•­</div>`;
                    }
                }

                // [ì²´ë ¥ë°” UI ë³€ê²½ í•µì‹¬ ë¶€ë¶„] + ìƒì„± ë±ƒì§€(${matchupBadge}) ì¶”ê°€ë¨
                const innerHTML = `
                    <div class="unit-img-bg" style="background-image: url('${imgUrl}');">
                        <div style="position:absolute; inset:0; background:${'transparent'};"></div>
                    </div>
                    ${matchupBadge} 
                    <div class="card-badge">${iconsHtml}</div>
                    <div class="card-atk">âš”ï¸ ${u.getAtk()}</div>
                ${u.elecStacks > 0 ? `<div class="elec-badge" style="top:30px;">âš¡${u.elecStacks}</div>` : ''}
                ${u.treeStack > 0 ? `<div class="tree-badge" style="top:30px;">ğŸŒ³${u.treeStack}</div>` : ''}
                <div class="tag-container">${tags}</div>
                    <div class="unit-info-overlay">
                        <div class="card-name" style="${u.isSuper ? 'color:#ffd700;' : ''}">${displayName}</div>
                        <div class="status-bar">
                            <div class="hp-fill" style="width:${hpPct}%; background:${hpColor};"></div>
                            <div class="shield-fill" style="width:${Math.min(100, (u.shield/u.maxHp)*100)}%"></div>
                        </div>
                        <div style="font-size:11px; font-weight:bold; text-align:right; color:#fff; text-shadow:1px 1px 1px rgba(0,0,0,0.8); margin-top:2px; letter-spacing:0.5px;">
                            ${u.hp} / ${u.maxHp} ${u.shield > 0 ? `<span style="color:#e1bee7;">(+${u.shield})</span>` : ''}
                        </div>
                    </div>
                `;
                
                if (d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };

        draw('player-row', this.pTeam, 0);
        draw('enemy-row', this.eTeam, 1);
    },

endTurn: function(isFast = false) {
        if (this.isOver) return;
        
        // [Fix] íƒ€ì´ë¨¸ ëˆ„ì  ë°©ì§€ - ëª¨ë“  íƒ€ì´ë¨¸ ëª…ì‹œì ìœ¼ë¡œ ì •ë¦¬
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.watchdog) {
            clearTimeout(this.watchdog);
            this.watchdog = null;
        }
        
        // í˜„ì¬ í„´ ì£¼ì¸ ìœ ë‹› ì°¾ê¸°
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // [ë°¸ëŸ°ìŠ¤ ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§
        // "í˜„ì¬ í„´ì„ ë§ˆì¹œ ìœ ë‹›(u)"ì´ "ì¡°ì¢… ì¤‘ì¸ ìœ ë‹›(isMindControlling)"ì¼ ë•Œë§Œ í•´ì œ
        if (this.isMindControlling && u && u.id === this.isMindControlling.id) {
             const puppet = this.isMindControlling;
             
             this.log(`<span class='log-sys'>ğŸ•Šï¸ [${puppet.name}] ì¡°ì¢… ì™„ë£Œ. ì •ì‹  ì§€ë°°ê°€ í•´ì œë©ë‹ˆë‹¤.</span>`); // ë©”ì‹œì§€ ë³€ê²½
             UI.floatText(puppet, "ì§€ë°° ì¢…ë£Œ", "ft-miss"); // í…ìŠ¤íŠ¸ ë³€ê²½
             
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             this.isMindControlling = null;
             
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab";
        }

        if (u && !u.isDead) u.decayStatus();
        
        [...this.pTeam, ...this.eTeam].forEach(u => {
            if (u.hp <= 0) this.die(u)
        });
        
        this.curr = (this.curr + 1) % 6;
        
        // [ìˆ˜ì •] íê°€ í•œ ë°”í€´ ëŒì•„ 0ë²ˆ(ì²« ìˆœì„œ)ì´ ë˜ë©´ ë¼ìš´ë“œ ì¦ê°€
        if (this.curr === 0) {
            this.globalRound++;

            // [ìˆ˜ì •] ë°ìŠ¤ë§¤ì¹˜ ë¡œì§ (globalRound ê¸°ì¤€)
            if (this.globalRound > 15) {
                [...this.pTeam, ...this.eTeam].forEach(u => {
                    if (!u.isDead) u.atk += 10;
                });
                this.log(`<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! (Round ${this.globalRound}) ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>`);
            }
        }
        
        this.render();
        const delay = isFast ? 100 : 1500;

        // [ìˆ˜ì •] íƒ€ì´ë¨¸ ì‹¤í–‰ ì§ì „ì—ë„ ê²Œì„ ì¢…ë£Œ ì—¬ë¶€(Kill Switch) í™•ì¸
        if (this.isOver) return;

        this.timer = setTimeout(() => {
            // [ì•ˆì „ì¥ì¹˜] ëŒ€ê¸° ì‹œê°„ ë™ì•ˆ ê²Œì„ì´ ë¦¬ì…‹ë˜ì—ˆëŠ”ì§€ í•œ ë²ˆ ë” í™•ì¸
            if (this.isOver) return;
            this.turn();
        }, delay);
    }, 

    // [ìˆ˜ì •] async í‚¤ì›Œë“œ ì¶”ê°€ (íˆ¬ì‚¬ì²´ ëŒ€ê¸°ìš©)
    execute: async function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el => el.onclick = null);
        AudioSys.speak(atk);

        if (isOnlineMode && !isRemote) {
            const isMindControlAction = this.isMindControlling && atk.id === this.isMindControlling.id;
            if (atk.team !== 0 && !isMindControlAction) {
                alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!");
                return;
            }
            netRndBuffer = [];
        }

        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];
        if (!logic) {
            this.endTurn(); 
            return;
        }

        if (sIdx > 0 && !def) {
             const needsTarget = !['SELF', 'SELF_BUFF', 'ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(SKILL_DB[key].type);
             if (needsTarget) {
                 this.log(`<span class='log-sys'>âš ï¸ [${atk.name}] ëŒ€ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
                 this.endTurn();
                 return;
             }
        }

        // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ (íƒ€ê²Ÿì´ ìˆê³ , ìì‹ ì´ ì•„ë‹ ë•Œ)
        if (def && atk.id !== def.id) {
            const skillType = (sIdx === 0) ? 'ATTACK' : SKILL_DB[key].type;
            // ìŠ¤í‚¬ íƒ€ì…ì´ ë²„í”„/íì´ ì•„ë‹ˆê±°ë‚˜, íì´ë¼ë„ ì ì—ê²Œ ì“¸ ë•Œ(ì„¸ë‡Œ)ëŠ” ê³µê²© ì´í™íŠ¸
            // ê°„ë‹¨í•˜ê²Œ ì•„ì´ì½˜ ë§¤í•‘
            let pIcon = 'âœ¨';
            if (atk.base === 'Fire') pIcon = 'ğŸ”¥';
            else if (atk.base === 'Water') pIcon = 'ğŸ’§';
            else if (atk.base === 'Tree') pIcon = 'ğŸƒ';
            else if (atk.base === 'Metal') pIcon = 'âš”ï¸';
            else if (atk.base === 'Earth') pIcon = 'ğŸª¨';
            else if (atk.base === 'Dark') pIcon = 'ğŸ’€';
            else if (atk.base === 'Normal') pIcon = 'ğŸ‘Š';
            
            // íŠ¹ìˆ˜ ìŠ¤í‚¬ ì•„ì´ì½˜ ì˜¤ë²„ë¼ì´ë“œ
            if (sIdx === 1 && atk.base === 'Metal-Light') pIcon = 'â˜£ï¸'; // ë…ê°€ìŠ¤
            if (sIdx === 2 && atk.base === 'Water-Dark') pIcon = 'â„ï¸'; // ì ˆëŒ€ì˜ë„

            // ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸° (0.4ì´ˆ)
            await UI.fireProjectile(atk, def, pIcon);
        }
        
        // âœ… try-catchë¡œ ìŠ¤í‚¬ ì‹¤í–‰ ë³´í˜¸
        try {
            const playedSound = logic.useSkill(atk, def, sIdx, this);
            if (!playedSound) AudioSys.play('SKILL');

            // [ê°ì„± ì²´í¬] ìŠ¤í‚¬ ì‚¬ìš© í›„ í†µê³„ ê°±ì‹  ì‹œ ê°ì„± í™•ì¸
            atk.checkAwakening();

            // âœ… ì„±ê³µ ì‹œì—ë§Œ ë„¤íŠ¸ì›Œí¬ ì „ì†¡
            if (isOnlineMode && !isRemote) {
                socket.emit('action', {
                    room: myRoom,
                    attackerId: atk.id,
                    attackerTeam: atk.team,
                    targetId: def ? def.id : null,
                    targetTeam: def ? def.team : null,
                    skillIdx: sIdx,
                    mcState: { // ì„¸ë‡Œ ìƒíƒœ ë™ê¸°í™”
                        isMindControlling: !!this.isMindControlling,
                        mcTargetId: this.isMindControlling ? this.isMindControlling.id : null,
                        mcCasterId: this.currentMCCasterId
                    }
                });
            }
        } catch(e) {
            console.error('âŒ Skill execution failed:', e);
            this.log(`<span class='log-sys' style='color:red;'>âš ï¸ [${atk.name}] ìŠ¤í‚¬ ì‹¤í–‰ ì˜¤ë¥˜ ë°œìƒ</span>`);
            netRndBuffer = []; // ì‹¤íŒ¨ ì‹œ ë²„í¼ ì´ˆê¸°í™”
        }
        
        // [ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ì€ endTurn()ìœ¼ë¡œ ì´ë™ë¨
        this.endTurn();
    },

    reset: function() {
        // [Fix] ê°•ì œ ì¢…ë£Œ í‚¬ ìŠ¤ìœ„ì¹˜ ê°€ë™
        this.isOver = true; // ì§„í–‰ ì¤‘ì¸ ë¡œì§ì´ ì¦‰ì‹œ ë©ˆì¶”ë„ë¡ í”Œë˜ê·¸ ì„¤ì •
        this.isProcessing = false;

        // [Fix] íƒ€ì´ë¨¸ ì™„ì „ ì •ë¦¬ - ëª¨ë“  íƒ€ì´ë¨¸ ëª…ì‹œì ìœ¼ë¡œ ì •ë¦¬
        if (this.timer) { 
            clearTimeout(this.timer); 
            this.timer = null; 
        }
        if (this.watchdog) { 
            clearTimeout(this.watchdog); 
            this.watchdog = null; 
        }

        // ì˜¤ë””ì˜¤ ì •ë¦¬
        MusicEngine.stop();

        // UI ì •ë¦¬
        UI.closeModal();
        document.getElementById('battle-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));

        // [Fix] ë°ì´í„° ì´ˆê¸°í™” - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
        this.selected = [];
        this.pTeam = []; // íŒ€ ì •ë³´ë„ ë‚ ë ¤ì„œ ìœ ë ¹ ì°¸ì¡° ë°©ì§€
        this.eTeam = [];
        this.isMindControlling = null;
        this.currentMCCasterId = null;

        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        this.pool = []; 

        // ì˜¨ë¼ì¸ ëª¨ë“œ ì •ë¦¬ ì¶”ê°€
        if (isOnlineMode) {
            isOnlineMode = false;
            globalRNG = null;
            gameSeed = null;
        }
        
        // [Fix] ì™„ì „í•œ ì¬ì´ˆê¸°í™”ë¥¼ ìœ„í•´ window.onload ëŒ€ì‹  init ì§ì ‘ í˜¸ì¶œ
        this.init();
    },
    // [ê°ì„± ì²´í¬] ìŠ¤íƒ¯ ê¸°ë¡ ì‹œ ê°ì„± í™•ì¸
    recordStat: function(unit, type, amount) {
        if (!unit || amount <= 0) return;
        if (type === 'dmg') unit.stats.dmg += amount;
        if (type === 'shield') unit.stats.shieldGiven += amount;
        if (type === 'heal') unit.stats.heal += amount;
        unit.checkAwakening();
    },
    input: function(u) {
    // ì„¸ë‡Œ ìƒíƒœ UI í‘œì‹œ
    const cp = document.querySelector('.control-panel');
    if (cp) {
        cp.style.borderTop = this.isMindControlling ? "5px solid #d500f9" : "5px solid #ff80ab";
    }
    
    const k = u.getKey();
    const s = SKILL_DB[k];
    
    // ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ ë°©ì–´ ì½”ë“œ
    if (!s) {
        console.error("âŒ SKILL_DB missing for key:", k, "Unit:", u.name);
        document.getElementById('p-icon').innerText = 'â“';
        document.getElementById('p-desc').innerText = 'ERROR: ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ';
        document.getElementById('sk-0').innerHTML = '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br><span class="skill-desc">1.0ë°°</span>';
        document.getElementById('sk-1').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        document.getElementById('sk-2').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        [0, 1, 2].forEach(i => document.getElementById(`sk-${i}`).disabled = true);
        this.log(`<span class='log-sys'>âš ï¸ [${u.name}] ìŠ¤í‚¬ ì •ë³´ ì˜¤ë¥˜ ë°œìƒ</span>`);
        return;
    }
    
    const silenced = u.hasStatus('SILENCE');
    
    // íŒ¨ì‹œë¸Œ ì •ë³´
    document.getElementById('p-icon').innerText = s.icon || 'â“';
    document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
    
    // ìŠ¤í‚¬ ë²„íŠ¼ ì •ë³´
    document.getElementById('sk-0').innerHTML = 
        '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br>' +
        '<span class="skill-desc">1.0ë°° í”¼í•´</span>';
    
    document.getElementById('sk-1').innerHTML = 
        '<span class="skill-name">' + (s.s1 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s1d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    document.getElementById('sk-2').innerHTML = 
        '<span class="skill-name">' + (s.s2 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s2d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ
    document.getElementById('sk-0').disabled = false;
    document.getElementById('sk-1').disabled = silenced;
    
    // S2 ë¹„í™œì„±í™” ì¡°ê±´
    let sk2Disable = silenced;
    
    if (k === 'Fire-Light' && (u.s2Count || 0) >= 5) {
        sk2Disable = true;
    }
    
    if (k === 'Tree-Dark') {
        const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
        const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
        if (aliveAllies.length === 0 || u.linkedAllyId !== -1) {
            sk2Disable = true;
        }
    }
    
    document.getElementById('sk-2').disabled = sk2Disable;
    
    if (silenced) {
        this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
    }
    
    // ë„ë°œ í™•ì¸ (ì„¸ë‡Œ ìƒíƒœë¼ë©´ ë„ë°œ ë¬´ì‹œ)
    const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
    const isBrainwashed = this.isMindControlling && this.isMindControlling.id === u.id;

    if (provoked && !isBrainwashed) { // ğŸ§  ì„¸ë‡Œ ì•„ë‹ ë•Œë§Œ ë„ë°œ ì ìš©
        const targetId = parseInt(provoked.type.split('_')[2]);
        const enemies = u.team === 0 ? this.eTeam : this.pTeam;
        const allies = u.team === 0 ? this.pTeam : this.eTeam;
        const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
        
        if (!target || target.isDead) {
            u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
            this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
            UI.floatText(u, "ììœ !", "ft-heal");
            this.render();
        } else {
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput();
            setTimeout(() => this.execute(u, target, 0), 1000);
            return; // ê°•ì œ ê³µê²© ì‹œ í•¨ìˆ˜ ì¢…ë£Œ
        }
    } else if (provoked && isBrainwashed) {
        this.log(`<span class='log-sys'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°°ë¡œ ì¸í•´ ë„ë°œì„ ë¬´ì‹œí•©ë‹ˆë‹¤.</span>`);
    }
    
    this.selectedSkillIdx = -1;
},
    noInput: function() {
        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            b.disabled = true;
            b.classList.remove('selected');
        });
    },
    prepareSkill: function(idx) {
    this.debugLog('Skill Button Clicked', { skillIndex: idx });

    // âœ… ì´ì „ íƒ€ê²ŸíŒ… ì´ˆê¸°í™” (ì¤‘ë³µ ë°©ì§€)
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    [0, 1, 2].forEach(i => {
        const b = document.getElementById(`sk-${i}`);
        if (i === idx) b.classList.add('selected');
        else b.classList.remove('selected');
    });
    
    this.selectedSkillIdx = idx;
        
        // í˜„ì¬ í–‰ë™ ì£¼ì²´ ì°¾ê¸°
        let u;
        if (this.isMindControlling) {
            u = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }

        // [ë””ë²„ê·¸] í–‰ë™ ìœ ë‹› ì •ë³´ ì¶œë ¥
        if (u) this.debugLog('Acting Unit Identified', { name: u.name, id: u.id, isMindControlled: !!this.isMindControlling });

        const k = u.getKey();
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';

        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì¸ë±ìŠ¤ë³„ íƒ€ê²Ÿ íƒ€ì… ëª…í™•í™”
        if (idx === 0) {
            targetType = 'ENEMY'; // í‰íƒ€ëŠ” ë¬´ì¡°ê±´ ê³µê²©
        } else if (idx === 1) {
            // S1 ìŠ¤í‚¬ë“¤ì˜ íƒ€ê²Ÿ íƒ€ì… ì„¤ì •
            // [ìˆ˜ì •] Tree-Darkì˜ S1(ê°€ì‹œì°Œë¥´ê¸°)ì€ ê³µê²©ê¸°ì´ë¯€ë¡œ ENEMYì—¬ì•¼ í•¨
            if (['Tree'].includes(k)) targetType = 'SELF_BUFF';
            else if (['Fire-Light'].includes(k)) targetType = 'ALL_ALLY'; // í¡í˜ˆ ë¶€ì—¬ëŠ” ì „ì²´ ë²„í”„
            else if (['Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; // ë””ë²„í”„ ê³µê²©
            else targetType = 'ENEMY'; // ë‚˜ë¨¸ì§€ëŠ” ëŒ€ë¶€ë¶„ ê³µê²©
        } else if (idx === 2) {
            // [Fix] ë‚˜ë¬´(Tree) S2ëŠ” ì•„êµ° íšŒë³µ ìŠ¤í‚¬ì´ë¯€ë¡œ ê°•ì œ ë³€ê²½
            if (k === 'Tree') targetType = 'ALLY';
            else targetType = s.target || 'ENEMY';
        }

        // íƒ€ê²ŸíŒ… í•¨ìˆ˜ í˜¸ì¶œ
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
    // 1. í–‰ë™ ìœ ë‹› í™•ì •
    if (!actingUnit) {
        if (this.isMindControlling) {
            actingUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            actingUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }
    }

    // 2. ê¸°ì¡´ íƒ€ê²ŸíŒ… ì´ˆê¸°í™”
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    // 3. ìŠ¤í‚¬ íƒ€ì… ë¶„ë¥˜
    const SUPPORT_TYPES = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF', 'TARGET_BUFF', 'HEAL', 'BUFF'];
    const isSupportSkill = SUPPORT_TYPES.includes(targetType);
    const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
    const isSelfOnly = ['SELF', 'SELF_BUFF'].includes(targetType);

    // 4. íŒ€ ì •ì˜ (ì›ë˜ ì†Œì† ê¸°ì¤€)
    const originalAllies = actingUnit.team === 0 ? this.pTeam : this.eTeam;
    const originalEnemies = actingUnit.team === 0 ? this.eTeam : this.pTeam;

    let finalTargets = [];

    // 5. ì„¸ë‡Œ ì—¬ë¶€ì— ë”°ë¥¸ íƒ€ê²Ÿ ê²°ì •
    const isMindControlled = this.isMindControlling && actingUnit.id === this.isMindControlling.id;
    
    if (isSelfOnly) {
        // ìê°€ ë²„í”„ëŠ” ì–¸ì œë‚˜ ìì‹ ì—ê²Œë§Œ
        finalTargets = [actingUnit];
    } 
    else if (isMindControlled) {
        // [ì„¸ë‡Œ ìƒíƒœ] - í”¼ì•„ì‹ë³„ ì—­ì „
        if (isSupportSkill) {
            // í/ë²„í”„ -> ì êµ°(í˜„ì¬ ë‚˜ë¥¼ ì¡°ì¢…í•˜ëŠ” íŒ€)ì—ê²Œ ì‚¬ìš©
            finalTargets = originalEnemies.filter(u => !u.isDead);
        } else {
            // ê³µê²© -> ì•„êµ°(ë‚˜ì˜ ì›ë˜ ë™ë£Œ)ì„ ê³µê²©
            // [ê°œì„ ] ìí•´(Self Attack)ë„ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ì„ í¬í•¨
            finalTargets = originalAllies.filter(u => !u.isDead);
            // ìí•´ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ë„ í¬í•¨ (ì¤‘ë³µ ë°©ì§€ ì²´í¬)
            if (!finalTargets.some(t => t.id === actingUnit.id)) {
                finalTargets.push(actingUnit);
            }
        }
    } else {
        // [ì •ìƒ ìƒíƒœ]
        if (isSupportSkill) {
            finalTargets = originalAllies.filter(u => !u.isDead);
        } else {
            // ì êµ° + "ì„¸ë‡Œë‹¹í•´ì„œ ë°°ì‹ ìê°€ ëœ ì•„êµ°"ë„ ê³µê²© ê°€ëŠ¥í•´ì•¼ í•¨
            const realEnemies = originalEnemies.filter(u => !u.isDead);
            const traitors = originalAllies.filter(u => !u.isDead && (u.hasStatus('MC_WAIT') || u.hasStatus('MC_READY')));
            finalTargets = [...realEnemies, ...traitors];
        }
    }

    // 6. Tree-Dark ì˜ˆì™¸ ì²˜ë¦¬
    if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2) {
        // ì˜í˜¼ê²°ì†ì€ ìì‹  ì œì™¸ (ë‹¨, ì„¸ë‡Œ ìƒíƒœì—ì„œ í˜¼ì ë‚¨ì€ ê²½ìš°ëŠ” ìí•´ ê°€ëŠ¥)
        if (!isMindControlled || finalTargets.length > 1) {
            finalTargets = finalTargets.filter(t => t.id !== actingUnit.id);
        }
    }

    // 7. íƒ€ê²Ÿ ë Œë”ë§
    let targetClass = isSupportSkill ? 'target-ally' : 'target-enemy';
    if (isAOE && !isSupportSkill) targetClass = 'target-aoe';

    let targetCount = 0;

    finalTargets.forEach((t) => {
        const cardId = t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`;
        const el = document.getElementById(cardId);
        
        if (el) {
            el.classList.add(targetClass);
            el.onclick = () => {
                if (Game.isProcessing) return;
                Game.isProcessing = true;
                
                // ì…ë ¥ ì ê¸ˆ
                this.noInput();
                document.querySelectorAll('.unit').forEach(e => {
                    e.classList.remove('target-enemy', 'target-ally', 'target-aoe');
                });
                
                // ì‹¤í–‰
                this.execute(actingUnit, t, this.selectedSkillIdx);
            };
            targetCount++;
        }
    });

// 8. ë””ë²„ê¹… ë° ì˜ˆì™¸ ì²˜ë¦¬ (Option 2 ì ìš©)
    if (targetCount === 0) {
        console.warn('âš ï¸ No valid targets:', {
            skillIdx: this.selectedSkillIdx,
            targetType: targetType,
            actingUnit: actingUnit.name,
            isMindControlled: isMindControlled,
            finalTargets: finalTargets.map(t => t.name)
        });

        // íƒ€ê²Ÿì´ ì—†ëŠ” ê²½ìš° UI í”¼ë“œë°±
        if (isMindControlled && !isSupportSkill) {
            UI.floatText(actingUnit, "ëŒ€ìƒì—†ìŒ", "ft-miss");
            this.log(`<span class='log-sys'>âš ï¸ [${actingUnit.name}] ê³µê²©í•  ìˆ˜ ìˆëŠ” ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>`);
        } else if (!isMindControlled && finalTargets.length === 0) {
            console.error('ğŸš¨ Critical: No targets found in normal state!');
            UI.floatText(actingUnit, "íƒ€ê²Ÿì˜¤ë¥˜", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš¨ [${actingUnit.name}] íƒ€ê²ŸíŒ… ì˜¤ë¥˜ ë°œìƒ</span>`);
        }
        
        // âœ… ìŠ¤í‚¬ ì„ íƒ ì´ˆê¸°í™” ì¶”ê°€ (ë²„ê·¸ ìˆ˜ì •)
        this.selectedSkillIdx = -1;
        document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('selected'));
        return; // í•¨ìˆ˜ ì¢…ë£Œ
    }
}, // ì½¤ë§ˆ í•„ìˆ˜ (ë’¤ì— ai í•¨ìˆ˜ê°€ ìˆìŒ)


    // ========== 3997ë²ˆì§¸ ì¤„ë¶€í„° êµì²´ ==========
ai: function(u) {
        // [ê²€ì¦] ì˜¨ë¼ì¸, ë¡œì»¬ PVPë©´ AI ì‘ë™ ì¤‘ì§€
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;
        
        // 0. ê¸°ë³¸ ê²€ì¦
        if (!u || u.isDead) {
            this.endTurn(true);
            return;
        }

        try {
            this.log(`<span class='log-sys'>ğŸ¤– AI í–‰ë™ ì¤‘: ${u.name}</span>`);

            // 1. ì„¸ë‡Œ íŒì •
            const isBrainwashed = (this.isMindControlling && this.isMindControlling.id === u.id);
            if (isBrainwashed) {
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì„¸ë‡Œ ìƒíƒœë¡œ í–‰ë™!</span>`);
            }

            // 2. ì /ì•„êµ° ì‹ë³„
            let enemies, allies;
            if (isBrainwashed) {
                enemies = u.team === 0 ? this.pTeam : this.eTeam; // ì›ë˜ íŒ€ì´ ì 
                allies = u.team === 0 ? this.eTeam : this.pTeam;
            } else {
                enemies = u.team === 0 ? this.eTeam : this.pTeam; // ìƒëŒ€ íŒ€ì´ ì 
                allies = u.team === 0 ? this.pTeam : this.eTeam;
            }

            // 3. ìƒì¡´ì í•„í„°ë§
            let aliveEnemies = enemies.filter(e => !e.isDead && e.id !== u.id);
            const aliveAllies = allies.filter(a => !a.isDead);

            // [ì˜ˆì™¸] ì„¸ë‡Œ ìƒíƒœì¸ë° ê³µê²© ëŒ€ìƒ ì „ë©¸ ì‹œ ìí•´ í—ˆìš©
            if (aliveEnemies.length === 0 && isBrainwashed) {
                aliveEnemies = [u];
            }

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            // 4. ë„ë°œ(Taunt) ì²˜ë¦¬
            if (!isBrainwashed) {
                const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
                if (provoked) {
                    const targetId = parseInt(provoked.type.split('_')[2]);
                    const taunter = aliveEnemies.find(t => t.id === targetId);
                    if (taunter) {
                        this.execute(u, taunter, 0); // í‰íƒ€ ê°•ì œ
                        return;
                    }
                }
            }

            const silenced = u.hasStatus('SILENCE');
            const k = u.getKey();
            const sk = SKILL_DB[k];

            // ---------------------------------------------------------
            // ğŸ§  [AI Core] í—¬í¼ í•¨ìˆ˜ ì •ì˜ (Parsing Logic Fix)
            // ---------------------------------------------------------

            const isAttackSkill = (desc, type) => {
                if (!desc) return false;
                
                // [Fix V2] ê³µê²© í‚¤ì›Œë“œ ì²´í¬
                const hasAttackKeyword = desc.includes('ë°°') || desc.includes('ë„ë°œ') || desc.includes('ì†ë°•');
                const hasHealKeyword = desc.includes('í') || desc.includes('íšŒë³µ') || desc.includes('HP+');
                
                // í/íšŒë³µì´ ìˆìœ¼ë©´ ê³µê²© ìŠ¤í‚¬ ì•„ë‹˜
                if (hasHealKeyword) return false;
                
                // âœ… ì‰´ë“œ+ê³µê²© ë³µí•© ìŠ¤í‚¬ ì²˜ë¦¬ (Metal S1, S2, Water S2 ë“±)
                if (desc.includes('ì‰´ë“œ') && hasAttackKeyword) return true;
                
                // ìˆœìˆ˜ ì‰´ë“œë§Œ ìˆìœ¼ë©´ ê³µê²© ì•„ë‹˜ (ì„œí¬í„° ìŠ¤í‚¬)
                if (desc.includes('ì‰´ë“œ') && !hasAttackKeyword) return false;
                
                // ì¼ë°˜ ê³µê²© í‚¤ì›Œë“œ ì²´í¬
                if (hasAttackKeyword) return true;
                
                // type ê¸°ë°˜ ì²´í¬
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER', 'ATK'].includes(type)) return true;
                
                return false;
            };

            const isSupportSkill = (desc, type) => {
                if (!desc) return false;
                // [Fix] ê³µê²© í‚¤ì›Œë“œê°€ ìˆìœ¼ë©´ ë³´ì¡° ìŠ¤í‚¬ ì•„ë‹˜ìœ¼ë¡œ ê°•ì œ (ë‹¨, í+ê³µê²© ë³µí•©ê¸°ëŠ” ì œì™¸)
                if (desc.includes('ë°°') && !desc.includes('í') && !desc.includes('íšŒë³µ')) return false;
                if (desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return false;
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER'].includes(type)) return false;
                
                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼', 'ì„±ì¥', 'ê²°ì†', 'íšŒë³µ', 'HP+'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY', 'ALLY'];
                return supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type);
            };

            // âš”ï¸ [AI ì—…ë°ì´íŠ¸ V3] ê³µê²© ì ìˆ˜ ê³„ì‚° (ë„ë°œ/ë”œ ê³„ì‚° ìµœì í™”)
            const getAttackScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                
                // ğŸ›‘ ìì‚´ ë°©ì§€
                if (u.base === 'Normal' && skillIdx === 1 && u.hp <= 30) return -9999; 
                if (u.getKey() === 'Dark-Dark' && skillIdx === 2 && u.hp < u.maxHp * 0.15) return -5000;

                let score = 0;
                const skillDesc = skillIdx === 0 ? "ê¸°ë³¸ê³µê²©" : (skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || ""));
                
                let multiplier = 1.0;
                if (skillIdx > 0 && skillDesc) {
                    const match = skillDesc.match(/([\d.]+)ë°°/) || skillDesc.match(/([\d.]+)%/);
                    if (match) {
                        multiplier = parseFloat(match[1]);
                        if (skillDesc.includes('%')) multiplier /= 100;
                    }
                }

                const aff = Game.calc(u, target);
                const baseDmg = u.getAtk() * multiplier * aff.v;

                // A. í‚¬ ìºì¹˜ (Kill Catch) - ìµœìš°ì„ 
                if (baseDmg > 0 && target.hp <= baseDmg && !target.hasStatus('IMMORTAL')) {
                    score += 50000; 
                } else {
                    score += baseDmg;
                }
                
                // ğŸ§  ë‚­ë¹„ ë°©ì§€: ì  1ëª…ì¼ ë•Œ ê´‘ì—­ê¸° ì–µì œ
                if (aliveEnemies.length === 1 && ['AOE', 'ALL_ENEMY', 'NUKE_PER'].includes(sk.type) && skillIdx > 0) {
                    if (target.hp > baseDmg) score -= 2000;
                }

                // ğŸ§± ë²„í”„ íŒŒê´´ì (Earth)
                if (u.base === 'Earth' && skillIdx === 1) {
                    if (target.status.some(s => ['EVADE', 'shield', 'LIGHT_MIGHT', 'ATK_BUFF_SMALL'].includes(s.type) || target.shield > 0)) {
                        score += 2500; 
                    }
                }

                // B. ìƒì„± ìš°ìœ„
                if (aff.v > 1.0) score += 300;

                // [ì‹¬í™”] íƒ€ê²ŸíŒ… ìš°ì„ ìˆœìœ„
                const hpPct = target.hp / target.maxHp;
                if (hpPct < 0.4) score += 1500; // ì•½ì ë©¸ì‹œ
                
                const tKey = target.getKey();
                if (SKILL_DB[tKey] && SKILL_DB[tKey].role === 'supp') score += 1000; // íëŸ¬ ì ì‚¬

                // 3. ì‰´ë“œ ë‚­ë¹„ ë°©ì§€ (Metal ìƒëŒ€ë¡œ)
                if (target.base === 'Metal' && !target.extra && target.shield > 0) {
                    const dmgCap = target.maxHp * 0.3;
                    if (baseDmg > dmgCap * 1.5) score -= 3000; 
                }

                // 4. ê´‘ì—­ê¸° íš¨ìœ¨
                if (['AOE', 'ALL_ENEMY', 'NUKE_PER'].includes(sk.type) && skillIdx > 0) {
                    let aoeBonus = 0;
                    aliveEnemies.forEach(en => {
                        if (en.id === target.id) return;
                        const subAff = Game.calc(u, en);
                        const subDmg = u.getAtk() * multiplier * subAff.v;
                        aoeBonus += subDmg;
                        if (subDmg >= en.hp) aoeBonus += 2000;
                    });
                    score += aoeBonus;
                }

                // C. CC ì¤‘ë³µ ë°©ì§€ (ë„ë°œ ì¶”ê°€!)
                // ğŸŸ¢ [ìˆ˜ì •] 'ë„ë°œ'ì„ CC í‚¤ì›Œë“œì— í¬í•¨ì‹œì¼œ ê¸°ë³¸ ì ìˆ˜ë¥¼ ë°›ê²Œ í•¨
                const ccKeywords = ['ê¸°ì ˆ', 'ë¹™ê²°', 'ì¹¨ë¬µ', 'ì„¸ë‡Œ', 'ì†ë°•', 'ë„ë°œ', 'STUN', 'FREEZE', 'SILENCE'];
                if (ccKeywords.some(kw => skillDesc.includes(kw))) {
                    if (!target.hasStatus('IMMUNITY') && !target.isNormal) {
                        const hasHardCC = target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('MC_WAIT');
                        if (hasHardCC) score -= 3000;
                        else score += 500;
                    }
                }

                // ğŸ›¡ï¸ [AI í•µì‹¬] Metal(ì‡ ) ë„ë°œ ë¡œì§ ì™„ì „ ê°œí¸
                if (u.base === 'Metal' && !u.extra) {
                    const myProvokedTarget = aliveEnemies.find(e => e.status.some(s => s.type === `PROVOKED_BY_${u.id}`));
                    
                    if (myProvokedTarget) {
                        // ì´ë¯¸ ë„ë°œ ê±´ ìƒëŒ€ê°€ ìˆë‹¤ë©´
                        if (skillIdx === 2) {
                            score -= 5000; // ë„ë°œ ë˜ ì“°ì§€ ë§ˆ (í„´ ë‚­ë¹„)
                        } else if (skillIdx === 1 && target.id === myProvokedTarget.id) {
                            score += 3000; // ë„ë°œ ê±¸ë¦° ë†ˆ íŒ¨ì„œ ì‰´ë“œ ë¦¬í•„
                        }
                    } else {
                        // ğŸŸ¢ [í•µì‹¬] ë„ë°œ ëŒ€ìƒì´ ì—†ë‹¤ë©´ S2(ë„ë°œ) ìµœìš°ì„ !
                        if (skillIdx === 2) {
                            score += 6000; // í‚¬ê°(50000) ì œì™¸í•˜ê³  ë¬´ì¡°ê±´ 1ìˆœìœ„
                            
                            // ğŸ”¥ [ì¶”ê°€] ì•„ë¬´ë‚˜ ë„ë°œí•˜ì§€ ë§ê³ , 'ê³µê²©ë ¥ ë†’ì€ ì 'ì„ ìš°ì„  ë„ë°œ
                            if (target.atk) {
                                score += target.atk * 10; 
                            }
                        }
                    }
                }

                // D. ë°”ìœ„(Earth-Dark) S2 ê³¼ì‰ ì‚¬ìš© ë°©ì§€
                if (u.getKey() === 'Earth-Dark' && skillIdx === 2) {
                    score -= 3000; 
                    if (!target.hasStatus('STUN') && !target.hasStatus('FREEZE')) {
                         score += 3500;
                    }
                }

                // E. ê³ ë‚œì´ë„ í‰íƒ€ ì–µì œ
                if (this.difficulty !== 'easy' && skillIdx === 0) {
                     if (!u.hasStatus('SILENCE')) score -= 2000;
                }

                return score;
            };

            // ğŸ›¡ï¸ ì§€ì› ì ìˆ˜ ê³„ì‚°
            const getSupportScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;

                // [AI Fix] ë‚˜ë¬´(Tree)ê°€ ì´ë¯¸ ìˆ˜í˜¸íƒœì„¸(ROOT_GUARD)ë©´ S1 ì‚¬ìš© ê¸ˆì§€
                if (u.base === 'Tree' && !u.extra && skillIdx === 1) {
                    if (u.hasStatus('ROOT_GUARD')) return -9999;
                }

                let score = 0;
                const skillDesc = skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || "");
                // A. í íš¨ìœ¨
                if (skillDesc.includes('í') || skillDesc.includes('HP') || sk.type === 'HEAL') {
                    const pct = target.hp / target.maxHp;
                    if (pct < 0.35) score += 5000; 
                    else if (pct > 0.9) score -= 2000; 
                    else score += (target.maxHp - target.hp) * 2.0;
                }

                // B. ì •í™” ìš°ì„ ìˆœìœ„
                if (skillDesc.includes('ì •í™”')) {
                    if (target.status.length > 0) score += 500;
                    if (target.getKey() === 'Earth-Dark' && target.hasStatus('STUN')) score += 8000; 
                    if (target.hasStatus('STUN') || target.hasStatus('FREEZE')) score += 2000;
                }

                // C. ì‰´ë“œ ë‚­ë¹„ ë°©ì§€
                if (skillDesc.includes('ì‰´ë“œ')) {
                    if (target.shield >= 300) score -= 5000; 
                    else if (target.shield < 50) score += 500;
                }

                // D. ìê°€ ë²„í”„
                if (target.id === u.id && (skillDesc.includes('ì„±ì¥') || sk.type === 'SELF_BUFF')) score += 400;

                // E. í‘¸ë¥¸ë¶ˆ(Fire-Light) ìµœì í™” (ì¤‘ë³µ ë°©ì§€)
                if (u.getKey() === 'Fire-Light') {
                    if (skillIdx === 1) { 
                        if (target.hasStatus('LIFESTEAL_BUFF')) {
                            score -= 5000;
                        } else {
                            const lowestHpAlly = aliveAllies.reduce((min, a) => Math.min(min, a.hp / a.maxHp), 1);
                            if (lowestHpAlly > 0.85) score -= 3000; 
                            else score += 3000; 
                        }
                    } else if (skillIdx === 2) { 
                        score += 500; 
                    }
                }

                return score;
            };

            // ---------------------------------------------------------
            // ğŸš€ í–‰ë™ ëª©ë¡ ìƒì„± ë° ì„ íƒ
            // ---------------------------------------------------------
            let actions = [];

            // A. ê³µê²© í–‰ë™ ìˆ˜ì§‘
            aliveEnemies.forEach(e => {
                actions.push({ idx: 0, target: e, score: getAttackScore(e, 0), type: 'attack' });
                if (!silenced) {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isAttackSkill(desc, sk.type)) {
                            if (k === 'Tree-Dark' && i === 2) return; 
                            actions.push({ idx: i, target: e, score: getAttackScore(e, i), type: 'attack' });
                        }
                    });
                }
            });

            // B. ì§€ì› í–‰ë™ ìˆ˜ì§‘
            if (!silenced) {
                aliveAllies.forEach(a => {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isSupportSkill(desc, sk.type)) {
                            if ((sk.type === 'SELF_BUFF' || sk.type === 'SELF') && a.id !== u.id) return;
                            if (k === 'Tree-Dark' && i === 2 && a.id === u.id) return; 
                            actions.push({ idx: i, target: a, score: getSupportScore(a, i), type: 'support' });
                        }
                    });
                });
            }

            // ë””ë²„ê·¸ ë¡œê·¸
            if (typeof DEBUG !== 'undefined' && DEBUG.enabled) {
                console.groupCollapsed(`ğŸ¤– [${u.name}] í–‰ë™ ì„ íƒ`);
                const debugActions = [...actions].sort((a, b) => b.score - a.score);
                debugActions.slice(0, 5).forEach(a => console.log(`${a.idx===0?'í‰íƒ€':(a.idx===1?'S1':'S2')} -> ${a.target.name} (${a.score.toFixed(0)})`));
                console.groupEnd();
            }

            // C. ìµœì  í–‰ë™ ì„ íƒ
            actions.sort((a, b) => (b.score + Math.random()*10) - (a.score + Math.random()*10));
            let best = actions[0];

            if (!best || !best.target || best.score < -5000) {
                best = { 
                    idx: 0, 
                    target: aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)],
                    type: 'attack'
                };
            }

            if (!isBrainwashed && best.target && best.target.team === u.team) {
                const info = best.idx === 0 ? "í‰íƒ€" : (best.idx === 1 ? sk.s1d : sk.s2d);
                if (best.type === 'attack' || (info && info.includes('ë°°') && sk.type !== 'HEAL')) {
                    best.target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
                    best.idx = 0;
                }
            }

            this.execute(u, best.target, best.idx);

        } catch (e) {
            console.error("AI Logic Critical Error:", e);
            this.endTurn(); 
        }
    },

    die: function(u) {
        if (u.isDead) return;
        u.isDead = true;
        u.hp = 0;
        
        // [Fix] ì¦‰ê°ì ì¸ ì‹œê°ì  í”¼ë“œë°± (ì£½ì€ ëˆˆ)
        const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(cardId);
        if (el) el.classList.add('dead');

        // [ìˆ˜ì •] 1. ì‚¬ë§í•œ ìœ ë‹›(u)ì´ ì‹œì „í•œ 'ì„¸ë‡Œ ëŒ€ê¸°(MC_WAIT)' ìƒíƒœ ëª¨ë‘ ì œê±°
        [...Game.pTeam, ...Game.eTeam].forEach(target => {
            const wait = target.status.find(s => s.type === 'MC_WAIT');
            if (wait && wait.sourceId === u.id) {
                target.status = target.status.filter(s => s.type !== 'MC_WAIT');
                Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì([${u.name}]) ì‚¬ë§ìœ¼ë¡œ [${target.name}]ì˜ ì„¸ë‡Œ ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
        });

        // [ìˆ˜ì •] 2. í˜„ì¬ 'ì¡°ì¢… ì¤‘'ì¸ ìƒíƒœì—ì„œ ì‹œì „ìê°€ ì£½ì—ˆì„ ë•Œ ê°•ì œ í•´ì œ
        // this.currentMCCasterIdëŠ” ìœ„ì—ì„œ ìƒˆë¡œ ì¶”ê°€í•œ ë³€ìˆ˜ì…ë‹ˆë‹¤.
        if (this.isMindControlling && (this.currentMCCasterId === u.id || !this.currentMCCasterId)) {
             const puppet = this.isMindControlling;
             
             // ì„¸ë‡Œ ìƒíƒœ ì•„ì´ì½˜ ì œê±° (MC_READY ë“± ì”ì—¬ë¬¼)
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             
             this.isMindControlling = null;
             this.currentMCCasterId = null;
             
             Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì ì‚¬ë§! [${puppet.name}]ì˜ ì •ì‹  ì§€ë°°ê°€ ì¦‰ì‹œ í’€ë¦½ë‹ˆë‹¤.</span>`);
             UI.floatText(puppet, "ì§€ë°° í•´ì œ", "ft-heal");
             
             // UI ë³µêµ¬
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab"; 
        }
		
        u.status = [];
        Game.log(`${u.name} íƒˆë½`);
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => {
                if (!e.isDead) e.addStatus('POISON', 1, 0, u);
            });
        }
        const allies = u.team === 0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base === 'Tree' && a.extra === 'Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.revengeAtk += 20;
            thorn.thornStack += 0.3;
            thorn.linkedAllyId = -1;
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`);
            UI.floatText(thorn, "RAGE!", "ft-crit");
        });
    },
    endCheck: function() {
        const pd = this.pTeam.every(u => u.isDead);
        const ed = this.eTeam.every(u => u.isDead);

        if (pd || ed) {
            this.isOver = true;
            if (this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN');
            MusicEngine.stop(); // [Fix] ì‹ í˜• ì—”ì§„ ì •ì§€

            // [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ìŠ¹ë¦¬/íŒ¨ë°° ì²˜ë¦¬ (start() ì¬í˜¸ì¶œë¡œ ì—°ê²°)
            if (this.difficulty === 'tutorial') {
                if (pd) { // íŒ¨ë°°
                    UI.showModal("Defeat... ğŸ˜¢", 
                        `<p>ê´œì°®ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!</p>
                         <button onclick="Game.start()" 
                         style="padding:10px 20px; background:#ff7043; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ì¬ë„ì „ ğŸ”„
                         </button>`
                    );
                } else { // ìŠ¹ë¦¬
                     UI.showModal("Victory! ğŸ“", 
                        `<p>í›Œë¥­í•©ë‹ˆë‹¤! í•µì‹¬ ì „ëµì„ ì´í•´í•˜ì…¨êµ°ìš”.</p>
                         <button onclick="Game.tStage++; Game.start();" 
                         style="padding:10px 20px; background:#4caf50; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ë‹¤ìŒ ë ˆìŠ¨ìœ¼ë¡œ â¡ï¸
                         </button>`
                    );
                }
                return true;
            }

// [ì‹ ê·œ] íŠœí† ë¦¬ì–¼ ìŠ¹ë¦¬/íŒ¨ë°° ì²˜ë¦¬ ì¸í„°ì…‰íŠ¸
            if (this.difficulty === 'tutorial') {
                if (pd) { // íŒ¨ë°° (Player Dead)
                    UI.showModal("Defeat... ğŸ˜¢", 
                        `<p>ê´œì°®ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!</p>
                         <button onclick="Game.runTutorialLevel()" 
                         style="padding:10px 20px; background:#ff7043; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ì¬ë„ì „ ğŸ”„
                         </button>`
                    );
                } else { // ìŠ¹ë¦¬
                     UI.showModal("Victory! ğŸ“", 
                        `<p>í›Œë¥­í•©ë‹ˆë‹¤! í•µì‹¬ ì „ëµì„ ì´í•´í•˜ì…¨êµ°ìš”.</p>
                         <button onclick="Game.tStage++; Game.runTutorialLevel();" 
                         style="padding:10px 20px; background:#4caf50; color:white; border:none; border-radius:10px; font-size:16px; cursor:pointer;">
                         ë‹¤ìŒ ë ˆìŠ¨ìœ¼ë¡œ â¡ï¸
                         </button>`
                    );
                }
                return true; // ì—¬ê¸°ì„œ ì¢…ë£Œ (ê¸°ë³¸ ê²°ê³¼ì°½ ì¶œë ¥ ë°©ì§€)
            }

            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) {
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if (this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)");
            }
            localStorage.removeItem('et_save_v6');
            return true;
        }
        return false;
    },
    log: function(m) {
        const b = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.innerHTML = m;
        b.appendChild(d);
        b.scrollTop = b.scrollHeight;
    },
    shake: function(u) {
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('shake');
            void el.offsetWidth;
            el.classList.add('shake');
        }
    },
    saveGame: function() {
        if (this.isOver) {
            alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue,
            curr: this.curr,
            turnCount: this.turnCount,
            difficulty: this.difficulty,
            mode: this.mode,
            selected: this.selected,
            // [Fix] ì„¸ë‡Œ ë°ì´í„° ì €ì¥ ì¶”ê°€
            mcCasterId: this.currentMCCasterId || null,
            mcTargetId: this.isMindControlling ? this.isMindControlling.id : null
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },
    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if (savedStage) this.challengeStage = parseInt(savedStage);
        if (!json) {
            alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`);
            return;
        }
        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty;
            this.mode = data.mode;
            this.turnCount = data.turnCount;
            this.curr = data.curr;
            this.queue = data.queue;
            this.selected = data.selected;
            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));
            
            // [ì¶”ê°€] ì„¸ë‡Œ ìƒíƒœ ë³µêµ¬
            this.isMindControlling = null;
            this.currentMCCasterId = data.mcCasterId || null;
            if (data.mcTargetId !== null && data.mcTargetId !== undefined) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                const puppet = allUnits.find(u => u.id === data.mcTargetId);
                if (puppet && !puppet.isDead) {
                    this.isMindControlling = puppet;
                    this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ìƒíƒœë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.</span>");
                }
            }

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
            if (!u) {
                alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
                return;
            }
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) {
            console.error('Save Load Error:', e);
            alert(`âš ï¸ ì„¸ì´ë¸Œ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në°ì´í„°ê°€ ì†ìƒë˜ì—ˆê±°ë‚˜ ë²„ì „ì´ ë‹¤ë¦…ë‹ˆë‹¤.\n(ì˜¤ë¥˜ ë‚´ìš©: ${e.message})`);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì´ˆê¸°í™”í•˜ì—¬ ê¼¬ì„ ë°©ì§€
            localStorage.removeItem('et_save_v6'); 
        }
    },
    serializeUnit: function(u) {
        return {
            id: u.id,
            team: u.team,
            base: u.base,
            extra: u.extra,
            hp: u.hp,
            maxHp: u.maxHp,
            shield: u.shield,
            atk: u.atk,
            status: u.status,
            isDead: u.isDead,
            thornStack: u.thornStack,
            linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count,
            elecStacks: u.elecStacks,
            growthStack: u.growthStack,
            stats: u.stats,
            passiveTriggered: u.passiveTriggered,
            revengeAtk: u.revengeAtk,
            isSuper: u.isSuper
        };
    },
    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp;
        u.maxHp = d.maxHp;
        u.shield = d.shield;
        u.atk = d.atk;
        u.status = d.status;
        u.isDead = d.isDead;
        if (d.thornStack) u.thornStack = d.thornStack;
        if (d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if (d.s2Count) u.s2Count = d.s2Count;
        if (d.elecStacks) u.elecStacks = d.elecStacks;
        if (d.growthStack) u.growthStack = d.growthStack;
        if (d.stats) u.stats = d.stats;
        if (d.passiveTriggered) u.passiveTriggered = d.passiveTriggered;
        if (d.revengeAtk) u.revengeAtk = d.revengeAtk;
        if (d.isSuper) u.isSuper = d.isSuper;
        return u;
    },
    // ë°ë¯¸ì§€ ì˜ˆì¸¡ ê³„ì‚°ê¸°
    predictDmg: function(target) {
        if (this.selectedSkillIdx === -1 || !target) return 0;
        
        // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì) ì°¾ê¸°
        let atkUnit;
        if (this.isMindControlling) {
            atkUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            if (tVal === undefined || tVal === null) return 0;
            atkUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal/2)] : this.eTeam[Math.floor((tVal-1)/2)];
        }
        if (!atkUnit || atkUnit.isDead) return 0;

        const k = atkUnit.getKey();
        const s = SKILL_DB[k];
        if (!s) return 0;
        
        let mult = 1.0;
        
        if (this.selectedSkillIdx === 0) {
            mult = 1.0;
        } else {
            const desc = this.selectedSkillIdx === 1 ? s.s1d : s.s2d;
            if (!desc) return 0;
            
            // ë¹„ê³µê²© ìŠ¤í‚¬ íƒ€ì… í•„í„°ë§
            const nonAtkTypes = ['HEAL', 'BUFF', 'ALLY', 'ALL_ALLY', 'SELF_BUFF', 'TARGET_BUFF'];
            if (s.type && nonAtkTypes.includes(s.type)) return 0;
            if (desc.includes('í') || desc.includes('ì‰´ë“œ') || desc.includes('ì •í™”')) return 0;
            
            const match = desc.match(/([\d.]+)ë°°/);
            if (match) mult = parseFloat(match[1]);
        }

        const baseAtk = atkUnit.getAtk();
        const aff = this.calc(atkUnit, target);
        return Math.floor(baseAtk * mult * aff.v);
    },
    calc: (a, d) => {
        let v = 1.0;
        let t = '';
        if (a.isNormal) {
            if (d.isNormal || d.isEnhanced) {
                v = 1.2;
                t = '(ê°•íƒ€)';
            }
        } else {
            const w = {
                'Fire': ['Metal', 'Tree'],
                'Water': ['Fire', 'Metal'],
                'Tree': ['Water', 'Earth'],
                'Metal': ['Tree', 'Earth'],
                'Earth': ['Fire', 'Water']
            };
            const ew = {
                'Light': ['Dark'],
                'Dark': ['Light']
            };
            // [Balance] ê¸°ì´ˆ 5ì†ì„± ì •ì˜
            const basicElements = ['Fire', 'Water', 'Tree', 'Metal', 'Earth'];

            if (d.isNormal) {
                // [ìˆ˜ì •] ìˆœìˆ˜ ê¸°ì´ˆ 5ì†ì„±(ë³´ì¡° ì†ì„±ì´ ì—†ëŠ” ê²½ìš°)ì—ê²Œë§Œ 1.2ë°° í”¼í•´
                // Light, Darkê°€ ì„ì¸ ë³µí•© ì†ì„±ì´ë‚˜, ìˆœìˆ˜ Light/Darkì—ê²ŒëŠ” 1.0ë°°
                if (basicElements.includes(a.base) && !a.extra) {
                    v = 1.2;
                    t = '(ì•½ì )';
                }
            } else {
                if (w[a.base]?.includes(d.base) || ew[a.base]?.includes(d.base)) {
                    v = 1.2;
                    t = '(ì•½ì )';
                } else if (w[d.base]?.includes(a.base)) {
                    v = 0.8;
                    t = '(ì €í•­)';
                }
            }
        }
        if (v === 1.2 && a.extra && d.extra && ((a.extra === 'Light' && d.extra === 'Dark') || (a.extra === 'Dark' && d.extra === 'Light'))) {
            v = 1.3;
            t = '(ì¹˜ëª…íƒ€!)';
        }
        return {
            v,
            t
        };
    }
};

window.onload = function() {
    Game.init();
};
</script>
</body>
</html>
